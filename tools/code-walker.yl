(def instructions
    '((HALT ())
      (VOID $next)
      (CONST (v . $next))
      (LREF (n . $next))
      (FREF (n . $next))
      (GREF (sym . $next))
      (LSET (n . $next))
      (FSET (n . $next))
      (GSET (sym . $next))
      (DEF (sym . $next))
      (PUSH $next)
      (TEST ($then . $else))
      (CLOSE (nparam nfree $body . $next))
      (FRAME ($cont . $ret))
      (APPLY (n))
      (RET ())
      (UNFRAME ())
      (TAPPLY (n))
      (LOOP (offset n . $next))
      (BOX (n . $next))
      (UNBOX $next)
      (CONTI (tail . $next))
      (SETJMP (offset $body . $next))
      (LONGJMP ())
      (MACRO (name nparam nfree $body . $next))
      (ADDSP (n . $next))
      (LOCAL (offset . $next))
      (VALS (n . $next))
      (RECV (offset n . $next))
      (NIL $next)
      (CAR $next)
      (CDR $next)
      (ADD (n . $next))
      (SUB (n . $next))
      (NEG $next)
      (MUL (n . $next))
      (DIV (n . $next))
      (INV $next)
      (EQ $next)
      (LT (n . $next))
      (LE (n . $next))
      (GT (n . $next))
      (GE (n . $next))
      ))

(def *opcode-table* (table))
(dolist (inst instructions)
  (table-put! *opcode-table* (car inst)
              (map [eq? (char-at (string _) 0) #\$]
                   (cadr inst))))

(defun vm-walker (code f)
  (let1 h (create-ss-table code)
    (let recur ((code code))
      (let1 index (table-get h code)
        (when (or (not index) (>= index 0))
          (table-put! h code -1)
          (let1 op (car code)
            (aif (f code recur)
                 (recur it)
              (alet ((p (table-get *opcode-table* op))
                     (c (cdr code)))
                (if (pair? p)
                    (do (when (car p)
                          (recur (car c)))
                        (loop (cdr p) (cdr c)))
                  (when p
                    (recur c)))))))))))

(defun files-or-stdin (args f)
  (if args
      (dolist (filename args)
        (let1 ss (open filename)
          (f ss)
          (close ss)))
    (f *stdin*)))
