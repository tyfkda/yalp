;; Yalp traversal compiler

; Stack usage:
;    c   ... closure
;    s   ... stack pointer
;    f   ... frame pointer (stack index)
;    ret ... next code
;
; * Initial
;   f = s = 0
;
; * Function call
;   1. Use FRAME opcode to create new frame on stack:
;     f[c][f][ret]s
;   2. Push function arguments to stack on reverse order:
;     f[c][f][ret][a3][a2][a1]s
;   3. Use APPLY opcode to apply function,
;      then argument number is pushed to stack:
;     [c][f][ret][a3][a2][a1]f[argnum]s
;
; * Return
;   1. Get called argument number from stack:
;     [c][f][ret][a3][a2][a1]f
;   2. Put back previous frame:
;     f = s = 0
; * Shift
;   1. Put next function arguments:
;     [c][f][ret][a3][a2][a1]f[argnum][b1]s
;   2. Use SHIFT opcode to remove previous function arguments:
;     [c][f][ret][b1]s
;   4. Use APPLY opcode to apply function,
;      then argument number is pushed to stack:
;     [c][f][ret][b1]f[argnum]s

;(load "./boot.yl")
;(load "./util.yl")

;;;;

;; Traverses lisp code and generate intermediate AST.
;;   x : code to be compiled.
;;   scope : code scope.
;;   @result : AST.
(defun traverse (x scope)
  (cond ((symbol? x)
         (traverse-refer x scope))
        ((pair? x)
         (let1 expanded (expand-macro x scope)
           (if (pair? expanded)
               (traverse-list expanded scope)
             (traverse expanded scope))))
        (t (list ':CONST x))))

(defun traverse-list (x scope)
  (record-case x
               ;; Special forms.
               (quote (obj) (list ':CONST obj))
               (^ (vars &body body)
                  (traverse-lambda vars body scope))
               (if (test then &rest rest)
                   (traverse-if test then rest scope))
               (set! (var val)
                     (traverse-set! var val scope))
               (def (var val)
                    (traverse-def var val scope))
               (call/cc (func)
                        (traverse-call/cc func scope))
               (defmacro (name vars &body body)
                 (traverse-defmacro name vars body scope))
               (values (&rest args)
                       (traverse-values args scope))
               (receive (vars vals &body body)
                        (traverse-receive vars vals body scope))
                ;; Other: normal forms.
               (t (let ((func (car x))
                        (args (cdr x)))
                    (cond ((direct-invoke? func)
                           (traverse-apply-direct (cadr func) (cddr func) args scope))
                          ((inline-function? func)
                           (traverse-inline-apply func args scope))
                          (t (traverse-apply func args scope)))))))

(defun traverse-refer (x scope)
  (cond ((member x (scope-local scope))       ; Bounded variable
         (list ':REF 'LREF x))
        ((member x (scope-upper-vars scope))  ; Free variable
         (register-fref x scope)
         (list ':REF 'FREF x))
        (t (list ':REF 'GREF x))))            ; Global variable

(defun traverse-set! (var val scope)
  (unless (symbol? var)
    (compile-error "`set!` requires symbol, but `%@`" var))
  (traverse var scope)
  (let* ((val-node (traverse val scope))
         (op (cond ((position var (scope-local scope)) 'LSET)
                   ((position var (scope-upper-vars scope))
                    (register-fref var scope)
                    'FSET)
                   (t 'GSET))))
    (unless (eq? op 'GSET)
      (register-set! var val-node scope))
    (list ':SET op var val-node)))

(defun traverse-def (var val scope)
  (unless (symbol? var)
    (compile-error "`def` requires symbol, but `%@`" var))
  (when (and (inline-function? var)
             (lambda-expression? val))
    (register-inline-function var val))
  (let1 val-node (traverse val scope)
    (register-set! var val-node scope)
    (list ':DEF var val-node)))

(defun traverse-if (test then rest scope)
  (when (and rest (cdr rest))
    (compile-error "malformed if"))
  (list ':IF (traverse test scope)
        (traverse then scope)
        (if rest
            (traverse (car rest) scope)
          '(:VOID))))

(defun traverse-call/cc (func scope)
  (list ':CONTI (traverse func scope)))

(defun traverse-lambda (vars body scope)
  (let* ((proper-vars (check-parameters vars))
         (inner-scope (create-scope proper-vars scope))
         (body-node (traverse-body body inner-scope)))
    (let1 varnum (if (eq? vars proper-vars)
                     (len vars)
                   (list (- (len proper-vars) 1)
                         -1))
      ;; Propagate to upper scope
      (propagate-scope inner-scope (scope-local inner-scope)
                       scope)
      ;; Returns lambda node
      (create-lambda-node inner-scope varnum body-node))))

(defun traverse-body (body scope)
  (map [traverse _ scope]
       body))

(defun traverse-apply (func args scope)
  (list ':APPLY (traverse func scope)
        (map [traverse _ scope] args)))

(defun traverse-inline-apply (sym args scope)
  (let1 lambda (get-inline-function-body sym)
    (traverse `(,lambda ,@args)
              scope)))

(defun traverse-apply-direct (vars body args scope)
  (let1 proper-vars (check-parameters vars)
    (let ((argnum (len args))
          (varnum (- (len proper-vars)
                     (if (eq? proper-vars vars) 0 1))))
      (if (no (eq? vars proper-vars))  ;; Has rest param.
          ;; Tweak arguments.
          (cond ((< argnum varnum)  ;; Error handled in the below.
                 (traverse-apply-direct proper-vars body args scope))
                ;; ((^(x y &rest z) ...) 1 2 3 4) => ((^(x y z) ...) 1 2 (list 3 4))
                ((> argnum varnum)
                 (traverse `((^ ,proper-vars ,@body)
                             ,@(take varnum args)
                             (list ,@(drop varnum args)))
                           scope))
                ;; ((^(x y &rest z) ...) 1 2) => ((^(x y z) ...) 1 2 '())
                (t (traverse-apply-direct proper-vars body (append args '(()))
                                          scope)))
        (if (eq? argnum varnum)
            (let1 args-node (map [traverse _ scope]
                                 args)
              (let* ((expanded-scope (expand-scope proper-vars scope))
                     (body-node (traverse-body body expanded-scope)))
                ;; Propagate to upper scope
                (propagate-scope expanded-scope proper-vars
                                 scope)
                ;; Returns lambda node
                (list ':INVOKE
                      expanded-scope
                      proper-vars
                      args-node
                      body-node)))
          (let1 which (if (< argnum varnum) "few" "many")
            (compile-error "Too %@ arguments, %@ for %@" which argnum varnum)))))))

(defun traverse-defmacro (name vars body scope)
  (let* ((proper-vars (check-parameters vars))
         (inner-scope (create-scope proper-vars scope))
         (body-node (traverse-body body inner-scope)))
    (let1 varnum (if (eq? vars proper-vars)
                     (len vars)
                   (list (- (len proper-vars) 1)
                         -1))
      ;; Propagate to upper scope
      (propagate-scope inner-scope (scope-local inner-scope)
                       scope)
      ;; Returns macro node
      (list ':MACRO
            inner-scope
            name
            varnum
            body-node))))

(defun traverse-values (args scope)
  (list ':VALS (map [traverse _ scope]
                    args)))

(defun traverse-receive (vars vals body scope)
  (let1 proper-vars (check-parameters vars)
    (let ((varnum (if (eq? vars proper-vars)
                      (len vars)
                    (list (- (len proper-vars) 1)
                          -1)))
          (val-node (traverse vals scope)))
      (let* ((expanded-scope (expand-scope proper-vars scope))
             (body-node (traverse-body body expanded-scope)))
        ;; Propagate to upper scope
        (propagate-scope expanded-scope proper-vars
                         scope)
        ;; Returns receive node
        (list ':RECV
              expanded-scope
              varnum
              val-node
              body-node)))))

;; Check function parameters are valid and returns proper vars.
(defun check-parameters (vars)
  (unless (list? vars)
    (compile-error "parameters must be list, but %@" vars))
  (let1 proper-vars (aif (position-if [or (eq? _ '&rest) (eq? _ '&body)] vars)
                         (let ((required (take it vars))
                               (rest (drop (+ it 1) vars)))
                           (unless (single? rest)
                             (compile-error "&rest requires only 1 name, but %@" rest))
                           (append! required rest))
                      vars)
    (aif (any? [no (symbol? _)] vars)
      (compile-error "parameter must be symbol, but `%@`" (car it)))
    (alet ((p proper-vars))
      (when p
        (when (member (car p) (cdr p))
          (compile-error "Duplicated parameter `%@`" (car p)))
        (loop (cdr p))))
    proper-vars))

(defun direct-invoke? (func)
  (and (pair? func)
       (eq? '^ (car func))))

(defun expand-macro (x scope)
  (let1 f (car x)
    (if (or (no (symbol? f))
            (member f (scope-local scope))
            (member f (scope-upper-vars scope)))
        x
      (macroexpand x))))

(defun macroexpand (exp)
  (let1 expanded (macroexpand-1 exp)
    (if (equal? expanded exp)
        exp
      (macroexpand expanded))))

;;;;
;; Scope

(defun create-scope (local oscope)
  (let ((upper-vars (if oscope
                        (append (scope-local oscope)
                                (scope-upper-vars oscope))
                      '()))
        (scope-id (gensym)))
    (list local upper-vars '() '() scope-id)))

(defun expand-scope (local oscope)
  (let1 expanded-vars (append local (scope-local oscope))
    (list expanded-vars
          (scope-upper-vars oscope)
          (scope-frees oscope)
          (scope-sets oscope)
          (scope-id oscope))))

(def scope-local       car)
(def scope-upper-vars  cadr)
(def scope-frees       caddr)
(def scope-sets        cadddr)
(def scope-id          caddddr)

(defun scope-local-set! (scope v)  (set-car! scope v))
(defun scope-upper-vars-set! (scope v)  (set-car! (cdr scope) v))
(defun scope-frees-set! (scope v)  (set-car! (cddr scope) v))
(defun scope-sets-set! (scope v)  (set-car! (cdddr scope) v))

(defun merge-scope-sets (sets1 sets2)
  ;; Elements of sets2 may be modified.
  (if sets1
      (let1 s (car sets1)
        (merge-scope-sets (cdr sets1)
                          (aif (assoc (car s) sets2)
                               (do (set-cdr! it (union (cdr s) (cdr it)))
                                   sets2)
                            (cons s sets2))))
    sets2))

(defun propagate-scope (inner-scope vars scope)
  (when scope
    (scope-frees-set! scope
                      (union (scope-frees scope)
                             (set-minus (scope-frees inner-scope) (scope-local scope))))
    (propagate-scope-sets scope inner-scope vars nil)))

(defun propagate-scope-sets (dst-scope src-scope vars to-inner)
  (let1 bleed-sets (let1 remove (if to-inner remove-if-not remove-if)
                     (remove [member (car _) vars]
                             (scope-sets src-scope)))
    (scope-sets-set! dst-scope
                     (merge-scope-sets bleed-sets
                                       (scope-sets dst-scope)))))

;; Registers free variable into scope and returns its index number.
(defun register-fref (x scope)
  (let1 frees (scope-frees scope)
    (if frees
        (aif (position x frees)
             it
          (let1 index (len frees)
            (set-cdr! (last frees) (cons x nil))
            index))
      (do (scope-frees-set! scope (cons x nil))
          0))))

(defun register-set! (x v scope)
  (aif (assoc x (scope-sets scope))
       (set-cdr! it
                 (cons v (cdr it)))
    (scope-sets-set! scope
                     (acons x (list v) (scope-sets scope)))))

;;;;
;; Lambda node

(defun create-lambda-node (scope varnum body-node)
  (list ':LAMBDA
        scope
        (cons nil nil)  ; body-slot
        varnum
        body-node))

(defun lambda-node? (node)
  (eq? (car node) ':LAMBDA))

(def lambda-scope-get      cadr)
(def lambda-body-slot-get  caddr)
(def lambda-varnum-get     cadddr)

;;;;

(defun compile-recur (tree scope next)
  (record-case tree
               (:CONST (x)
                       (list* 'CONST x next))
               (:VOID ()
                      (list* 'VOID next))
               (:REF (op sym)
                     (list* op (case op
                                 (LREF (position sym (scope-local scope)))
                                 (FREF (position sym (scope-frees scope)))
                                 (GREF sym)
                                 (t (error "Compile error for :REF %@:%@" op sym)))
                            (if (and (no (eq? op 'GREF))
                                     (assoc sym (scope-sets scope)))
                                (list* 'UNBOX next)
                              next)))
               (:SET (op var val)
                     (compile-recur val scope
                                    (list* op (case op
                                                (LSET (position var (scope-local scope)))
                                                (FSET (position var (scope-frees scope)))
                                                (GSET var)
                                                (t (error "Compile error for :SET %@:%@" op var)))
                                           next)))
               (:DEF (var val)
                     (compile-recur val scope
                                    (list* 'DEF var next)))
               (:IF (test then else)
                    (compile-recur test scope
                                   (list* 'TEST
                                          (compile-recur then scope next)
                                          (compile-recur else scope next))))
               (:LAMBDA (inner-scope body-slot varnum body)
                        (let ((frees (scope-frees inner-scope)))
                          (propagate-scope-sets inner-scope scope frees t)
                          ;; Set compiled body code to body-slot.
                          (copy-pair! body-slot
                                      (compile-body (scope-local inner-scope) body inner-scope (list 'RET)))
                          (collect-free frees scope
                                           (list* 'CLOSE varnum (len frees)
                                                  body-slot
                                                  next))))
               (:INVOKE (expanded-scope proper-vars args-node body)
                        (let ((vars (scope-local expanded-scope))
                              (frees (scope-frees expanded-scope)))
                          (propagate-scope-sets expanded-scope scope frees t)
                          (compile-args args-node scope
                                           (if proper-vars
                                               (let1 varnum (len proper-vars)
                                                 (list* 'EXPND varnum
                                                        (compile-body proper-vars body expanded-scope
                                                                      (if (tail? next)
                                                                          next
                                                                        (list* 'SHRNK varnum next)))))
                                             (compile-body '() body expanded-scope next)))))
               (:MACRO (inner-scope name varnum body)
                       (let ((vars (scope-local inner-scope))
                             (frees (scope-frees inner-scope)))
                         (propagate-scope-sets inner-scope scope frees t)
                         (collect-free frees scope
                                       (list* 'MACRO name varnum (len frees)
                                              (compile-body (scope-local inner-scope) body inner-scope (list 'RET))
                                              next))))
               (:APPLY (f args)
                       (let ((is-tail (tail? next))
                             (argnum (len args))
                             (lambda-node (can-goto? f scope)))
                         (if (and lambda-node
                                  (eq? (scope-id (lambda-scope-get lambda-node))
                                       (scope-id scope))  ; is in the same scope with target jump point.
                                  is-tail)
                             (let1 varnum (lambda-varnum-get lambda-node)
                               (if (pair? varnum)
                                   (error "Not implemented: rest param for loop")
                                 (do (unless (eq? argnum varnum)
                                       (compile-error "Illegal argnum, `%@` requires %@, but %@" (caddr f) varnum argnum))
                                     (compile-args args scope
                                                   (list* 'LOOP argnum
                                                          (lambda-body-slot-get lambda-node))))))
                           (let1 code (compile-args args scope
                                                    (compile-recur f scope
                                                                   (if is-tail
                                                                       (list 'TAPPLY argnum)
                                                                     (list 'APPLY argnum))))
                             (if is-tail
                                 code
                               (list* 'FRAME code next))))))
               (:CONTI (func)
                       (let* ((is-tail (tail? next))
                              (c (list* 'CONTI is-tail
                                        'PUSH
                                        (compile-recur func scope
                                                       (if is-tail
                                                           '(TAPPLY 1)  ;(SHIFT 1 APPLY 1)
                                                         '(APPLY 1))))))
                         (if is-tail
                             c
                           (list* 'FRAME c next))))
               (:VALS (args)
                      (let1 argnum (len args)
                        (if (eq? argnum 0)
                            (list* 'VOID next)
                          (compile-args args scope
                                        (list* 'VALS argnum next)))))
               (:RECV (expanded-scope varnum vals body)
                      (let ((frees (scope-frees expanded-scope)))
                        (propagate-scope-sets expanded-scope scope frees t)
                        (compile-recur vals scope
                                       (list* 'RECV varnum
                                              (compile-body (scope-local expanded-scope) body expanded-scope
                                                            (if (tail? next)
                                                                next
                                                              (list* 'SHRNK (if (pair? varnum)
                                                                                (+ (car varnum) 1)
                                                                              varnum)
                                                                     next)))))))
               (t (error "Unknown [%@]" tree))))

(defun compile-body (vars body scope next)
  (if body
      (make-boxes (scope-sets scope) vars
                  (alet ((body body))
                    (if body
                        (compile-recur (car body) scope
                                       (loop (cdr body)))
                      next)))
    (list* 'VOID next)))

(defun make-boxes (sets locals next)
  (alet ((vars locals)
         (n 0))
    (if vars
        (if (assoc (car vars) sets)
            (list* 'BOX n
                   (loop (cdr vars) (+ n 1)))
          (loop (cdr vars) (+ n 1)))
      next)))

(defun compile-args (args scope next)
  (if args
      (compile-args (cdr args) scope
                    (compile-recur (car args) scope
                                   (list* 'PUSH next)))
    next))

(defun collect-free (vars scope next)
  (if vars
      (collect-free (cdr vars) scope
                    (let1 x (car vars)
                      (aif (position x (scope-local scope))
                           (list* 'LREF it 'PUSH next)
                        (aif (position x (scope-frees scope))
                             (list* 'FREF it 'PUSH next)
                          (error "something wrong in collect-free [%@](%@)" x scope)))))
    next))

(defun can-goto? (f scope)
  (and (eq? (car f) ':REF)                      ; Function is simple reference.
       (let ((sym (caddr f))                    ; Symbol for the reference.
             (sets (scope-sets scope)))
         (awhen (assoc sym sets)
           (and (single? (cdr it))              ; Just 1 time assignment.
                (let1 node (cadr it)
                  (and (lambda-node? node)      ; Lambda node.
                       node)))))))

(defun tail? (next)
  (eq? (car next) 'RET))

;;;;
;; Declaim

(defmacro declaim (&rest defs)
  `(do ,@(map (^(sentence)
                (when (pair? sentence)
                  (case (car sentence)
                    (inline (do (dolist (sym (cdr sentence))
                                  (declaim-inline sym))
                                '(values)))
                    )))
              defs)))

(let1 *inline-functions* (table)
  (defun declaim-inline (sym)
    (table-put! *inline-functions* sym t))

  (defun inline-function? (sym)
    (and (symbol? sym)
         (table-exists? *inline-functions* sym)))

  (defun register-inline-function (sym func)
    (table-put! *inline-functions* sym func))

  (defun get-inline-function-body (sym)
    (table-get *inline-functions* sym))
  )

(defun lambda-expression? (exp)
  (and (pair? exp)
       (eq? (car exp) '^)))

;;;;

(let1 *exit-compile* nil
  (defun compile-error (&rest args)
    (apply format *stderr* args)
    (display "\n" *stderr*)
    (*exit-compile* nil))

  (defun compile (x)
    (call/cc
     (^(cc)
       (set! *exit-compile* cc)
       (let* ((scope (create-scope '() nil))
              (tree (traverse x scope)))
         (compile-recur tree scope (list 'HALT)))))))

(defun eval (x)
  (run-binary (compile x)))

(defun error (&rest all)
  (apply format *stderr* all)
  (exit 1))
