;; Traversal compiler

(defun caddr (x) (car (cddr x)))
(defun cdddr (x) (cdr (cddr x)))
(defun cadddr (x) (car (cdddr x)))
(defun cddddr (x) (cdr (cdddr x)))
(defun caddddr (x) (car (cddddr x)))
(defun cdddddr (x) (cdr (cddddr x)))

(defun append1 (ls x) (append ls (list x)))

;;;;

(defun create-scope (local oscope)
  (let1 upper-vars (if oscope
                       (append (scope-local oscope)
                               (scope-upper-vars oscope))
                     '())
    (list local upper-vars '() '())))

(defun scope-local (scope)  (car scope))
(defun scope-upper-vars (scope)  (cadr scope))
(defun scope-frees (scope)  (caddr scope))
(defun scope-sets (scope)  (cadddr scope))

(defun scope-local-set! (scope v)  (set-car! scope v))
(defun scope-upper-vars-set! (scope v)  (set-car! (cdr scope) v))
(defun scope-frees-set! (scope v)  (set-car! (cddr scope) v))
(defun scope-sets-set! (scope v)  (set-car! (cdddr scope) v))

;; Registers free variable into scope and returns its index number.
(defun register-fref (x scope)
  (let1 frees (scope-frees scope)
    (if frees
        (aif (find-index x frees)
             it
          (let1 index (len frees)
            (set-cdr! (last frees) (cons x nil))
            index))
      (do (scope-frees-set! scope (cons x nil))
          0))))

(defun register-set! (x v scope)
  (aif (assoc x (scope-sets scope))
       (set-cdr! it
                 (cons v (cdr it)))
    (scope-sets-set! scope
                     (acons x (list v) (scope-sets scope)))))

(defun remove-if (test seq)
  (alet ((p seq)
         (acc '()))
    (if p
        (loop (cdr p)
              (if (test (car p))
                  acc
                (cons (car p) acc)))
      (reverse! acc))))

(defun remove-if-not (test seq)
  (remove-if [no _] seq))

(defun merge-scope-sets (sets1 sets2)
  ;; Elements of sets2 may be modified.
  (if sets1
      (let1 s (car sets1)
        (merge-scope-sets (cdr sets1)
                          (aif (assoc (car s) sets2)
                               (do (set-cdr! it (union (cdr s) (cdr it)))
                                   sets2)
                            (cons s sets2))))
    sets2))

(defun propagate-scope (inner-scope scope)
  (when scope
    (scope-frees-set! scope
                      (union (scope-frees scope)
                             (set-minus (scope-frees inner-scope) (scope-local scope))))
    (let* ((inner-local (scope-local inner-scope))
           (bleed-sets (remove-if [member (car _) inner-local]
                                  (scope-sets inner-scope))))
      (scope-sets-set! scope
                       (merge-scope-sets bleed-sets
                                         (scope-sets scope))))))

;;;;

(defun traverse (x scope)
  (cond ((symbol? x)
         (traverse-refer x scope))
        ((pair? x)
         (traverse-list x scope))
        (t `(:CONST ,x))))

(defun traverse-refer (x scope)
  (aif (find-index x (scope-local scope))        ; Bounded variable
       (list ':REF 'LREF it x)
    (if (find-index x (scope-upper-vars scope))  ; Free variable
        (list ':REF 'FREF (register-fref x scope) x)
      (list ':REF 'GREF x x))))                  ; Global variable

(defun traverse-set! (var val scope)
  ;; TODO: Confirm var is symbol.
  (traverse var scope)
  (let1 val-node (traverse val scope)
    (aif (find-index var (scope-local scope))
         (do (register-set! var val-node scope)
             (list ':SET 'LSET it val-node))
      (if (find-index var (scope-upper-vars scope))
          (do (register-set! var val scope)
              (list ':SET 'FSET (register-fref var scope) val-node))
        (list ':SET 'GSET var val-node)))))

(defun traverse-def (var val scope)
  (let1 val-node (traverse val scope)
    (register-set! var val-node scope)
    (list ':DEF var val-node)))

(defun traverse-if (test then rest scope)
  (when (and rest (cdr rest))
    (compile-error "malformed if"))
  `(:IF ,(traverse test scope)
        ,(traverse then scope)
        ,(if rest
             (traverse (car rest) scope)
           '(:VOID))))

(defun traverse-list (x scope)
  (record-case x
               ;; Special forms.
               (quote (obj) (list ':CONST obj))
               (^ (vars &body body)
                  (traverse-lambda vars body scope))
               (if (test then &rest rest)
                   (traverse-if test then rest scope))
               (set! (var val)
                     (traverse-set! var val scope))
               (def (var val)
                    (traverse-def var val scope))
               (call/cc (func)
                        (traverse-call/cc func scope))
               (defmacro (name vars &body body)
                 (traverse-defmacro name vars body scope))
               (values (&rest args)
                       (traverse-values args scope))
               (receive (vars vals &body body)
                        (traverse-receive vars vals body scope))
               (t (let ((func (car x))
                        (args (cdr x)))
                    (traverse-apply func args scope)))))

(defun traverse-call/cc (func scope)
  `(:CONTI ,(traverse func scope)))

(defun traverse-lambda (vars body scope)
  (let* ((proper-vars (check-parameters vars))
         (inner-scope (create-scope proper-vars scope))
         (body-node (traverse-body body inner-scope)))
    ;; Propagate to upper scope
    (propagate-scope inner-scope scope)
    ;; Returns lambda node
    (list ':LAMBDA
          inner-scope
          (cons nil nil)  ; body-slot
          body-node)))

(defun lambda-node? (node)
  (eq? (car node) ':LAMBDA))

(defun lambda-scope-get (node)
  (cadr node))

(defun lambda-body-slot-get (node)
  (caddr node))

(defun traverse-body (body scope)
  (map [traverse _ scope]
       body))

(defun traverse-apply (func args scope)
  `(:APPLY ,(traverse func scope)
           ,(map [traverse _ scope] args)))

(defun traverse-defmacro (name vars body scope)
  (let* ((proper-vars (check-parameters vars))
         (inner-scope (create-scope proper-vars scope))
         (body-node (traverse-body body inner-scope)))
    ;; Propagate to upper scope
    (propagate-scope inner-scope scope)
    ;; Returns lambda node
    (list ':MACRO
          inner-scope
          name
          body-node)))

(defun traverse-values (args scope)
  `(:VALS ,(map [traverse _ scope]
                args)))

(defun traverse-receive (vars vals body scope)
  (let1 proper-vars (check-parameters vars)
    (let ((val-node (traverse vals scope))
          (inner-scope (create-scope proper-vars scope)))
      (let1 body-node (traverse-body body inner-scope)
        ;; Propagate to upper scope
        (propagate-scope inner-scope scope)
        ;; Returns receive node
        (list ':RECV
              inner-scope
              (len proper-vars)
              val-node
              body-node)))))

;;;;

(defun my-compile (code)
  (let* ((scope (create-scope '() nil))
         (tree (traverse (macroexpand-all code '())
                         scope)))
    ;(print/ss tree)
    (my-compile-recur tree scope '(HALT))))

(defun my-collect-free (vars scope next)
  (if vars
      (my-collect-free (cdr vars) scope
                       (let1 x (car vars)
                         (aif (find-index x (scope-local scope))
                              `(LREF ,it PUSH ,@next)
                           (aif (find-index x (scope-upper-vars scope))
                                `(FREF ,it PUSH ,@next)
                             (compile-error "something wrong in collect-free [%@](%@)" x scope)))))
    next))

(defun my-compile-recur (tree scope next)
  (record-case tree
               (:REF (op i sym)
                     (list* op i
                            (if (and (no (eq? op 'GREF))
                                     (assoc sym (scope-sets scope)))
                                (list* 'UNBOX next)
                              next)))
               (:SET (op i val)
                     (my-compile-recur val scope
                                       (list* op i next)))
               (:DEF (var val)
                     (my-compile-recur val scope
                                       (list* 'DEF var next)))
               (:MACRO (inner-scope name body)
                        (let ((vars (scope-local inner-scope))
                              (frees (scope-frees inner-scope)))
                          ;; Propagate upper-sets to inner-sets
                          (let ((bleed-sets (remove-if-not [member (car _) frees]
                                                           (scope-sets scope))))
                            (scope-sets-set! inner-scope
                                             (merge-scope-sets bleed-sets
                                                               (scope-sets inner-scope)))
                            (my-collect-free frees scope
                                             `(MACRO ,name
                                                     ,(len vars)
                                                     ,(len frees)
                                                     ,(my-compile-body body inner-scope (list 'RET))
                                                     ,@next)))))
               (:LAMBDA (inner-scope body-slot body)
                        (let ((vars (scope-local inner-scope))
                              (frees (scope-frees inner-scope)))
                          ;; Propagate upper-sets to inner-sets
                          (let ((bleed-sets (remove-if-not [member (car _) frees]
                                                           (scope-sets scope))))
                            (scope-sets-set! inner-scope
                                             (merge-scope-sets bleed-sets
                                                               (scope-sets inner-scope)))
                            ;; Set compiled body code to body-slot
                            (copy-pair! body-slot
                                        (my-compile-body body inner-scope (list 'RET)))
                            (my-collect-free frees scope
                                             `(CLOSE ,(len vars)
                                                     ,(len frees)
                                                     ,body-slot
                                                     ,@next)))))
               (:IF (test then else)
                    (my-compile-recur test scope
                                      `(TEST
                                        ,(my-compile-recur then scope next)
                                        ,@(my-compile-recur else scope next))))
               (:APPLY (f args)
                       (let ((is-tail (tail? next))
                             (argnum (len args))
                             (lambda-node (can-goto? f scope)))
                         (if (and lambda-node
                                  (eq? (lambda-scope-get lambda-node)
                                       scope)  ;; is in the same scope with target jump point.
                                  is-tail)
                             ;; TODO: Checks argument number.
                             (my-compile-args args scope
                                              (list* 'LOOP argnum
                                                     (lambda-body-slot-get lambda-node)))
                           (let1 code (my-compile-args args scope
                                                       (my-compile-recur f scope
                                                                         (if is-tail
                                                                             (list 'TAPPLY argnum)
                                                                           (list 'APPLY argnum))))
                             (if is-tail
                                 code
                               (list* 'FRAME code next))))))
               (:CONST (x)
                       (list* 'CONST x next))
               (:VOID ()
                      (list* 'VOID next))
               (:CONTI (func)
                       (let* ((is-tail (tail? next))
                              (c (list* 'CONTI is-tail
                                        'PUSH
                                        (my-compile-recur func scope
                                                          (if is-tail
                                                              '(TAPPLY 1)  ;(SHIFT 1 APPLY 1)
                                                            '(APPLY 1))))))
                         (if is-tail
                             c
                           (list* 'FRAME c next))))
               (:VALS (args)
                      (let1 argnum (len args)
                        (if (eq? argnum 0)
                            (list* 'VOID next)
                          (my-compile-args args scope
                                           (list* 'VALS argnum next)))))
               (:RECV (inner-scope varnum vals body)
                      (my-compile-recur vals scope
                                        (list* 'RECV varnum
                                               (my-compile-body body inner-scope
                                                                (list* 'SHRNK varnum next)))))
               (t `(UNKNOWN ,tree ,@next))))

(defun can-goto? (f scope)
  (and (eq? (car f) ':REF)                      ; Function is simple reference.
       (let ((sym (cadddr f))                   ; Symbol for the reference.
             (sets (scope-sets scope)))
         (awhen (assoc sym sets)
           (when (single? (cdr it))             ; Just 1 time assignment.
             (let1 node (cadr it)
               (when (lambda-node? node)        ; Lambda node.
                 node)))))))

(defun my-compile-body (body scope next)
  (if body
      (my-make-boxes (cadddr scope) (scope-local scope)
                     (alet ((body body))
                       (if body
                           (my-compile-recur (car body) scope
                                             (loop (cdr body)))
                         next)))
    (list* 'VOID next)))

(defun my-make-boxes (sets locals next)
  (alet ((vars locals)
         (n 0))
    (if vars
        (if (assoc (car vars) sets)
            (list* 'BOX n
                   (loop (cdr vars) (+ n 1)))
          (loop (cdr vars) (+ n 1)))
      next)))

(defun my-compile-args (args scope next)
  (if args
      (my-compile-args (cdr args) scope
                       (my-compile-recur (car args) scope
                                         `(PUSH
                                           ,@next)))
    next))

;;;;

(defun print/ss (x)
  (write/ss x)
  (display "\n"))

;(defun main (args)
;  (awhile (read)
;    (print/ss (my-compile it))))


(let1 x '(alet ((i 0))
           (when (< i 10)
             (print i)
             (loop (+ i 1))))
  (let1 code (my-compile x)
    (print/ss code)
    (let1 result (run-binary code)
      (print (list 'RESULT: result)))))
