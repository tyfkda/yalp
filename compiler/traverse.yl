;; Traversal compiler

(defun caddr (x) (car (cddr x)))
(defun cdddr (x) (cdr (cddr x)))
(defun cadddr (x) (car (cdddr x)))
(defun cddddr (x) (cdr (cdddr x)))
(defun caddddr (x) (car (cddddr x)))
(defun cdddddr (x) (cdr (cddddr x)))

(defun append1 (ls x) (append ls (list x)))

;;;;

(defun create-scope (local oscope)
  (let1 upper-vars (if oscope
                       (append (scope-local oscope)
                               (scope-upper-vars oscope))
                     '())
    (list local upper-vars '() '())))

(defun scope-local (scope)  (car scope))
(defun scope-upper-vars (scope)  (cadr scope))
(defun scope-frees (scope)  (caddr scope))
(defun scope-sets (scope)  (cadddr scope))

(defun scope-local-set! (scope v)  (set-car! scope v))
(defun scope-upper-vars-set! (scope v)  (set-car! (cdr scope) v))
(defun scope-frees-set! (scope v)  (set-car! (cddr scope) v))
(defun scope-sets-set! (scope v)  (set-car! (cdddr scope) v))

;; Registers free variable into scope and returns its index number.
(defun register-fref (x scope)
  (let1 frees (scope-frees scope)
    (if frees
        (aif (find-index x frees)
             it
          (let1 index (len frees)
            (set-cdr! (last frees) (cons x nil))
            index))
      (do (scope-frees-set! scope (cons x nil))
          0))))

(defun register-set! (x v scope)
  (aif (assoc x (scope-sets scope))
       (set-cdr! it
                 (cons v (cdr it)))
    (scope-sets-set! scope
                     (acons x (list v) (scope-sets scope)))))

(defun remove-if (test seq)
  (alet ((p seq)
         (acc '()))
    (if p
        (loop (cdr p)
              (if (test (car p))
                  acc
                (cons (car p) acc)))
      (reverse! acc))))

(defun remove-if-not (test seq)
  (remove-if [no _] seq))

(defun merge-scope-sets (sets1 sets2)
  ;; Elements of sets2 may be modified.
  (if sets1
      (let1 s (car sets1)
        (merge-scope-sets (cdr sets1)
                          (aif (assoc (car s) sets2)
                               (do (set-cdr! it (append (cdr s) (cdr it)))
                                   sets2)
                            (cons s sets2))))
    sets2))

(defun propagate-scope (inner-scope scope)
  (when scope
    (scope-frees-set! scope
                      (union (scope-frees scope)
                             (set-minus (scope-frees inner-scope) (scope-local scope))))
    (let* ((inner-local (scope-local inner-scope))
           (bleed-sets (remove-if [member (car _) inner-local]
                                  (scope-sets inner-scope))))
      (scope-sets-set! scope
                       (merge-scope-sets bleed-sets
                                         (scope-sets scope))))))

;;;;

(defun traverse (x scope)
  (cond ((symbol? x)
         (traverse-refer x scope))
        ((pair? x)
         (traverse-list x scope))
        (t `(:CONST ,x))))

(defun traverse-refer (x scope)
  (aif (find-index x (scope-local scope))        ; Bounded variable
       (list ':REF 'LREF it x)
    (if (find-index x (scope-upper-vars scope))  ; Free variable
        (list ':REF 'FREF (register-fref x scope) x)
      (list ':REF 'GREF x x))))                  ; Global variable

(defun traverse-set! (var val scope)
  ;; TODO: Confirm var is symbol.
  (traverse var scope)
  (let1 val-node (traverse val scope)
    (aif (find-index var (scope-local scope))
         (do (register-set! var val-node scope)
             (list ':SET 'LSET it val-node))
      (if (find-index var (scope-upper-vars scope))
          (do (register-set! var val scope)
              (list ':SET 'FSET (register-fref var scope) val-node))
        (list ':SET 'GSET var val-node)))))

(defun traverse-def (var val scope)
  (let1 val-node (traverse val scope)
    (list ':DEF var val-node)))

(defun traverse-if (test then rest scope)
  (when (and rest (cdr rest))
    (compile-error "malformed if"))
  `(:IF ,(traverse test scope)
        ,(traverse then scope)
        ,(if rest
             (traverse (car rest) scope)
           `(:VOID))))

(defun traverse-list (x scope)
  (record-case x
               ;; Special forms.
               (quote (obj) (list ':CONST obj))
               (^ (vars &body body)
                  (traverse-lambda vars body scope))
               (if (test then &rest rest)
                   (traverse-if test then rest scope))
               (set! (var val)
                     (traverse-set! var val scope))
               (def (var val)
                    (traverse-def var val scope))
               (t (let ((func (car x))
                        (args (cdr x)))
                    (traverse-apply func args scope)))))

(defun traverse-lambda (vars body scope)
  (let* ((proper-vars (check-parameters vars))
         (inner-scope (create-scope proper-vars scope))
         (body-node (traverse-body body inner-scope)))
    ;; Propagate to upper scope
    (propagate-scope inner-scope scope)
    ;; Returns lambda node
    (list ':LAMBDA
          inner-scope
          (cons nil nil)  ; body-slot
          body-node)))

(defun lambda-node? (node)
  (eq? (car node) ':LAMBDA))

(defun lambda-body-slot-get (node)
  (caddr node))

(defun traverse-body (body scope)
  (map [traverse _ scope]
       body))

(defun traverse-apply (func args scope)
  `(:APPLY ,(traverse func scope)
           ,(map [traverse _ scope] args)))

;;;;

(defun my-compile (code)
  (let* ((scope (create-scope '() nil))
         (tree (traverse (macroexpand-all code '())
                         scope)))
    (my-compile-recur tree scope '(HALT))))

(defun my-collect-free (vars scope next)
  (if vars
      (my-collect-free (cdr vars) scope
                       (let1 x (car vars)
                         (aif (find-index x (scope-local scope))
                              `(LREF ,it PUSH ,@next)
                           (aif (find-index x (scope-upper-vars scope))
                                `(FREF ,it PUSH ,@next)
                             (compile-error "something wrong in collect-free [%@](%@)" x scope)))))
    next))

(defun my-compile-recur (tree scope next)
  (record-case tree
               (:REF (op i sym)
                     (list* op i
                            (if (assoc sym (scope-sets scope))
                                (list* 'UNBOX next)
                              next)))
               (:SET (op i val)
                     (my-compile-recur val scope
                                       (list* op i next)))
               (:DEF (var val)
                     (my-compile-recur val scope
                                       (list* 'DEF var next)))
               (:LAMBDA (inner-scope body-slot body)
                        (let ((vars (scope-local inner-scope))
                              (frees (scope-frees inner-scope)))
                          ;; Propagate upper-sets to inner-sets
                          (let ((bleed-sets (remove-if-not [member (car _) frees]
                                                           (scope-sets scope))))
                            (scope-sets-set! inner-scope
                                             (merge-scope-sets bleed-sets
                                                               (scope-sets inner-scope)))
                            ;; Set compiled body code to body-slot
                            (copy-pair! body-slot
                                        (my-compile-body body inner-scope (list 'RET)))
                            (my-collect-free frees scope
                                             `(CLOSE ,(len vars)
                                                     ,(len frees)
                                                     ,body-slot
                                                     ,@next)))))
               (:IF (test then else)
                    (my-compile-recur test scope
                                      `(TEST
                                        ,(my-compile-recur then scope next)
                                        ,@(my-compile-recur else scope next))))
               (:APPLY (f args)
                       (let ((is-tail (tail? next))
                             (argnum (len args))
                             (goto (can-goto? f scope)))
                         (if (and is-tail goto)
                             ;; TODO: Checks argument number.
                             (my-compile-args args scope
                                              (list* 'LOOP argnum
                                                     goto))
                           (let1 code (my-compile-args args scope
                                                       (my-compile-recur f scope
                                                                         (if is-tail
                                                                             (list 'TAPPLY argnum)
                                                                           (list 'APPLY argnum))))
                             (if is-tail
                                 code
                               (list* 'FRAME code next))))))
               (:CONST (x)
                       (list* 'CONST x next))
               (:VOID ()
                      (list* 'VOID next))
               (t `(UNKNOWN ,tree ,@next))))

(defun can-goto? (f scope)
  (and (eq? (car f) ':REF)                      ; Function is simple reference.
       (no (eq? (cadr f) 'GREF))
       (let ((sym (cadddr f))                   ; Symbol for the reference.
             (sets (scope-sets scope)))
         (awhen (assoc sym sets)
           (when (single? (cdr it))             ; Just 1 time assignment.
             (let1 node (cadr it)
               (when (lambda-node? node)        ; Lambda node.
                 (lambda-body-slot-get node))))))))

(defun my-compile-body (body scope next)
  (if body
      (my-make-boxes (cadddr scope) (scope-local scope)
                     (alet ((body body))
                       (if body
                           (my-compile-recur (car body) scope
                                             (loop (cdr body)))
                         next)))
    (list* 'VOID next)))

(defun my-make-boxes (sets locals next)
  (alet ((vars locals)
         (n 0))
    (if vars
        (if (assoc (car vars) sets)
            (list* 'BOX n
                   (loop (cdr vars) (+ n 1)))
          (loop (cdr vars) (+ n 1)))
      next)))

(defun my-compile-args (args scope next)
  (if args
      (my-compile-args (cdr args) scope
                       (my-compile-recur (car args) scope
                                         `(PUSH
                                           ,@next)))
    next))

;;;;

(defun print/ss (x)
  (write/ss x)
  (display "\n"))

(defun main (args)
  (awhile (read)
    (print/ss (my-compile it))))


;(let1 x '(alet ((i 0))
;           (if (< i 5)
;               (loop (+ i 1))
;             i))
;  (let1 code (my-compile x)
;    (print/ss code)
;    (let1 result (run-binary code)
;      (print (list 'RESULT: result)))))
