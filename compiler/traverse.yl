;; Traversal compiler

(defun caddr (x) (car (cddr x)))
(defun cdddr (x) (cdr (cddr x)))
(defun cadddr (x) (car (cdddr x)))
(defun cddddr (x) (cdr (cdddr x)))
(defun caddddr (x) (car (cddddr x)))
(defun cdddddr (x) (cdr (cddddr x)))

(defun append1 (ls x) (append ls (list x)))

;;;;

(defun create-scope (local oscope)
  (let1 upper-vars (if oscope
                       (append (scope-local oscope)
                               (scope-upper-vars oscope))
                     '())
    (list local upper-vars '() '())))

(defun scope-local (scope)  (car scope))
(defun scope-upper-vars (scope)  (cadr scope))
(defun scope-frees (scope)  (caddr scope))
(defun scope-sets (scope)  (cadddr scope))

(defun scope-local-set! (scope v)  (set-car! scope v))
(defun scope-upper-vars-set! (scope v)  (set-car! (cdr scope) v))
(defun scope-frees-set! (scope v)  (set-car! (cddr scope) v))
(defun scope-sets-set! (scope v)  (set-car! (cdddr scope) v))

(defun register-fref (x scope)
  (let1 p (cddr scope)
    (unless (member x (car p))
      (set-car! p
                (cons x (car p))))))

(defun register-set! (x v scope)
  (aif (assoc x (scope-sets scope))
       (set-cdr! it
                 (cons v (cdr it)))
    (scope-sets-set! scope
                     (acons x v (scope-sets scope)))))

(defun remove-if (test seq)
  (alet ((p seq)
         (acc '()))
    (if p
        (loop (cdr p)
              (if (test (car p))
                  (cons (car p) acc)
                acc))
      (reverse! acc))))

(defun propagate-scope (inner-scope scope)
  (when scope
    (scope-frees-set! scope
                      (union (scope-frees scope)
                             (set-minus (scope-frees inner-scope) (scope-local scope))))
    ;(scope-sets-set! scope
    ;                 (let ((local (scope-local scope)))
    ;                   (set-union (scope-sets inner-scope)
    ;                              (remove-if [member (car _) local]
    ;                                         (scope-local inner-scope)))))))
    ))

;;;;

(defun traverse (x scope)
  (cond ((symbol? x)
         (traverse-refer x scope))
        ((pair? x)
         (traverse-list x scope))
        (t `(:CONST ,x))))

(defun traverse-refer (x scope)
  (aif (find-index x (scope-local scope))
      `(:LREF ,it)
    (aif (find-index x (scope-upper-vars scope))
         (do (register-fref x scope)
             `(:FREF ,x))
      `(:GREF ,x))))

(defun traverse-list (x scope)
  (record-case x
               ;; Special forms.
               (quote (obj) (list* 'CONST obj next))
               (^ (vars &body body)
                  (traverse-lambda vars body scope))
               (if (test then &rest rest)
                   (traverse-if test then rest scope))
               (set! (var val)
                     (traverse-set! var val scope))
               (def (var val)
                    (traverse-def var val scope))
               (t (let ((func (car x))
                        (args (cdr x)))
                    (traverse-apply func args scope)))))

(defun traverse-if (test then rest scope)
  (when (and rest (cdr rest))
    (compile-error "malformed if"))
  `(:IF ,(traverse test scope)
        ,(traverse then scope)
        ,(if rest
             (traverse (car rest) scope)
           `(:VOID))))

(defun traverse-set! (var val scope)
  (register-set! var val scope)
  (let1 val-node (traverse val scope)
    (aif (find-index var (car scope))
         (list ':LSET it val-node)
      (aif (find-index var (caddr scope))
           (list ':FSET it val-node)
        (list ':GSET var val-node)))))

(defun traverse-def (var val scope)
  (let1 val-node (traverse val scope)
    (list ':DEF var val-node)))

(defun traverse-lambda (vars body scope)
  (let* ((proper-vars (check-parameters vars))
         (inner-scope (create-scope vars scope))
         (node `(:LAMBDA ,inner-scope
                         ,(traverse-body body inner-scope))))
    ;; Propagate to upper scope
    (propagate-scope inner-scope scope)
    node))

(defun traverse-body (body scope)
  (map [traverse _ scope]
       body))

(defun traverse-apply (func args scope)
  `(:APPLY ,(traverse func scope)
           ,(map [traverse _ scope] args)))

;;;;

(defun my-compile (code)
  (let* ((scope (create-scope '() nil))
         (tree (traverse (macroexpand-all code '())
                         scope)))
    (my-compile-recur tree scope '(HALT))))

(defun my-collect-free (vars scope next)
  (if vars
      (my-collect-free (cdr vars) scope
                       (let1 x (car vars)
                         (aif (find-index x (scope-local scope))
                              `(LREF ,it PUSH ,@next)
                           (aif (find-index x (scope-upper-vars scope))
                                `(FREF ,it PUSH ,@next)
                             (compile-error "something wrong in collect-free [%@](%@)" x scope)))))
    next))

(defun my-compile-recur (tree scope next)
  (record-case tree
               (:LREF (v)
                      (list* 'LREF v next))
               (:FREF (v)
                      (let1 i (find-index v (caddr scope))
                        (list* 'FREF i
                               (if (member v (cadddr scope))
                                   (list* 'UNBOX next)
                                 next))))
               (:GREF (v)
                      (list* 'GREF v next))
               (:LSET (i val)
                      (my-compile-recur val scope
                                        (list* 'LSET i next)))
               (:FSET (i val)
                      (my-compile-recur val scope
                                        (list* 'FSET i next)))
               (:GSET (var val)
                      (my-compile-recur val scope
                                        (list* 'GSET var next)))
               (:DEF (var val)
                     (my-compile-recur val scope
                                       (list* 'DEF var next)))
               (:LAMBDA (inner-scope body)
                        (let ((vars (car inner-scope))
                              (free (caddr inner-scope)))
                          (my-collect-free free scope
                                           `(CLOSE ,(len (car inner-scope))  ;; argnum
                                                   ,(len (caddr inner-scope)) ;; freenum
                                                   ,(my-compile-body body inner-scope (list 'RET))
                                                   ,@next))))
               (:IF (test then else)
                    (my-compile-recur test scope
                                      `(TEST
                                        ,(my-compile-recur then scope next)
                                        ,@(my-compile-recur else scope next))))
               (:APPLY (f args)
                       `(FRAME ,(my-compile-args args scope
                                                 (my-compile-recur f scope
                                                                   `(APPLY ,(len args))))
                               ,@next))
               (:CONST (x)
                       (list* 'CONST x next))
               (:VOID ()
                      (list* 'VOID next))
               (t `(UNKNOWN ,tree ,@next))))

(defun my-compile-body (body scope next)
  (my-make-boxes (cadddr scope) (scope-local scope)
              (alet ((body body))
                (if body
                    (my-compile-recur (car body) scope
                                      (loop (cdr body)))
                  next))))

(defun my-make-boxes (sets locals next)
  (alet ((vars sets)
         (n 0))
    (if vars
        (if (member (caar vars) locals)
            (list* 'BOX n
                   (loop (cdr vars) (+ n 1)))
          (loop (cdr vars) (+ n 1)))
      next)))

(defun my-compile-args (args scope next)
  (if args
      (my-compile-args (cdr args) scope
                       (my-compile-recur (car args) scope
                                         `(PUSH
                                           ,@next)))
    next))

;;;;

(defun print/ss (x)
  (write/ss x)
  (display "\n"))

(defun main (args)
  (awhile (read)
    (print/ss (my-compile it))))


;(let1 x '(alet ((i 0))
;           (if (< i 10)
;             (loop (+ i 1))))
;      (print/ss (my-compile x))
;      (print/ss (compile x)))
