;;;; Yalp compiler
;;;; Based on 3imp.

; Stack usage:
;    c   ... closure
;    s   ... stack pointer
;    f   ... frame pointer (stack index)
;    ret ... next code
;
; * Initial
;   f = s = 0
;
; * Function call
;   1. Use FRAME opcode to create new frame on stack:
;     f[c][f][ret]s
;   2. Push function arguments to stack on reverse order:
;     f[c][f][ret][a3][a2][a1]s
;   3. Use APPLY opcode to apply function,
;      then argument number is pushed to stack:
;     [c][f][ret][a3][a2][a1]f[argnum]s
;
; * Return
;   1. Get called argument number from stack:
;     [c][f][ret][a3][a2][a1]f
;   2. Put back previous frame:
;     f = s = 0
; * Shift
;   1. Put next function arguments:
;     [c][f][ret][a3][a2][a1]f[argnum][b1]s
;   2. Use SHIFT opcode to remove previous function arguments:
;     [c][f][ret][b1]s
;   4. Use APPLY opcode to apply function,
;      then argument number is pushed to stack:
;     [c][f][ret][b1]f[argnum]s

;(load "./boot.yl")
;(load "./util.yl")

;; Compiles lisp code into vm code.
;;   x : code to be compiled.
;;   e : current environment, ((local-vars ...) free-vars ...)
;;   s : sets variables, (sym1 sym2 ...)
;;   @result : compiled code (list)
(defun compile-recur (x e s next)
  (cond ((symbol? x)
         (compile-refer x e
                        (if (member x s)
                            (list* 'UNBOX next)
                          next)))
        ((pair? x)
         (compile-list x e s next))
        (t (list* 'CONST x next))))

(defun compile-list (x e s next)
  (record-case x
               ;; Special forms.
               (quote (obj) (list* 'CONST obj next))
               (^ (vars &body body)
                  (compile-lambda vars body e s next))
               (if (test then &rest rest)
                   (compile-if test then rest e s next))
               (set! (var val)
                     (compile-set! var val e s next))
               (def (var val)
                    (compile-def var val e s next))
               (call/cc (func)
                        (compile-call/cc func e s next))
               (defmacro (name vars &body body)
                 (compile-defmacro name vars body e s next))
               (values (&rest args)
                       (compile-values args e s next))
               (receive (vars vals &body body)
                        (compile-receive vars vals body e s next))
               (t
                ;; Normal forms.
                (let ((func (car x))
                      (args (cdr x)))
                  (cond ((direct-invoke? func)
                         (compile-apply-direct (cadr func) (cddr func) args e s next))
                        ((inline-function? func)
                         (compile-inline-apply func args e s next))
                        (t (compile-apply func args e s next)))))))

(defun compile-if (test then rest e s next)
  (when (and rest (cdr rest))
    (compile-error "malformed if"))
  (let ((then-slot (cons nil nil))
        (else-slot (cons nil nil)))
    (let1 c (compile-recur test e s (list* 'TEST then-slot else-slot))
      (copy-pair! then-slot (compile-recur then e s next))
      (copy-pair! else-slot (if rest (compile-recur (car rest) e s next)
                              (compile-void next)))
      c)))

(defun compile-def (var val e s next)
  (unless (symbol? var)
    (compile-error "1st argument for `def` must be symbol, but `%@`" var))
  (when (and (inline-function? var)
             (lambda-expression? val))
    (register-inline-function var val))
  (compile-recur val e s (list* 'DEF var next)))

(defun compile-set! (var val e s next)
  (unless (symbol? var)
    (compile-error "1st argument for `set!` must be symbol, but `%@`" var))
  (compile-lookup var e
                  (^(n) (compile-recur val e s (list* 'LSET n next)))
                  (^(n) (compile-recur val e s (list* 'FSET n next)))
                  (^()  (compile-recur val e s (list* 'GSET var next)))))

(defun compile-call/cc (func e s next)
  (let1 is-tail (tail? next)
    (let1 c (list* 'CONTI is-tail
                   'PUSH
                   (compile-recur func e s
                                  (if is-tail
                                      '(TAPPLY 1)  ;(SHIFT 1 APPLY 1)
                                    '(APPLY 1))))
      (if is-tail
          c
        (list* 'FRAME c next)))))

(defun compile-void (next)
  (list* 'VOID next))

(defun direct-invoke? (func)
  (and (pair? func)
       (eq? '^ (car func))))

(defun compile-apply (func args e s next)
  (let ((is-tail (tail? next))
        (argnum (length args))
        (func-slot (cons nil nil)))
    (let1 code-top (compile-apply-args args e s func-slot)
      (copy-pair! func-slot
                  (compile-recur func e s
                                 (if is-tail
                                     (list 'TAPPLY argnum)  ;(list 'SHIFT argnum 'APPLY argnum)
                                   (list 'APPLY argnum))))
      (if is-tail
          code-top
        (list* 'FRAME code-top next)))))

(defun compile-inline-apply (sym args e s next)
  (let1 lambda (get-inline-function-body sym)
    (compile-recur `(,lambda ,@args)
                   e s next)))

(defun compile-apply-args (args e s next)
  (alet ((args args)
         (c next))
    (if args
        (loop (cdr args)
              (compile-recur (car args) e s
                             (list* 'PUSH c)))
      c)))

;; Compiles ((^(vars) body) args) form
(defun compile-apply-direct (vars body args e s next)
  (let1 proper-vars (check-parameters vars)
    (let ((argnum (length args))
          (varnum (- (length proper-vars)
                     (if (eq? proper-vars vars) 0 1))))
      (if (not (eq? vars proper-vars))  ;; Has rest param.
          ;; Tweak arguments.
          (cond ((< argnum varnum)  ;; Error handled in the below.
                 (compile-apply-direct proper-vars body args e s next))
                ;; ((^(x y &rest z) ...) 1 2 3 4) => ((^(x y z) ...) 1 2 '(3 4))
                ((> argnum varnum)
                 (compile-recur `((^ ,proper-vars ,@body)
                                  ,@(take varnum args)
                                  (list ,@(drop varnum args)))
                                e s next))
                ;; ((^(x y &rest z) ...) 1 2) => ((^(x y z) ...) 1 2 '())
                (t (compile-apply-direct proper-vars body (append args '(()))
                                         e s next)))
        (do
          (unless (eq? argnum varnum)
            (let1 which (if (< argnum varnum) "few" "many")
              (compile-error "Too %@ arguments, %@ for %@" which argnum varnum)))
          (let ((ext-vars (append proper-vars (car e)))
                (body-slot (cons nil nil)))
            (let ((free (cdr e))  ;(intersection (union (car e)
                                  ;                     (cdr e))
                                  ;              (find-frees body '() proper-vars))
                  (sets (union s (find-setses body ext-vars))) ;(find-setses body proper-vars))
                  (code-top (compile-apply-args args e s body-slot)))
              (copy-pair! body-slot
                          (if (eq? argnum 0)
                              (compile-body proper-vars ext-vars body free sets s
                                            next)
                            (list* 'EXPND argnum
                                   (compile-body proper-vars ext-vars body free sets s
                                                 (if (tail? next)
                                                     next
                                                   (list* 'SHRNK argnum next))))))
              code-top)))))))

(defun compile-lambda (vars body e s next)
  (let1 proper-vars (check-parameters vars)
    (let ((free (intersection (union (car e)
                                     (cdr e))
                              (find-frees body '() proper-vars)))
          (sets (find-setses body proper-vars))
          (varnum (if (eq? vars proper-vars)
                      (length vars)
                    (list (- (length proper-vars) 1)
                          -1))))
      (collect-free free e
                    (list* 'CLOSE varnum (length free)
                           (compile-body proper-vars proper-vars body free sets s
                                         (list 'RET))
                           next)))))

(defun collect-free (vars e next)
  (if vars
      (collect-free (cdr vars) e
                    (compile-refer (car vars) e
                                   (list* 'PUSH next)))
    next))

;; Check function parameters are valid and returns proper vars.
(defun check-parameters (vars)
  (unless (list? vars)
    (compile-error "parameters must be list, but %@" vars))
  (let1 proper-vars (aif (position-if [or (eq? _ '&rest) (eq? _ '&body)] vars)
                         (let ((required (take it vars))
                               (rest (drop (+ it 1) vars)))
                           (unless (single? rest)
                             (compile-error "&rest requires only 1 name, but %@" rest))
                           (append! required rest))
                      vars)
    (awhen (any? [not (symbol? _)] vars)
      (compile-error "parameter must be symbol, but `%@`" (car it)))
    (alet ((p proper-vars))
      (when p
        (when (member (car p) (cdr p))
          (compile-error "Duplicated parameter `%@`" (car p)))
        (loop (cdr p))))
    proper-vars))

(defun compile-body (set-vars vars body free sets s next)
  (if body
      (let ((ee (cons vars free))
            (ss (union sets
                       (intersection s free)))
            (top-slot (cons nil nil)))
        (alet ((p body)
               (prev-slot top-slot))
          (let* ((next-slot (if (cdr p) (cons nil nil) next))
                 (cc (compile-recur (car p) ee ss next-slot)))
            (copy-pair! prev-slot cc)
            (when (cdr p)
              (loop (cdr p) next-slot))))
        (make-boxes sets set-vars
                    top-slot))
    (compile-void next)))

(defun make-boxes (sets vars next)
  (alet ((vars vars)
         (n 0))
    (if vars
        (if (member (car vars) sets)
            (list* 'BOX n (loop (cdr vars) (+ n 1)))
          (loop (cdr vars) (+ n 1)))
      next)))

(defun compile-values (args e s next)
  (let1 argnum (length args)
    (if (eq? argnum 0)
        (compile-void next)
      (compile-apply-args args e s (list* 'VALS argnum next)))))

(defun compile-receive (vars vals body e s next)
  (let* ((proper-vars (check-parameters vars))
         (ext-vars (append proper-vars (car e))))
    (let ((free (cdr e))  ;(intersection (union (car e)
                          ;                     (cdr e))
                          ;              (find-frees body '() proper-vars))
          (sets (union s (find-setses body ext-vars))) ;(find-setses body proper-vars))
          (varnum (if (eq? vars proper-vars)
                      (length vars)
                    (list (- (length proper-vars) 1)
                          -1)))
          (body-slot (cons nil nil)))
      (let1 c (compile-recur vals e s
                             (list* 'RECV varnum
                                    body-slot))
        (copy-pair! body-slot (compile-body ext-vars ext-vars body free sets s
                                            (list* 'SHRNK (length proper-vars) next)))
        c))))

(defun find-frees (xs b vars)
  (let1 bb (union (dotted->proper vars) b)
    (alet ((v '())
           (p xs))
      (if p
          (loop (union v (find-free (car p) bb))
                (cdr p))
        v))))

;; Find free variables.
;; This does not consider upper scope, so every symbol except under scope
;; are listed up.
(defun find-free (x b)
  (cond ((symbol? x)
         (if (member x b) '() (list x)))
        ((pair? x)
         (record-case x
                      (^ (vars &body body)
                         (find-frees body b vars))
                      (quote (obj) '())
                      (if (&rest all) (find-frees all b '()))
                      (set! (var exp)
                            (union (if (member var b) '() (list var))
                                   (find-free exp b)))
                      (def (var exp)
                           (union (if (member var b) '() (list var))
                                  (find-free exp b)))
                      (call/cc (&rest all) (find-frees all b '()))
                      (defmacro (name vars &body body) (find-frees body b vars))
                      (values (&rest all) (find-frees all b '()))
                      (receive (vars vals &body body)
                               (union (find-free vals b)
                                      (find-frees body b vars)))
                      (t (find-frees x b '()))))
        (t '())))

(defun find-setses (xs v)
  (alet ((sets '())
         (xs xs))
    (if xs
        (loop (union sets (find-sets (car xs) v))
              (cdr xs))
      sets)))

;; Find assignment expression for local variables to make them boxing.
;; Boxing is needed to keep a value for continuation.
(defun find-sets (x v)
  (if (pair? x)
      (record-case x
                   (set! (var val)
                         (union (if (member var v) (list var) '())
                                (find-sets val v)))
                   (def (var val)
                        (find-sets val v))
                   (^ (vars &body body)
                      (find-setses body (set-minus v (dotted->proper vars))))
                   (quote (&rest all) '())
                   (if (&rest all) (find-setses all v))
                   (call/cc (&rest all) (find-setses all v))
                   (defmacro (name vars &body body)  (find-setses body (set-minus v (dotted->proper vars))))
                   (values (&rest all) (find-setses all v))
                   (receive (vars vals &body body)
                            (union (find-sets vals v)
                                   (find-setses body (set-minus v (dotted->proper vars)))))
                   (t (find-setses x v)))
    '()))

(defun compile-refer (var e next)
  (compile-lookup var e
                  (^(n) (list* 'LREF n next))
                  (^(n) (list* 'FREF n next))
                  (^()  (list* 'GREF var next))))

(defun find-index (x ls)
  (alet ((ls ls)
         (idx 0))
    (if ls
        (if (eq? (car ls) x)
            idx
          (loop (cdr ls) (+ idx 1)))
      nil)))

(defun compile-lookup (var e return-local return-free return-global)
  (let ((locals (car e))
        (free   (cdr e)))
    (acond ((find-index var locals)  (return-local it))
           ((find-index var free)    (return-free it))
           (t                        (return-global)))))

(defun tail? (next)
  (eq? (car next) 'RET))

;;; Macro

(defun compile-defmacro (name vars body e s next)
  (let1 proper-vars (check-parameters vars)
    (let ((free (intersection (union (car e)
                                     (cdr e))
                              (find-frees body '() proper-vars)))
          (sets (find-setses body proper-vars))
          (varnum (if (eq? vars proper-vars)
                      (length vars)
                    (list (- (length proper-vars) 1)
                          -1))))
      ;; Macro registeration will be done in other place.
      (collect-free free e
                    (list* 'MACRO name varnum (length free)
                           (compile-body proper-vars proper-vars body free sets s '(RET))
                           next)))))

(defun macroexpand-all (exp scope-vars)
  (if (pair? exp)
      (if (member (car exp) scope-vars)
          (macroexpand-all-sub exp scope-vars)
        (let1 expanded (macroexpand-1 exp)
          (if (equal? expanded exp)
              (macroexpand-all-sub exp scope-vars)
            (macroexpand-all expanded scope-vars))))
    exp))

(defun map-macroexpand-all (ls svars)
  (map [macroexpand-all _ svars] ls))

(defun macroexpand-all-sub (exp scope-vars)
  (record-case exp
               (quote (obj) `(quote ,obj))
               (^ (vars &body body)
                  (let1 new-scope-vars (append (dotted->proper vars) scope-vars)
                    `(^ ,vars ,@(map-macroexpand-all body new-scope-vars))))
               (if (&rest all)
                   `(if ,@(map-macroexpand-all all scope-vars)))
               (set! (var x)
                     `(set! ,var ,(macroexpand-all x scope-vars)))
               (def (var x)
                    `(def ,var ,(macroexpand-all x scope-vars)))
               (call/cc (x)
                        `(call/cc ,(macroexpand-all x scope-vars)))
               (defmacro (name vars &body body)
                 (let1 new-scope-vars (append (dotted->proper vars) scope-vars)
                   `(defmacro ,name ,vars ,@(map-macroexpand-all body new-scope-vars))))
               (values (&rest all)
                       `(values ,@(map-macroexpand-all all scope-vars)))
               (receive (vars vals &body body)
                        (let1 new-scope-vars (append (dotted->proper vars) scope-vars)
                          `(receive ,vars ,(macroexpand-all vals scope-vars)
                             ,@(map-macroexpand-all body new-scope-vars))))
               (t (map-macroexpand-all exp scope-vars))))

(defun macroexpand (exp)
  (let1 expanded (macroexpand-1 exp)
    (if (equal? expanded exp)
        exp
      (macroexpand expanded))))

;; Declaim

(defmacro declaim (&rest defs)
  `(do
     ,@(map (^(sentence)
              (when (pair? sentence)
                (case (car sentence)
                  (inline (do (dolist (sym (cdr sentence))
                                (declaim-inline sym))
                              '(values)))
                  )))
            defs)))

(let1 *inline-functions* (table)
  (defun declaim-inline (sym)
    (table-put! *inline-functions* sym t))

  (defun inline-function? (sym)
    (and (symbol? sym)
         (table-exists? *inline-functions* sym)))

  (defun register-inline-function (sym func)
    (table-put! *inline-functions* sym func))

  (defun get-inline-function-body (sym)
    (table-get *inline-functions* sym))
  )

(defun lambda-expression? (exp)
  (and (pair? exp)
       (eq? (car exp) '^)))

;;

(let1 *exit-compile* nil
  (defun compile-error (&rest args)
    (apply format *stderr* args)
    (display "\n")
    (*exit-compile* nil))

  (defun compile (x)
    (call/cc
     (^(cc)
       (set! *exit-compile* cc)
       (compile-recur (macroexpand-all x '())
                      '(()) '() '(HALT))))))

(defun eval (x)
  (run-binary (compile x)))
