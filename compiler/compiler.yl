;; Yalp traversal compiler

; Stack usage:
;    c   ... closure
;    s   ... stack pointer
;    f   ... frame pointer (stack index)
;    ret ... next code
;
; * Initial
;   f = s = 0
;
; * Function call
;   1. Use FRAME opcode to create new frame on stack:
;     f[c][f][ret]s
;   2. Push function arguments to stack on reverse order:
;     f[c][f][ret][a3][a2][a1]s
;   3. Use APPLY opcode to apply function,
;      then argument number is pushed to stack:
;     [c][f][ret][a3][a2][a1]f[argnum]s
;
; * Return
;   1. Get called argument number from stack:
;     [c][f][ret][a3][a2][a1]f
;   2. Put back previous frame:
;     f = s = 0
; * Shift
;   1. Put next function arguments:
;     [c][f][ret][a3][a2][a1]f[argnum][b1]s
;   2. Use SHIFT opcode to remove previous function arguments:
;     [c][f][ret][b1]s
;   4. Use APPLY opcode to apply function,
;      then argument number is pushed to stack:
;     [c][f][ret][b1]f[argnum]s

;(load "./boot.yl")
;(load "./util.yl")

;;;;

(def VAR-ARG 1)        ; is used for argument (or return value).
(def VAR-CALL 2)       ; is used for function.
(def VAR-TAIL-CALL 4)  ; is used for function in tail position.
(def VAR-FREE 8)       ; is captured for free variable.
(def VAR-SET 16)       ; is set.

;; Traverses lisp code and generate intermediate AST.
;;   x : code to be compiled.
;;   scope : code scope.
;;   tail : whether this node is at tail position.
;;   @result : AST.
(defun traverse (x scope tail)
  (cond ((symbol? x)
         (traverse-refer x scope))
        ((pair? x)
         (let1 expanded (expand-macro x scope)
           (if (pair? expanded)
               (traverse-list expanded scope tail)
             (traverse expanded scope tail))))
        (t (list ':CONST x))))

(defun traverse-list (x scope tail)
  (record-case x
               ;; Special forms.
               (quote (obj) (list ':CONST obj))
               (^ (vars &body body)
                  (traverse-lambda vars body scope))
               (if (test then &rest rest)
                   (traverse-if test then rest scope tail))
               (set! (var val)
                     (traverse-set! var val scope))
               (def (var val)
                    (traverse-def var val scope))
               (call/cc (func)
                        (traverse-call/cc func scope tail))
               (defmacro (name vars &body body)
                 (traverse-defmacro name vars body scope))
               (values (&rest args)
                       (traverse-values args scope tail))
               (receive (vars vals &body body)
                        (traverse-receive vars vals body scope tail))
               ;; Other: normal forms.
               (t (let ((func (car x))
                        (args (cdr x)))
                    (cond ((direct-invoke? func)
                           (traverse-apply-direct (cadr func) (cddr func) args scope tail))
                          ((inline-function? func)
                           (traverse-inline-apply func args scope))
                          (t (traverse-apply func args scope tail)))))))

(defun traverse-refer (x scope)
  (when (and (not (scope-local-has? scope x))
             (scope-upper-vars-has? scope x))  ; Free variable
    (register-fref scope x))
  (list ':REF x))

(defun traverse-set! (var val scope)
  (unless (symbol? var)
    (compile-error "`set!` requires symbol, but `%@`" var))
  (let ((is-local (scope-local-has? scope var))
        (is-free (scope-upper-vars-has? scope var))
        (val-node (traverse val scope nil)))
    (when (and (not is-local) is-free)
      (register-fref scope var))
    (when (or is-local is-free)
      (register-set! scope var val-node))
    (list ':SET var val-node)))

(defun traverse-def (var val scope)
  (unless (symbol? var)
    (compile-error "`def` requires symbol, but `%@`" var))
  (when (and (inline-function? var)
             (lambda-expression? val))
    (register-inline-function var val))
  (let1 val-node (traverse val scope nil)
    (register-set! scope var val-node)
    (list ':DEF var val-node)))

(defun traverse-if (test then rest scope tail)
  (when (and rest (cdr rest))
    (compile-error "malformed if"))
  (list ':IF (traverse test scope nil)
        (traverse then scope tail)
        (if rest
            (traverse (car rest) scope tail)
          '(:VOID))))

(defun traverse-call/cc (func scope tail)
  (list ':CONTI (traverse func scope nil) tail))

(defun traverse-lambda (vars body scope)
  (let* ((proper-vars (check-parameters vars))
         (inner-scope (create-scope proper-vars scope))
         (body-node (traverse-body body inner-scope t)))
    (let1 varnum (if (eq? vars proper-vars)
                     (length vars)
                   (list (- (length proper-vars) 1)
                         -1))
      ;; Propagate to upper scope
      (propagate-scope-to-upper scope inner-scope (scope-local inner-scope))
      ;; Returns lambda node
      (create-lambda-node inner-scope proper-vars varnum body-node))))

(defun traverse-body (body scope tail)
  (maplist [traverse (car _) scope (and (not (cdr _))
                                        tail)]
           body))

(defun traverse-apply (func args scope tail)
  (add-var-info scope func (if tail VAR-TAIL-CALL VAR-CALL))
  (dolist (arg args)
    (add-var-info scope arg VAR-ARG))
  (list ':APPLY
        (traverse func scope tail)
        (map [traverse _ scope nil] args)
        tail))

(defun traverse-inline-apply (sym args scope tail)
  (let1 lambda (get-inline-function-body sym)
    (traverse `(,lambda ,@args)
              scope tail)))

(defun traverse-apply-direct (vars body args scope tail)
  (dolist (arg args)
    (add-var-info scope arg VAR-ARG))
  (let1 proper-vars (check-parameters vars)
    (let ((argnum (length args))
          (varnum (- (length proper-vars)
                     (if (eq? proper-vars vars) 0 1))))
      (if (not (eq? vars proper-vars))  ;; Has rest param.
          ;; Tweak arguments.
          (cond ((< argnum varnum)  ;; Error handled in the below.
                 (traverse-apply-direct proper-vars body args scope tail))
                ;; ((^(x y &rest z) ...) 1 2 3 4) => ((^(x y z) ...) 1 2 (list 3 4))
                ((> argnum varnum)
                 (traverse `((^ ,proper-vars ,@body)
                             ,@(take varnum args)
                             (list ,@(drop varnum args)))
                           scope tail))
                ;; ((^(x y &rest z) ...) 1 2) => ((^(x y z) ...) 1 2 '())
                (t (traverse-apply-direct proper-vars body (append args '(()))
                                          scope tail)))
        (if (eq? argnum varnum)
            (let1 args-node (map [traverse _ scope nil]
                                 args)
              (let* ((expanded-scope (expand-scope proper-vars scope))
                     (body-node (traverse-body body expanded-scope tail)))
                (propagate-scope-to-upper scope expanded-scope proper-vars)
                ;; Returns lambda node
                (list ':INVOKE
                      expanded-scope
                      proper-vars
                      args-node
                      body-node
                      tail)))
          (let1 which (if (< argnum varnum) "few" "many")
            (compile-error "Too %@ arguments, %@ for %@" which argnum varnum)))))))

(defun traverse-defmacro (name vars body scope)
  (let* ((proper-vars (check-parameters vars))
         (inner-scope (create-scope proper-vars scope))
         (body-node (traverse-body body inner-scope t)))
    (let1 varnum (if (eq? vars proper-vars)
                     (length vars)
                   (list (- (length proper-vars) 1)
                         -1))
      (propagate-scope-to-upper scope inner-scope (scope-local inner-scope))
      ;; Returns macro node
      (list ':MACRO
            inner-scope
            name
            varnum
            body-node))))

(defun traverse-values (args scope tail)
  (list ':VALS (maplist [traverse (car _) scope (and (cdr args)
                                                     tail)]
                        args)))

(defun traverse-receive (vars vals body scope tail)
  (let1 proper-vars (check-parameters vars)
    (let ((varnum (if (eq? vars proper-vars)
                      (length vars)
                    (list (- (length proper-vars) 1)
                          -1)))
          (val-node (traverse vals scope nil)))
      (let* ((expanded-scope (expand-scope proper-vars scope))
             (body-node (traverse-body body expanded-scope tail)))
        (propagate-scope-to-upper scope expanded-scope proper-vars)
        ;; Returns receive node
        (list ':RECV
              expanded-scope
              proper-vars
              varnum
              val-node
              body-node
              tail)))))

;; Check function parameters are valid and returns proper vars.
(defun check-parameters (vars)
  (unless (list? vars)
    (compile-error "parameters must be list, but %@" vars))
  (let1 proper-vars (aif (position-if [or (eq? _ '&rest) (eq? _ '&body)] vars)
                         (let ((required (take it vars))
                               (rest (drop (+ it 1) vars)))
                           (unless (single? rest)
                             (compile-error "&rest requires only 1 name, but %@" rest))
                           (append! required rest))
                      vars)
    (awhen (any? [not (symbol? _)] vars)
      (compile-error "parameter must be symbol, but `%@`" (car it)))
    (alet ((p proper-vars))
      (when p
        (when (member (car p) (cdr p))
          (compile-error "Duplicated parameter `%@`" (car p)))
        (loop (cdr p))))
    proper-vars))

(defun direct-invoke? (func)
  (and (pair? func)
       (eq? '^ (car func))))

(defun expand-macro (x scope)
  (let1 f (car x)
    (if (or (not (symbol? f))
            (scope-local-has? scope f)
            (scope-upper-vars-has? scope f))
        x
      (macroexpand x))))

(defun macroexpand (exp)
  (let1 expanded (macroexpand-1 exp)
    (if (equal? expanded exp)
        exp
      (macroexpand expanded))))

;;;;
;; Scope
;;   var-info: #0=var-info, #1=set-value

(defun create-scope (local-vars outer-scope)
  (let ((scope-id (gensym))
        (infos (map (^(_) (vector 0 nil)) local-vars)))
    (vector local-vars
            infos
            '()
            scope-id
            outer-scope)))

(defun expand-scope (local oscope)
  (let ((expanded-vars (append local (scope-local oscope)))
        (expanded-var-infos (append (map (^(_) (vector 0 nil)) local)
                                    (scope-local-info oscope))))
    (vector expanded-vars
            expanded-var-infos
            (scope-frees oscope)
            (scope-id oscope)
            oscope)))

(defun get-expanded-scope-outer-local-count (scope)
  (let1 outer (scope-outer-scope scope)
    (if (eq? (scope-id outer)
             (scope-id scope))
        (length (scope-local outer))
      0)))

(defun scope-local (scope)        (vector-get scope 0))
(defun scope-local-info (scope)   (vector-get scope 1))
(defun scope-frees (scope)        (vector-get scope 2))
(defun scope-id (scope)           (vector-get scope 3))
(defun scope-outer-scope (scope)  (vector-get scope 4))

(defun scope-frees-set! (scope v) (vector-set! scope 2 v))

;; Returns index if the scope has the symbol.
(defun scope-local-has? (scope sym)  (position sym (scope-local scope)))
(defun scope-upper-vars-has? (scope sym)
  (alet ((pscope (scope-outer-scope scope)))
    (if pscope
        (aif (scope-local-has? pscope sym)
             it
          (loop (scope-outer-scope pscope)))
      nil)))

(defun propagate-scope-to-upper (scope inner-scope vars)
  (when scope
    (scope-frees-set! scope
                      (union (scope-frees scope)
                             (set-minus (scope-frees inner-scope) (scope-local scope))))))

(defun with-var-info (scope var fn)
  (when scope
    (aif (scope-local-has? scope var)
         (fn (elt (scope-local-info scope) it))
      (with-var-info (scope-outer-scope scope) var fn))))

(defun add-var-info (scope var val)
  (when (symbol? var)
    (with-var-info scope var
                   (^(info)
                     (vector-set! info 0 (logior (vector-get info 0)
                                                 val))
                     info))))

(defun var-has-attr? (scope var flag)
  (with-var-info scope var
                 (^(info)
                   (unless (eq? (logand (vector-get info 0) flag)
                                0)
                     info))))

(defun var-is-set? (scope sym)
  (aif (var-has-attr? scope sym VAR-SET)
       (vector-get it 1)
    nil))

;; Registers free variable into scope and returns its index number.
(defun register-fref (scope x)
  (add-var-info scope x VAR-FREE)
  (let1 frees (scope-frees scope)
    (if frees
        (aif (position x frees)
             it
          (let1 index (length frees)
            (set-cdr! (last frees) (cons x nil))
            index))
      (do (scope-frees-set! scope (cons x nil))
          0))))

(defun register-set! (scope x v)
  (let1 info (add-var-info scope x VAR-SET)
    (when info
      (vector-set! info 1 (cons v (vector-get info 1))))))

;;;;
;; Lambda node

(defun create-lambda-node (scope proper-vars varnum body-node)
  (list ':LAMBDA
        scope
        (cons nil nil)  ; body-slot
        proper-vars
        varnum
        body-node))

(defun lambda-node? (node)
  (eq? (car node) ':LAMBDA))

(def lambda-scope-get      cadr)
(def lambda-body-slot-get  caddr)
(def lambda-varnum-get     caddddr)
(defun lambda-body-node-get (node)  (elt node 5))

(defun lambda-scope-set! (node scope)
  (set-car! (cdr node) scope))

;;;;

(defun compile-recur (tree scope next)
  (record-case tree
               (:CONST (x)
                       (list* 'CONST x next))
               (:VOID ()
                      (list* 'VOID next))
               (:REF (sym)
                     (receive (op i)
                              (acond ((scope-local-has? scope sym)
                                      (values 'LREF it))
                                     ((position sym (scope-frees scope))
                                      (values 'FREF it))
                                     (t (values 'GREF sym)))
                       (list* op i
                              (if (and (not (eq? op 'GREF))
                                       (var-is-set? scope sym))
                                  (list* 'UNBOX next)
                                next))))
               (:SET (var val)
                     (compile-set! var val scope next))
               (:DEF (var val)
                     (compile-recur val scope
                                    (list* 'DEF var next)))
               (:IF (test then else)
                    (compile-recur test scope
                                   (list* 'TEST
                                          (compile-recur then scope next)
                                          (compile-recur else scope next))))
               (:LAMBDA (inner-scope body-slot proper-vars varnum body)
                        (let ((frees (scope-frees inner-scope)))
                          ;; Set compiled body code to body-slot.
                          (copy-pair! body-slot
                                      (compile-body (scope-local inner-scope) body inner-scope (list 'RET)))
                          (collect-free frees scope
                                        (list* 'CLOSE varnum (length frees)
                                               body-slot
                                               next))))
               (:INVOKE (expanded-scope proper-vars args-node body tail)
                        (let ((vars (scope-local expanded-scope))
                              (frees (scope-frees expanded-scope)))
                          (compile-args args-node scope
                                        (if proper-vars
                                            (let1 varnum (length proper-vars)
                                              (list* 'EXPND varnum
                                                     (compile-body proper-vars body expanded-scope
                                                                   (if tail
                                                                       next
                                                                     (list* 'SHRNK varnum next)))))
                                          (compile-body '() body expanded-scope next)))))
               (:MACRO (inner-scope name varnum body)
                       (let ((vars (scope-local inner-scope))
                             (frees (scope-frees inner-scope)))
                         (collect-free frees scope
                                       (list* 'MACRO name varnum (length frees)
                                              (compile-body (scope-local inner-scope) body inner-scope (list 'RET))
                                              next))))
               (:APPLY (f args tail)
                       (compile-apply f args tail scope next))
               (:CONTI (func tail)
                       (let* ((c (list* 'CONTI tail
                                        'PUSH
                                        (compile-recur func scope
                                                       (if tail
                                                           '(TAPPLY 1)  ;(SHIFT 1 APPLY 1)
                                                         '(APPLY 1))))))
                         (if tail
                             c
                           (list* 'FRAME c next))))
               (:VALS (args)
                      (let1 argnum (length args)
                        (if (eq? argnum 0)
                            (list* 'VOID next)
                          (compile-args args scope
                                        (list* 'VALS argnum next)))))
               (:RECV (expanded-scope proper-vars varnum vals body tail)
                      (let ((frees (scope-frees expanded-scope)))
                        (compile-recur vals scope
                                       (list* 'RECV varnum
                                              (compile-body (scope-local expanded-scope) body expanded-scope
                                                            (if tail
                                                                next
                                                              (list* 'SHRNK (if (pair? varnum)
                                                                                (+ (car varnum) 1)
                                                                              varnum)
                                                                     next)))))))
               (t (error "Unknown [%@]" tree))))

(defun compile-apply (f args tail scope next)
  (let ((argnum (length args))
        (lambda-node (can-goto? f scope)))
    (cond ((and lambda-node
                (eq? (scope-outer-scope (lambda-scope-get lambda-node))
                     scope))
           ;; Beginning of loop using self-recursion function.
           (let ((lambda-scope (lambda-scope-get lambda-node))
                 (body-slot (lambda-body-slot-get lambda-node)))
             (let ((expanded-scope (expand-scope (scope-local lambda-scope) scope)))
               ;(copy-pair! body-slot
               ;            (compile-body (scope-local lambda-scope) (lambda-body-node-get lambda-node) expanded-scope
               ;                          next))
               (let1 c (compile-args args scope
                                     (compile-recur f scope
                                                    (if tail
                                                        (list* 'SHIFT argnum
                                                               (list* 'DIRECTCALL argnum
                                                                      body-slot))
                                                      (list* 'DIRECTCALL argnum
                                                             body-slot))))
                 (if tail
                     c
                   (list* 'FRAME c next))))))
          ;; Continue loop using self-recursion in tail position.
          ((and lambda-node
                (or (eq? (scope-id (lambda-scope-get lambda-node))
                         (scope-id scope))
                    (eq? (scope-id (scope-outer-scope (lambda-scope-get lambda-node)))
                         (scope-id scope)))
                tail)
           (let ((varnum (lambda-varnum-get lambda-node))
                 (outer-varnum (length (get-expanded-scope-outer-local-count (lambda-scope-get lambda-node)))))
             (when (pair? varnum)
               (error "Not implemented: rest param for loop"))
             (unless (eq? argnum varnum)
               (compile-error "Illegal argnum, `%@` requires %@, but %@" (caddr f) varnum argnum))
             (compile-args args scope
                           (list* 'LOOP argnum outer-varnum
                                  (lambda-body-slot-get lambda-node)))))
          ;; Normal function call.
          (t (let1 code (compile-args args scope
                                      (compile-recur f scope
                                                     (if tail
                                                         (list 'TAPPLY argnum)
                                                       (list 'APPLY argnum))))
               (if tail
                   code
                 (list* 'FRAME code next)))))))

(defun compile-set! (var val scope next)
  ;; Check whether the set! value is lambda and it is used for
  ;; local loop.
  (if (and nil  ; TODO: Enable this.
           (lambda-node? val)
           (let1 ss (var-is-set? scope var)
             (and ss
                  (single? ss)
                  (car ss))))
       ;; This function is used for loop.
       (let* ((lambda-node val)
              (body-slot (lambda-body-slot-get lambda-node))
              (lambda-scope (lambda-scope-get lambda-node))
              (expanded-scope (expand-scope (scope-local lambda-scope) scope)))
         (lambda-scope-set! lambda-node expanded-scope)
         (copy-pair! body-slot
                     (compile-body (scope-local lambda-scope) (lambda-body-node-get lambda-node)
                                   expanded-scope
                                   (list 'RET)))
         (list* 'CONST body-slot
                next))
    ;; Normal set!
    (receive (op i)
             (acond ((scope-local-has? scope var)
                     (values 'LSET it))
                    ((position var (scope-frees scope))
                     (values 'FSET it))
                    (t (values 'GSET var)))
      (compile-recur val scope
                     (list* op i
                            next)))))

(defun compile-body (vars body scope next)
  (if body
      (make-boxes scope vars
                  (alet ((body body))
                    (if body
                        (compile-recur (car body) scope
                                       (loop (cdr body)))
                      next)))
    (list* 'VOID next)))

(defun make-boxes (scope locals next)
  (alet ((vars locals)
         (n 0))
    (if vars
        (if (var-is-set? scope (car vars))
            (list* 'BOX n
                   (loop (cdr vars) (+ n 1)))
          (loop (cdr vars) (+ n 1)))
      next)))

(defun compile-args (args scope next)
  (if args
      (compile-args (cdr args) scope
                    (compile-recur (car args) scope
                                   (list* 'PUSH next)))
    next))

(defun collect-free (vars scope next)
  (if vars
      (collect-free (cdr vars) scope
                    (let1 x (car vars)
                      (aif (scope-local-has? scope x)
                           (list* 'LREF it 'PUSH next)
                        (aif (position x (scope-frees scope))
                             (list* 'FREF it 'PUSH next)
                          (error "something wrong in collect-free [%@](%@)" x scope)))))
    next))

(defun can-goto? (f scope)
  (and (eq? (car f) ':REF)                      ; Function is simple reference.
       (let ((sym (cadr f)))                    ; Symbol for the reference.
         (aif (var-is-set? scope sym)
              (and (single? it)                 ; Just 1 time assignment.
                   (let1 node (car it)
                     (and (lambda-node? node)   ; Lambda node.
                          node)))))))

;;;;
;; Declaim

(defmacro declaim (&rest defs)
  `(do ,@(map (^(sentence)
                (when (pair? sentence)
                  (case (car sentence)
                    (inline (do (dolist (sym (cdr sentence))
                                  (declaim-inline sym))
                                '(values)))
                    )))
              defs)))

(let1 *inline-functions* (table)
  (defun declaim-inline (sym)
    (table-put! *inline-functions* sym t))

  (defun inline-function? (sym)
    (and (symbol? sym)
         (table-exists? *inline-functions* sym)))

  (defun register-inline-function (sym func)
    (table-put! *inline-functions* sym func))

  (defun get-inline-function-body (sym)
    (table-get *inline-functions* sym))
  )

(defun lambda-expression? (exp)
  (and (pair? exp)
       (eq? (car exp) '^)))

;;;;

(let1 exit-compile nil
  (defun compile-error (&rest args)
    (apply format *stderr* args)
    (display "\n" *stderr*)
    (exit-compile nil))

  (defun compile (x)
    (call/cc
     (^(cc)
       (set! exit-compile cc)
       (let* ((scope (create-scope '() nil))
              (tree (traverse x scope nil)))
         (compile-recur tree scope (list 'HALT)))))))

(defun eval (x)
  (run-binary (compile x)))

(defun debug/ss (&rest all)
  (write/ss all *stderr*)
  (display "\n" *stderr*)
  all)
