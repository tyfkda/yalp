;(load-binary "../../boot.bin")
(load "./test.yl")

(defun alist->table (alist)
  (let1 ht (table)
    (dolist (kv alist)
      (table-put! ht (car kv) (cdr kv)))
    ht))

(defun table->alist (ht)
  (map (^(key) (cons key (table-get ht key)))
       (table-keys ht)))

(test-section "find-free")
(test "check-parameters" '(x y z) (check-parameters '(x y z)))
(test "check-parameters-rest" '(x y z) (check-parameters '(x y &rest z)))
(test "check-parameters-body" '(x y z) (check-parameters '(x y &body z)))

(test-section "macroexpand")
(test "macroexpand-1" '(x y . z) (macroexpand-1 '(x y . z)))

(test-section "direct-invoke?")
(test "direct-invoke?" t (direct-invoke? '(^(x y))))
(test "direct-invoke?-false" nil (direct-invoke? 'func))

(test-section "get-var-info")
(let* ((scope1 (create-scope '(a) nil))
       (scope2 (expand-scope '(b) scope1))
       (scope3 (create-scope '(c) scope2)))
  (receive (info found-scope)
           (get-var-info scope3 'a)
    (test-eq "expanded scope" scope1 found-scope)))

(test-section "loop")
(test "tail recursion is loop" 55
      (let1 n 10
        (alet ((i 0)
               (acc 0))
          (if (<= i n)
              (loop (+ i 1) (+ acc i))
            acc))))
(test "non tail recursion is not loop" 55
      (let1 n 10
        (alet ((i 0))
          (if (<= i n)
              (+ i (loop (+ i 1)))
            0))))
(test "non tail loop start is loop" 55
      (let1 n 10
        (+ 0 (alet ((i 0)
                    (acc 0))
               (if (<= i n)
                   (loop (+ i 1) (+ acc i))
                 acc)))))
(test "call from outside of self scope is not loop" 55
      (let1 n 10
        (alet ((i 0)
               (acc 0))
          (let1 f (^(i acc) (loop i acc))
            (if (<= i n)
                (f (+ i 1) (+ acc i))
              acc)))))
(test "set after call" 2
      ((^(f)
         (let1 x (f)
           (set! f (^() 1))
           x))
       (^() 2)))
(test "set in lambda but not called" -1
      (let1 n 10
        ((^(loop)
           (let1 f (^() (set! loop (^(i acc)
                                     (if (<= i n)
                                         (loop (+ i 1) (+ acc i))
                                       acc))))
             (loop 0 0)))
         (^(i acc) -1))))
(test "nested loop with free variable" 456
      (let1 h 123
        (let recur ((code '(FRAME (HALT) HALT)))
             h  ; <- needed for make h free variable.
             (alet ((c code))
               (if c
                   (do (when (pair? (car c))
                         (recur (car c)))
                       (loop (cdr c)))
                 456)))))
(test "use set result" 55
      (let1 n 10
        ((^(loop)
           ((set! loop (^(i acc)
                         (if (<= i n)
                             (loop (+ i 1) (+ acc i))
                           acc)))
            0 0))
         nil)))

(test-section "call/cc")
(test "free variable" 123
      (let1 x 123
        (call/cc
         (^(cc)
           (cc x)))))
(test "set! call/cc var" 12321
      (call/cc
       (^(cc)
         (set! cc (^(x) (* x x)))
         (cc 111))))
(test "direct jump" '(nil 4 5)
      (call/cc
       (^(break)
         (alet ((ls '(1 2 nil 4 5))
                (acc 0))
           (if ls
               (do (unless (int? (car ls))
                     (break ls))
                   (loop (cdr ls)
                         (+ acc (car ls))))
             acc)))))
(test "frame, conti and loop" (+ 123 15)
      (let1 x 123  ;; For expand frame.
        (+ (call/cc
            (^(break)
              (alet ((ls '(1 2 3 4 5))
                     (acc 0))
                (if ls
                    (do (unless (int? (car ls))
                          (break ls))
                        (loop (cdr ls) (+ (car ls) acc)))
                  acc))))
           x)))
(test "longjmp from closure" 123
      (call/cc
       (^(break)
         (let1 f (^() (break 123))
           (f)))))

(test-complete)
