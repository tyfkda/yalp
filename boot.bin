(FRAME (CLOSE 2 0 (FRAME (LREF 0 PUSH GREF read APPLY 1) PUSH CONST quote PUSH GREF list TAPPLY 2) PUSH CONST 39 PUSH GREF set-macro-character APPLY 2) HALT)
(FRAME (CLOSE 2 0 (FRAME (LREF 0 PUSH GREF read APPLY 1) PUSH CONST quasiquote PUSH GREF list TAPPLY 2) PUSH CONST 96 PUSH GREF set-macro-character APPLY 2) HALT)
(FRAME (CLOSE 2 0 (FRAME (LREF 0 PUSH GREF read-char APPLY 1) PUSH EXPND 1 FRAME (CONST 64 PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 1 PUSH GREF read APPLY 1) PUSH CONST unquote-splicing PUSH GREF list TAPPLY 2) FRAME (FRAME (LREF 1 PUSH LREF 0 PUSH GREF unread-char APPLY 2) PUSH GREF read APPLY 1) PUSH CONST unquote PUSH GREF list TAPPLY 2) PUSH CONST 44 PUSH GREF set-macro-character APPLY 2) HALT)
(FRAME (CLOSE 2 0 (FRAME (LREF 0 PUSH CONST 93 PUSH GREF read-delimited-list APPLY 2) PUSH CONST (_) PUSH CONST ^ PUSH GREF list TAPPLY 3) PUSH CONST 91 PUSH GREF set-macro-character APPLY 2) HALT)
(MACRO defun (2 -1) 0 (FRAME (LREF 2 PUSH LREF 1 PUSH CONST ^ PUSH GREF list* APPLY 3) PUSH LREF 0 PUSH CONST def PUSH GREF list TAPPLY 3) HALT)
(CLOSE 1 0 (LREF 0 TEST (GREF nil . #0=(RET)) GREF t . #0#) DEF not HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF car TAPPLY 1) DEF caar HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF cdr TAPPLY 1) DEF cdar HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF car TAPPLY 1) DEF cadr HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF cdr TAPPLY 1) DEF cddr HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF cddr APPLY 1) PUSH GREF car TAPPLY 1) DEF caddr HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF cddr APPLY 1) PUSH GREF cdr TAPPLY 1) DEF cdddr HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF cdddr APPLY 1) PUSH GREF car TAPPLY 1) DEF cadddr HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF cdddr APPLY 1) PUSH GREF cdr TAPPLY 1) DEF cddddr HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF cddddr APPLY 1) PUSH GREF car TAPPLY 1) DEF caddddr HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF cddddr APPLY 1) PUSH GREF cdr TAPPLY 1) DEF cdddddr HALT)
(CLOSE 1 0 (CONST fixnum PUSH FRAME (LREF 0 PUSH GREF type APPLY 1) PUSH GREF eq? TAPPLY 2) DEF fixnum? HALT)
(CLOSE 1 0 (CONST pair PUSH FRAME (LREF 0 PUSH GREF type APPLY 1) PUSH GREF eq? TAPPLY 2) DEF pair? HALT)
(CLOSE 1 0 (CONST symbol PUSH FRAME (LREF 0 PUSH GREF type APPLY 1) PUSH GREF eq? TAPPLY 2) DEF symbol? HALT)
(CLOSE 1 0 (CONST string PUSH FRAME (LREF 0 PUSH GREF type APPLY 1) PUSH GREF eq? TAPPLY 2) DEF string? HALT)
(CLOSE 1 0 (CONST flonum PUSH FRAME (LREF 0 PUSH GREF type APPLY 1) PUSH GREF eq? TAPPLY 2) DEF flonum? HALT)
(CLOSE 2 0 (FRAME (LREF 1 PUSH GREF pair? APPLY 1) TEST (FRAME (FRAME (LREF 1 PUSH GREF car APPLY 1) PUSH LREF 0 APPLY 1) TEST (LREF 1 . #0=(RET)) FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 0 PUSH GREF any? TAPPLY 2) GREF nil . #0#) DEF any? HALT)
(CLOSE 3 0 (FRAME (LREF 1 PUSH GREF pair? APPLY 1) TEST (FRAME (LREF 2 PUSH FRAME (FRAME (LREF 1 PUSH GREF car APPLY 1) PUSH LREF 0 APPLY 1) PUSH GREF cons APPLY 2) PUSH FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 0 PUSH GREF map1-loop TAPPLY 3) FRAME (LREF 2 PUSH GREF reverse! APPLY 1) PUSH EXPND 1 LREF 2 TEST (LREF 3 TEST (FRAME (FRAME (LREF 2 PUSH LREF 1 APPLY 1) PUSH LREF 3 PUSH GREF set-cdr! APPLY 2) LREF 0 . #0=(RET)) LREF 2 PUSH LREF 1 TAPPLY 1) LREF 0 . #0#) DEF map1-loop HALT)
(CLOSE 3 0 (FRAME (LREF 1 PUSH GREF not PUSH GREF any? APPLY 2) TEST (LREF 2 PUSH GREF reverse! TAPPLY 1) FRAME (LREF 2 PUSH FRAME (FRAME (CONST nil PUSH LREF 1 PUSH GREF car PUSH GREF map1-loop APPLY 3) PUSH LREF 0 PUSH GREF apply APPLY 2) PUSH GREF cons APPLY 2) PUSH FRAME (CONST nil PUSH LREF 1 PUSH GREF cdr PUSH GREF map1-loop APPLY 3) PUSH LREF 0 PUSH GREF mapn-loop TAPPLY 3) DEF mapn-loop HALT)
(CLOSE (2 -1) 0 (LREF 2 TEST (CONST nil PUSH FRAME (LREF 2 PUSH LREF 1 PUSH GREF cons APPLY 2) PUSH LREF 0 PUSH GREF mapn-loop TAPPLY 3) CONST nil PUSH LREF 1 PUSH LREF 0 PUSH GREF map1-loop TAPPLY 3) DEF map HALT)
(CLOSE 2 0 (GREF nil PUSH EXPND 1 BOX 0 LREF 0 PUSH LREF 1 PUSH CLOSE 2 2 #0=(FRAME (LREF 0 PUSH GREF pair? APPLY 1) TEST (FRAME (LREF 1 PUSH FRAME (LREF 0 PUSH FREF 0 APPLY 1) PUSH GREF cons APPLY 2) PUSH FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH LOOP 2 0 . #0#) FRAME (LREF 1 PUSH GREF reverse! APPLY 1) PUSH EXPND 1 LREF 1 TEST (LREF 2 TEST (FRAME (FRAME (LREF 1 PUSH FREF 0 APPLY 1) PUSH LREF 2 PUSH GREF set-cdr! APPLY 2) LREF 0 . #1=(RET)) LREF 1 PUSH FREF 0 TAPPLY 1) LREF 0 . #1#) LSET 0 CONST nil PUSH LREF 2 PUSH LREF 0 UNBOX SHIFT 2 DIRECTCALL 2 . #0#) DEF maplist HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF pair? APPLY 1) TEST (FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH EXPND 1 FRAME (CONST unquote PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (LREF 1 PUSH GREF cadr TAPPLY 1) FRAME (CONST unquote-splicing PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (CONST "Illegal ,@" PUSH GREF error TAPPLY 1) FRAME (CONST quasiquote PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (FRAME (LREF 1 PUSH GREF cadr APPLY 1) PUSH GREF qq-expand APPLY 1) PUSH GREF qq-expand TAPPLY 1) FRAME (FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH GREF qq-expand APPLY 1) PUSH FRAME (FRAME (LREF 1 PUSH GREF car APPLY 1) PUSH GREF qq-expand-list APPLY 1) PUSH CONST append PUSH GREF list TAPPLY 3) LREF 0 PUSH CONST quote PUSH GREF list TAPPLY 2) DEF qq-expand HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF pair? APPLY 1) TEST (FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH EXPND 1 FRAME (CONST unquote PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 1 PUSH GREF cadr APPLY 1) PUSH CONST list PUSH GREF list TAPPLY 2) FRAME (CONST unquote-splicing PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (LREF 1 PUSH GREF cadr TAPPLY 1) FRAME (CONST quasiquote PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (FRAME (LREF 1 PUSH GREF cadr APPLY 1) PUSH GREF qq-expand APPLY 1) PUSH GREF qq-expand-list TAPPLY 1) FRAME (FRAME (FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH GREF qq-expand APPLY 1) PUSH FRAME (FRAME (LREF 1 PUSH GREF car APPLY 1) PUSH GREF qq-expand-list APPLY 1) PUSH CONST append PUSH GREF list APPLY 3) PUSH CONST list PUSH GREF list TAPPLY 2) FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH CONST quote PUSH GREF list TAPPLY 2) DEF qq-expand-list HALT)
(MACRO quasiquote 1 0 (LREF 0 PUSH GREF qq-expand TAPPLY 1) HALT)
(MACRO do (0 -1) 0 (CONST nil PUSH FRAME (FRAME (FRAME (FRAME (CONST nil PUSH LREF 0 PUSH GREF append APPLY 2) PUSH CONST (nil) PUSH GREF append APPLY 2) PUSH CONST (^) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append TAPPLY 2) HALT)
(MACRO when (1 -1) 0 (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (CONST nil PUSH LREF 1 PUSH GREF append APPLY 2) PUSH CONST (do) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (if) PUSH GREF append TAPPLY 2) HALT)
(MACRO unless (1 -1) 0 (FRAME (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (CONST nil PUSH LREF 1 PUSH GREF append APPLY 2) PUSH CONST (do) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (FRAME (CONST nil PUSH CONST (do) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (if) PUSH GREF append TAPPLY 2) HALT)
(MACRO set! (2 -1) 0 (LREF 2 TEST (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (CONST nil PUSH LREF 2 PUSH GREF append APPLY 2) PUSH CONST (set!) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (FRAME (FRAME (FRAME (CONST nil PUSH FRAME (LREF 1 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (set!) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (do) PUSH GREF append TAPPLY 2) FRAME (FRAME (CONST nil PUSH FRAME (LREF 1 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (set!) PUSH GREF append TAPPLY 2) HALT)
(MACRO and (0 -1) 0 (LREF 0 TEST (FRAME (LREF 0 PUSH GREF cdr APPLY 1) TEST (FRAME (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (CONST nil PUSH CONST (nil) PUSH GREF append APPLY 2) PUSH CONST (quote) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (FRAME (FRAME (CONST nil PUSH FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (and) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (if) PUSH GREF append TAPPLY 2) LREF 0 PUSH GREF car TAPPLY 1) CONST t RET) HALT)
(MACRO let1 (2 -1) 0 (FRAME (CONST nil PUSH FRAME (LREF 1 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (FRAME (FRAME (FRAME (CONST nil PUSH LREF 2 PUSH GREF append APPLY 2) PUSH FRAME (FRAME (CONST nil PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (^) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append TAPPLY 2) HALT)
(MACRO let (1 -1) 0 (FRAME (LREF 0 PUSH GREF symbol? APPLY 1) TEST (LREF 0 . #0=(TEST (FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH FRAME (LREF 1 PUSH GREF car APPLY 1) PUSH LREF 0 PUSH EXPND 3 FRAME (FRAME (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (CONST nil PUSH FRAME (LREF 1 PUSH GREF cadr PUSH GREF map APPLY 2) PUSH GREF append APPLY 2) PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (FRAME (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (FRAME (CONST nil PUSH LREF 2 PUSH GREF append APPLY 2) PUSH FRAME (FRAME (LREF 1 PUSH GREF car PUSH GREF map APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (^) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (set!) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (nil) PUSH GREF append APPLY 2) PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (let1) PUSH GREF append TAPPLY 2) FRAME (CONST nil PUSH FRAME (LREF 0 PUSH GREF cadr PUSH GREF map APPLY 2) PUSH GREF append APPLY 2) PUSH FRAME (FRAME (FRAME (FRAME (CONST nil PUSH LREF 1 PUSH GREF append APPLY 2) PUSH FRAME (FRAME (LREF 0 PUSH GREF car PUSH GREF map APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (^) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append TAPPLY 2)) CONST nil . #0#) HALT)
(MACRO let* (1 -1) 0 (LREF 0 TEST (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (FRAME (CONST nil PUSH LREF 1 PUSH GREF append APPLY 2) PUSH FRAME (FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (let*) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (let1) PUSH GREF append TAPPLY 2) FRAME (CONST nil PUSH LREF 1 PUSH GREF append APPLY 2) PUSH CONST (do) PUSH GREF append TAPPLY 2) HALT)
(MACRO alet (1 -1) 0 (FRAME (FRAME (FRAME (CONST nil PUSH LREF 1 PUSH GREF append APPLY 2) PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (loop) PUSH GREF append APPLY 2) PUSH CONST (let) PUSH GREF append TAPPLY 2) HALT)
(CLOSE 2 0 (LREF 0 TEST (FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH EXPND 2 FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH EXPND 2 FRAME (CONST t PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (LREF 3 TEST (CONST "else clause must comes at last in cond" PUSH GREF compile-error TAPPLY 1) FRAME (CONST nil PUSH LREF 1 PUSH GREF append APPLY 2) PUSH CONST (do) PUSH GREF append TAPPLY 2) LREF 3 PUSH LREF 1 PUSH LREF 0 PUSH LREF 5 TAPPLY 3) GREF nil RET) DEF cond-template HALT)
(MACRO cond (0 -1) 0 (CLOSE 3 0 (FRAME (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (CONST nil PUSH LREF 2 PUSH GREF append APPLY 2) PUSH CONST (cond) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (FRAME (FRAME (CONST nil PUSH LREF 1 PUSH GREF append APPLY 2) PUSH CONST (do) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (if) PUSH GREF append TAPPLY 2) PUSH LREF 0 PUSH GREF cond-template TAPPLY 2) HALT)
(MACRO acond (0 -1) 0 (CLOSE 3 0 (FRAME (GREF gensym APPLY 0) PUSH EXPND 1 FRAME (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (CONST nil PUSH LREF 3 PUSH GREF append APPLY 2) PUSH CONST (acond) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (FRAME (FRAME (FRAME (FRAME (CONST nil PUSH LREF 2 PUSH GREF append APPLY 2) PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (it) PUSH GREF append APPLY 2) PUSH CONST (let1) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (if) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 1 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (let1) PUSH GREF append TAPPLY 2) PUSH LREF 0 PUSH GREF cond-template TAPPLY 2) HALT)
(MACRO aif (1 -1) 0 (FRAME (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (FRAME (CONST nil PUSH LREF 1 PUSH GREF append APPLY 2) PUSH CONST (it) PUSH GREF append APPLY 2) PUSH CONST (if) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (it) PUSH GREF append APPLY 2) PUSH CONST (let1) PUSH GREF append TAPPLY 2) HALT)
(MACRO awhen (1 -1) 0 (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (CONST nil PUSH LREF 1 PUSH GREF append APPLY 2) PUSH CONST (do) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (aif) PUSH GREF append TAPPLY 2) HALT)
(MACRO let-gensym (1 -1) 0 (FRAME (LREF 0 PUSH GREF pair? APPLY 1) TEST (FRAME (FRAME (CONST nil PUSH LREF 1 PUSH GREF append APPLY 2) PUSH FRAME (FRAME (LREF 0 PUSH CLOSE 1 0 (CONST (gensym) PUSH LREF 0 PUSH GREF list TAPPLY 2) PUSH GREF map APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (let) PUSH GREF append TAPPLY 2) FRAME (FRAME (FRAME (CONST nil PUSH LREF 1 PUSH GREF append APPLY 2) PUSH FRAME (FRAME (CONST nil PUSH CONST (gensym) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (let1) PUSH GREF append TAPPLY 2) HALT)
(MACRO while (1 -1) 0 (FRAME (GREF gensym APPLY 0) PUSH EXPND 1 FRAME (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (CONST nil PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH LREF 2 PUSH GREF append APPLY 2) PUSH FRAME (LREF 1 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (when) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (nil) PUSH GREF append APPLY 2) PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (let) PUSH GREF append TAPPLY 2) HALT)
(MACRO awhile (1 -1) 0 (FRAME (GREF gensym APPLY 0) PUSH EXPND 1 FRAME (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (CONST nil PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH LREF 2 PUSH GREF append APPLY 2) PUSH FRAME (LREF 1 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (awhen) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (nil) PUSH GREF append APPLY 2) PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (let) PUSH GREF append TAPPLY 2) HALT)
(MACRO until (1 -1) 0 (FRAME (GREF gensym APPLY 0) PUSH EXPND 1 FRAME (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (CONST nil PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH LREF 2 PUSH GREF append APPLY 2) PUSH FRAME (LREF 1 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (unless) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (nil) PUSH GREF append APPLY 2) PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (let) PUSH GREF append TAPPLY 2) HALT)
(MACRO or (0 -1) 0 (LREF 0 TEST (FRAME (GREF gensym APPLY 0) PUSH EXPND 1 FRAME (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (CONST nil PUSH FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (or) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (if) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (FRAME (LREF 1 PUSH GREF car APPLY 1) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (let1) PUSH GREF append TAPPLY 2) CONST nil RET) HALT)
(MACRO case (1 -1) 0 (FRAME (GREF gensym APPLY 0) PUSH EXPND 1 FRAME (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (CONST nil PUSH FRAME (LREF 2 PUSH LREF 0 PUSH CLOSE 1 1 (FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH EXPND 2 FRAME (CONST t PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (LREF 2 RET) FRAME (LREF 0 PUSH GREF pair? APPLY 1) TEST (FRAME (CONST nil PUSH LREF 1 PUSH GREF append APPLY 2) PUSH FRAME (FRAME (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (CONST nil PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (quote) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (FREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (member) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append TAPPLY 2) FRAME (CONST nil PUSH LREF 1 PUSH GREF append APPLY 2) PUSH FRAME (FRAME (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (CONST nil PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (quote) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (FREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (eq?) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append TAPPLY 2) PUSH GREF map APPLY 2) PUSH GREF append APPLY 2) PUSH CONST (cond) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 1 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (let1) PUSH GREF append TAPPLY 2) HALT)
(MACRO dolist (1 -1) 0 (FRAME (LREF 0 PUSH GREF cadr APPLY 1) PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH EXPND 2 FRAME (GREF gensym APPLY 0) PUSH FRAME (GREF gensym APPLY 0) PUSH EXPND 2 FRAME (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (FRAME (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (CONST nil PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (cdr) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 1 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH LREF 5 PUSH GREF append APPLY 2) PUSH FRAME (FRAME (FRAME (CONST nil PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (car) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 2 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (let1) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (FRAME (FRAME (CONST nil PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (pair?) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (when) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (CONST nil PUSH FRAME (LREF 3 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 1 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (let) PUSH GREF append TAPPLY 2) HALT)
(MACRO for0-n (2 -1) 0 (FRAME (GREF gensym APPLY 0) PUSH FRAME (GREF gensym APPLY 0) PUSH EXPND 2 FRAME (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (FRAME (CONST nil PUSH CONST (1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 2 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (+) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 1 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH LREF 4 PUSH GREF append APPLY 2) PUSH FRAME (FRAME (FRAME (FRAME (CONST nil PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 2 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (<) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (when) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (CONST nil PUSH CONST (0) PUSH GREF append APPLY 2) PUSH FRAME (LREF 2 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 1 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (let) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 3 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (let1) PUSH GREF append TAPPLY 2) HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF type APPLY 1) PUSH EXPND 1 FRAME (CONST pair PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (GREF nil PUSH EXPND 1 BOX 0 LREF 0 PUSH CLOSE 2 1 #0=(FRAME (LREF 0 PUSH GREF pair? APPLY 1) TEST (FRAME (CONST 1 PUSH LREF 1 PUSH GREF + APPLY 2) PUSH FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH LOOP 2 0 . #0#) LREF 1 RET) LSET 0 CONST 0 PUSH LREF 2 PUSH LREF 0 UNBOX SHIFT 2 DIRECTCALL 2 . #0#) FRAME (CONST string PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (LREF 1 PUSH GREF string-length TAPPLY 1) FRAME (CONST vector PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (LREF 1 PUSH GREF vector-length TAPPLY 1) CONST 0 RET) DEF length HALT)
(CLOSE 1 0 (FRAME (FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF pair? APPLY 1) TEST (FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF last TAPPLY 1) LREF 0 RET) DEF last HALT)
(CLOSE 1 0 (GREF nil PUSH EXPND 1 BOX 0 LREF 0 PUSH CLOSE 2 1 #0=(FRAME (LREF 0 PUSH GREF pair? APPLY 1) TEST (FRAME (LREF 1 PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF cons APPLY 2) PUSH FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH LOOP 2 0 . #0#) LREF 1 RET) LSET 0 CONST nil PUSH LREF 1 PUSH LREF 0 UNBOX SHIFT 2 DIRECTCALL 2 . #0#) DEF reverse HALT)
(CLOSE 2 0 (LREF 1 PUSH LREF 0 PUSH CLOSE 1 1 (LREF 0 PUSH FREF 0 PUSH GREF eq? TAPPLY 2) PUSH GREF any? TAPPLY 2) DEF member HALT)
(CLOSE 2 0 (LREF 1 TEST (FRAME (LREF 0 PUSH FRAME (LREF 1 PUSH GREF caar APPLY 1) PUSH GREF eq? APPLY 2) TEST (LREF 1 PUSH GREF car TAPPLY 1) FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 0 PUSH GREF assoc TAPPLY 2) GREF nil RET) DEF assoc HALT)
(CLOSE 3 0 (LREF 2 PUSH FRAME (LREF 1 PUSH LREF 0 PUSH GREF cons APPLY 2) PUSH GREF cons TAPPLY 2) DEF acons HALT)
(CLOSE 2 0 (LREF 0 TEST (FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH EXPND 1 FRAME (LREF 2 PUSH LREF 0 PUSH GREF member APPLY 2) TEST (LREF 2 . #0=(SHRNK 1 PUSH FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF union TAPPLY 2)) FRAME (LREF 2 PUSH LREF 0 PUSH GREF cons APPLY 2) . #0#) LREF 1 RET) DEF union HALT)
(CLOSE 2 0 (LREF 0 TEST (FRAME (LREF 1 PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF member APPLY 2) TEST (FRAME (LREF 1 PUSH FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF intersection APPLY 2) PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF cons TAPPLY 2) LREF 1 PUSH FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF intersection TAPPLY 2) CONST nil RET) DEF intersection HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF pair? APPLY 1) TEST (FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF not TAPPLY 1) CONST nil RET) DEF single? HALT)
(CLOSE (1 -1) 0 (LREF 1 TEST (FRAME (LREF 1 PUSH GREF car APPLY 1) . #0=(PUSH EXPND 1 FRAME (LREF 0 PUSH FRAME (LREF 1 PUSH GREF write/ss-construct APPLY 1) PUSH LREF 1 PUSH GREF write/ss-print APPLY 3) LREF 1 RET)) GREF *stdout* . #0#) DEF write/ss HALT)
(CLOSE 1 0 (CLOSE 3 0 (FRAME (LREF 1 PUSH LREF 0 PUSH GREF table-get APPLY 2) TEST (VOID RET) FRAME (LREF 2 PUSH LREF 0 PUSH GREF table-get APPLY 2) PUSH EXPND 1 FRAME (LREF 0 PUSH LREF 2 PUSH LREF 1 PUSH GREF table-put! APPLY 3) FRAME (LREF 0 PUSH CONST 1 PUSH GREF + APPLY 2) PUSH LREF 3 PUSH LREF 1 PUSH GREF table-put! TAPPLY 3) PUSH FRAME (GREF gensym APPLY 0) PUSH FRAME (CONST eq PUSH GREF table APPLY 1) PUSH EXPND 3 FRAME (CONST 0 PUSH LREF 1 PUSH LREF 0 PUSH GREF table-put! APPLY 3) GREF nil PUSH EXPND 1 BOX 0 LREF 2 PUSH LREF 3 PUSH LREF 0 PUSH LREF 1 PUSH CLOSE 1 4 #0=(FRAME (LREF 0 PUSH GREF type APPLY 1) PUSH EXPND 1 FRAME (CONST pair PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 1 PUSH FREF 0 PUSH GREF table-exists? APPLY 2) TEST (FREF 3 PUSH LREF 1 PUSH FREF 0 PUSH FREF 2 TAPPLY 3) FRAME (GREF nil PUSH LREF 1 PUSH FREF 0 PUSH GREF table-put! APPLY 3) FRAME (FRAME (LREF 1 PUSH GREF car APPLY 1) PUSH FREF 1 UNBOX APPLY 1) FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LOOP 1 0 . #0#) FRAME (CONST vector PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 1 PUSH FREF 0 PUSH GREF table-exists? APPLY 2) TEST (FREF 3 PUSH LREF 1 PUSH FREF 0 PUSH FREF 2 TAPPLY 3) FRAME (GREF nil PUSH LREF 1 PUSH FREF 0 PUSH GREF table-put! APPLY 3) FRAME (LREF 1 PUSH GREF length APPLY 1) PUSH EXPND 1 GREF nil PUSH EXPND 1 BOX 0 LREF 1 PUSH LREF 0 PUSH LREF 3 PUSH FREF 1 PUSH CLOSE 1 4 #1=(FRAME (FREF 3 PUSH LREF 0 PUSH GREF < APPLY 2) TEST (FRAME (FRAME (LREF 0 PUSH FREF 1 PUSH GREF vector-get APPLY 2) PUSH FREF 0 UNBOX APPLY 1) FRAME (CONST 1 PUSH LREF 0 PUSH GREF + APPLY 2) PUSH LOOP 1 0 . #1#) VOID RET) LSET 0 CONST 0 PUSH LREF 0 UNBOX SHIFT 1 DIRECTCALL 1 . #1#) GREF nil RET) LSET 0 FRAME (LREF 4 PUSH LREF 0 UNBOX DIRECTCALL 1 . #0#) SHRNK 1 LREF 0 RET) DEF write/ss-construct HALT)
(CLOSE 3 0 (FRAME (LREF 0 PUSH LREF 1 PUSH GREF table-get APPLY 2) PUSH EXPND 1 LREF 0 TEST (FRAME (CONST 0 PUSH LREF 0 PUSH GREF < APPLY 2) . #7=(TEST (FRAME (LREF 0 PUSH CONST -1 PUSH GREF - APPLY 2) PUSH CONST "#%@#" PUSH LREF 3 PUSH GREF format TAPPLY 3) LREF 0 TEST (FRAME (LREF 0 PUSH CONST "#%@=" PUSH LREF 3 PUSH GREF format APPLY 3) FRAME (FRAME (LREF 0 PUSH CONST -1 PUSH GREF - APPLY 2) PUSH LREF 1 PUSH LREF 2 PUSH GREF table-put! APPLY 3) . #6=(FRAME (LREF 1 PUSH GREF type APPLY 1) PUSH EXPND 1 FRAME (CONST pair PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (FRAME (LREF 2 PUSH GREF cdr APPLY 1) PUSH GREF single? APPLY 1) TEST (FRAME (FRAME (FRAME (LREF 2 PUSH GREF cdr APPLY 1) PUSH LREF 3 PUSH GREF table-get APPLY 2) PUSH GREF not APPLY 1) TEST (FRAME (CONST ((quote . "'") (quasiquote . "`") (unquote . ",") (unquote-splicing . ",@")) PUSH FRAME (LREF 2 PUSH GREF car APPLY 1) PUSH GREF assoc APPLY 2) . #4=(PUSH EXPND 1 LREF 0 TEST (FRAME (LREF 5 PUSH FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF display APPLY 2) LREF 5 PUSH FRAME (LREF 3 PUSH GREF cadr APPLY 1) PUSH GREF write TAPPLY 2) GREF nil PUSH EXPND 1 BOX 0 LREF 0 PUSH LREF 5 PUSH LREF 6 PUSH CLOSE 2 3 #0=(LREF 1 TEST (FRAME (FREF 0 PUSH LREF 0 PUSH GREF display APPLY 2) FRAME (FREF 0 PUSH FREF 1 PUSH FRAME (LREF 1 PUSH GREF car APPLY 1) PUSH GREF write/ss-print APPLY 3) FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH EXPND 1 LREF 0 TEST (FRAME (FRAME (LREF 0 PUSH GREF pair? APPLY 1) PUSH GREF not APPLY 1) . #3=(PUSH EXPND 1 LREF 0 TEST (LREF 0 . #1=(SHRNK 1 TEST (FRAME (FREF 0 PUSH CONST " . " PUSH GREF display APPLY 2) FREF 0 PUSH FREF 1 PUSH LREF 0 PUSH GREF write/ss-print TAPPLY 3) LREF 0 PUSH CONST " " PUSH LOOP 2 0 . #0#)) FRAME (LREF 1 PUSH FREF 1 PUSH GREF table-get APPLY 2) PUSH EXPND 1 LREF 0 TEST (LREF 0 . #2=(SHRNK 1 . #1#)) GREF nil . #2#)) CONST nil . #3#) VOID RET) LSET 0 FRAME (LREF 4 PUSH CONST "(" PUSH LREF 0 UNBOX DIRECTCALL 2 . #0#) SHRNK 1 LREF 5 PUSH CONST ")" PUSH GREF display TAPPLY 2)) CONST nil . #4#) CONST nil . #4#) FRAME (CONST vector PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 2 PUSH GREF vector-length APPLY 1) PUSH EXPND 1 GREF nil PUSH EXPND 1 BOX 0 LREF 1 PUSH LREF 0 PUSH LREF 5 PUSH LREF 4 PUSH LREF 6 PUSH CLOSE 2 5 #5=(FRAME (FREF 4 PUSH LREF 1 PUSH GREF < APPLY 2) TEST (FRAME (FREF 0 PUSH LREF 0 PUSH GREF display APPLY 2) FRAME (FREF 0 PUSH FREF 2 PUSH FRAME (LREF 1 PUSH FREF 1 PUSH GREF vector-get APPLY 2) PUSH GREF write/ss-print APPLY 3) FRAME (CONST 1 PUSH LREF 1 PUSH GREF + APPLY 2) PUSH CONST " " PUSH LOOP 2 0 . #5#) VOID RET) LSET 0 FRAME (CONST 0 PUSH CONST "#(" PUSH LREF 0 UNBOX DIRECTCALL 2 . #5#) SHRNK 1 LREF 5 PUSH CONST ")" PUSH GREF display TAPPLY 2) LREF 4 PUSH LREF 2 PUSH GREF write TAPPLY 2)) VOID . #6#)) CONST nil . #7#) DEF write/ss-print HALT)
(CLOSE 2 0 (GREF nil PUSH EXPND 1 BOX 0 LREF 0 PUSH CLOSE 3 1 #0=(LREF 2 TEST (FRAME (CONST 0 PUSH LREF 0 PUSH GREF > APPLY 2) . #1=(TEST (FRAME (LREF 2 PUSH GREF cdr APPLY 1) PUSH FRAME (LREF 1 PUSH FRAME (LREF 2 PUSH GREF car APPLY 1) PUSH GREF cons APPLY 2) PUSH FRAME (CONST 1 PUSH LREF 0 PUSH GREF - APPLY 2) PUSH LOOP 3 0 . #0#) LREF 1 PUSH GREF reverse! TAPPLY 1)) CONST nil . #1#) LSET 0 LREF 2 PUSH CONST nil PUSH LREF 1 PUSH LREF 0 UNBOX SHIFT 3 DIRECTCALL 3 . #0#) DEF take HALT)
(CLOSE 2 0 (LREF 1 TEST (FRAME (CONST 0 PUSH LREF 0 PUSH GREF > APPLY 2) TEST (FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH FRAME (CONST 1 PUSH LREF 0 PUSH GREF - APPLY 2) PUSH GREF drop TAPPLY 2) LREF 1 . #0=(RET)) VOID . #0#) DEF drop HALT)
(CLOSE 2 0 (FRAME (LREF 0 PUSH LREF 1 PUSH GREF drop APPLY 2) PUSH GREF car TAPPLY 1) DEF elt HALT)
(CLOSE 2 0 (GREF nil PUSH EXPND 1 BOX 0 LREF 1 PUSH LREF 0 PUSH CLOSE 2 2 #0=(LREF 0 TEST (FRAME (FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH FREF 1 APPLY 1) TEST (LREF 1 . #1=(RET)) FRAME (CONST 1 PUSH LREF 1 PUSH GREF + APPLY 2) PUSH FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH LOOP 2 0 . #0#) GREF nil . #1#) LSET 0 CONST 0 PUSH LREF 2 PUSH LREF 0 UNBOX SHIFT 2 DIRECTCALL 2 . #0#) DEF position-if HALT)
(CLOSE 2 0 (LREF 1 PUSH LREF 0 PUSH CLOSE 1 1 (FREF 0 PUSH LREF 0 PUSH GREF eq? TAPPLY 2) PUSH GREF position-if TAPPLY 2) DEF position HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF not APPLY 1) PUSH EXPND 1 LREF 0 TEST (LREF 0 . #0=(RET)) FRAME (LREF 1 PUSH GREF pair? APPLY 1) TEST (FRAME (FRAME (FRAME (LREF 1 PUSH GREF last APPLY 1) PUSH GREF cdr APPLY 1) PUSH GREF not APPLY 1) . #1=(PUSH EXPND 1 LREF 0 TEST (LREF 0 . #0#) GREF nil . #0#)) CONST nil . #1#) DEF list? HALT)
(CLOSE 2 0 (FRAME (FRAME (LREF 1 PUSH GREF car APPLY 1) PUSH LREF 0 PUSH GREF set-car! APPLY 2) FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 0 PUSH GREF set-cdr! TAPPLY 2) DEF copy-pair! HALT)
(CLOSE 2 0 (GREF nil PUSH EXPND 1 BOX 0 LREF 1 PUSH LREF 0 PUSH CLOSE 2 2 #0=(LREF 0 TEST (FRAME (FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH FREF 1 APPLY 1) TEST (LREF 1 . #1=(PUSH FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH LOOP 2 0 . #0#)) FRAME (LREF 1 PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF cons APPLY 2) . #1#) LREF 1 PUSH GREF reverse! TAPPLY 1) LSET 0 CONST nil PUSH LREF 2 PUSH LREF 0 UNBOX SHIFT 2 DIRECTCALL 2 . #0#) DEF remove-if HALT)
(CLOSE 2 0 (LREF 1 PUSH LREF 0 PUSH CLOSE 1 1 (FRAME (LREF 0 PUSH FREF 0 APPLY 1) PUSH GREF not TAPPLY 1) PUSH GREF remove-if TAPPLY 2) DEF remove-if-not HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF pair? APPLY 1) TEST (FRAME (FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF copy-list APPLY 1) PUSH FRAME (FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF copy-list APPLY 1) PUSH GREF cons TAPPLY 2) LREF 0 RET) DEF copy-list HALT)
(CLOSE 2 0 (FRAME (CONST 0 PUSH FRAME (LREF 1 PUSH LREF 0 PUSH GREF logand APPLY 2) PUSH GREF eq? APPLY 2) PUSH GREF not TAPPLY 1) DEF bit? HALT)
(MACRO record (2 -1) 0 (FRAME (FRAME (CONST nil PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (FRAME (FRAME (FRAME (CONST nil PUSH LREF 2 PUSH GREF append APPLY 2) PUSH FRAME (LREF 1 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (^) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (apply) PUSH GREF append TAPPLY 2) HALT)
(MACRO record-case (1 -1) 0 (FRAME (GREF gensym APPLY 0) PUSH EXPND 1 FRAME (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (FRAME (CONST nil PUSH FRAME (LREF 2 PUSH LREF 0 PUSH CLOSE 1 1 (FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH EXPND 1 FRAME (CONST t PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (LREF 1 RET) FRAME (CONST nil PUSH FRAME (FRAME (FRAME (FRAME (CONST nil PUSH FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (FRAME (FRAME (CONST nil PUSH FRAME (FREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (cdr) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (record) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append TAPPLY 2) PUSH GREF map APPLY 2) PUSH GREF append APPLY 2) PUSH FRAME (FRAME (FRAME (CONST nil PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (car) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (case) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 1 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (let1) PUSH GREF append TAPPLY 2) HALT)
(CLOSE 1 0 (LREF 0 TEST (FRAME (FRAME (LREF 0 PUSH GREF pair? APPLY 1) PUSH GREF not APPLY 1) PUSH EXPND 1 LREF 0 TEST (LREF 0 . #1=(SHRNK 1 . #3=(TEST (GREF nil PUSH EXPND 1 BOX 0 LREF 0 PUSH CLOSE 2 1 #0=(FRAME (LREF 0 PUSH GREF pair? APPLY 1) TEST (FRAME (LREF 1 PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF cons APPLY 2) PUSH FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH LOOP 2 0 . #0#) FRAME (LREF 1 PUSH LREF 0 PUSH GREF cons APPLY 2) PUSH GREF reverse! TAPPLY 1) LSET 0 CONST nil PUSH LREF 1 PUSH LREF 0 UNBOX SHIFT 2 DIRECTCALL 2 . #0#) LREF 0 RET))) FRAME (FRAME (LREF 1 PUSH GREF last APPLY 1) PUSH GREF cdr APPLY 1) PUSH EXPND 1 LREF 0 TEST (LREF 0 . #2=(SHRNK 1 . #1#)) GREF nil . #2#) CONST nil . #3#) DEF dotted->proper HALT)
(CLOSE 2 0 (LREF 0 TEST (FRAME (LREF 1 PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF member APPLY 2) TEST (LREF 1 PUSH FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF set-minus TAPPLY 2) FRAME (LREF 1 PUSH FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF set-minus APPLY 2) PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF cons TAPPLY 2) CONST nil RET) DEF set-minus HALT)
(CONST 1 DEF VAR-ARG HALT)
(CONST 2 DEF VAR-FREE HALT)
(CONST 4 DEF VAR-SET HALT)
(CONST 8 DEF VAR-SELF-TAIL-RECUR HALT)
(CONST 16 DEF VAR-CALL-IN-BASE1 HALT)
(CONST 32 DEF VAR-CALL-IN-BASE2 HALT)
(CONST 64 DEF VAR-CALL-OTHER HALT)
(CLOSE 3 0 (FRAME (LREF 0 PUSH GREF symbol? APPLY 1) TEST (FRAME (GREF VAR-ARG PUSH LREF 0 PUSH LREF 1 PUSH GREF add-var-info APPLY 3) LREF 1 PUSH LREF 0 PUSH GREF traverse-refer TAPPLY 2) FRAME (LREF 0 PUSH GREF pair? APPLY 1) TEST (FRAME (LREF 1 PUSH LREF 0 PUSH GREF expand-macro APPLY 2) PUSH EXPND 1 FRAME (LREF 0 PUSH GREF pair? APPLY 1) TEST (LREF 3 PUSH LREF 2 PUSH LREF 0 PUSH GREF traverse-list TAPPLY 3) LREF 3 PUSH LREF 2 PUSH LREF 0 PUSH GREF traverse TAPPLY 3) LREF 0 PUSH CONST :CONST PUSH GREF list TAPPLY 2) DEF traverse HALT)
(CLOSE 3 0 (LREF 0 PUSH EXPND 1 FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH EXPND 1 FRAME (CONST quote PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH CLOSE 1 0 (LREF 0 PUSH CONST :CONST PUSH GREF list TAPPLY 2) PUSH GREF apply TAPPLY 2) FRAME (CONST ^ PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 3 PUSH CLOSE (1 -1) 1 (FREF 0 PUSH LREF 1 PUSH LREF 0 PUSH GREF traverse-lambda TAPPLY 3) PUSH GREF apply TAPPLY 2) FRAME (CONST if PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 4 PUSH LREF 3 PUSH CLOSE (2 -1) 2 (FREF 1 PUSH FREF 0 PUSH LREF 2 PUSH LREF 1 PUSH LREF 0 PUSH GREF traverse-if TAPPLY 5) PUSH GREF apply TAPPLY 2) FRAME (CONST set! PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 3 PUSH CLOSE 2 1 (FREF 0 PUSH LREF 1 PUSH LREF 0 PUSH GREF traverse-set! TAPPLY 3) PUSH GREF apply TAPPLY 2) FRAME (CONST def PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 3 PUSH CLOSE 2 1 (FREF 0 PUSH LREF 1 PUSH LREF 0 PUSH GREF traverse-def TAPPLY 3) PUSH GREF apply TAPPLY 2) FRAME (CONST call/cc PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 4 PUSH LREF 3 PUSH CLOSE 1 2 (FREF 1 PUSH FREF 0 PUSH LREF 0 PUSH GREF traverse-call/cc TAPPLY 3) PUSH GREF apply TAPPLY 2) FRAME (CONST defmacro PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 3 PUSH CLOSE (2 -1) 1 (FREF 0 PUSH LREF 2 PUSH LREF 1 PUSH LREF 0 PUSH GREF traverse-defmacro TAPPLY 4) PUSH GREF apply TAPPLY 2) FRAME (CONST values PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 4 PUSH LREF 3 PUSH CLOSE (0 -1) 2 (FREF 1 PUSH FREF 0 PUSH LREF 0 PUSH GREF traverse-values TAPPLY 3) PUSH GREF apply TAPPLY 2) FRAME (CONST receive PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 4 PUSH LREF 3 PUSH CLOSE (2 -1) 2 (FREF 1 PUSH FREF 0 PUSH LREF 2 PUSH LREF 1 PUSH LREF 0 PUSH GREF traverse-receive TAPPLY 5) PUSH GREF apply TAPPLY 2) FRAME (LREF 2 PUSH GREF cdr APPLY 1) PUSH FRAME (LREF 2 PUSH GREF car APPLY 1) PUSH EXPND 2 FRAME (LREF 0 PUSH GREF direct-invoke? APPLY 1) TEST (LREF 6 PUSH LREF 5 PUSH LREF 1 PUSH FRAME (LREF 0 PUSH GREF cddr APPLY 1) PUSH FRAME (LREF 0 PUSH GREF cadr APPLY 1) PUSH GREF traverse-apply-direct TAPPLY 5) FRAME (LREF 0 PUSH GREF inline-function? APPLY 1) TEST (LREF 5 PUSH LREF 1 PUSH LREF 0 PUSH GREF traverse-inline-apply TAPPLY 3) LREF 6 PUSH LREF 5 PUSH LREF 1 PUSH LREF 0 PUSH GREF traverse-apply TAPPLY 4) DEF traverse-list HALT)
(CLOSE 2 0 (FRAME (FRAME (LREF 0 PUSH LREF 1 PUSH GREF scope-local-has? APPLY 2) PUSH GREF not APPLY 1) TEST (FRAME (LREF 0 PUSH LREF 1 PUSH GREF scope-upper-vars-has? APPLY 2) . #1=(TEST (FRAME (LREF 0 PUSH LREF 1 PUSH GREF register-fref APPLY 2) . #0=(LREF 0 PUSH CONST :REF PUSH GREF list TAPPLY 2)) VOID . #0#)) CONST nil . #1#) DEF traverse-refer HALT)
(CLOSE 3 0 (FRAME (LREF 0 PUSH GREF symbol? APPLY 1) TEST (VOID . #5=(FRAME (GREF nil PUSH LREF 2 PUSH LREF 1 PUSH GREF traverse APPLY 3) PUSH FRAME (LREF 0 PUSH LREF 2 PUSH GREF scope-upper-vars-has? APPLY 2) PUSH FRAME (LREF 0 PUSH LREF 2 PUSH GREF scope-local-has? APPLY 2) PUSH EXPND 3 FRAME (LREF 0 PUSH GREF not APPLY 1) TEST (LREF 1 . #4=(TEST (FRAME (LREF 3 PUSH LREF 5 PUSH GREF register-fref APPLY 2) . #3=(LREF 0 PUSH EXPND 1 LREF 0 TEST (LREF 0 . #1=(SHRNK 1 TEST (FRAME (LREF 2 PUSH LREF 3 PUSH LREF 5 PUSH GREF register-set! APPLY 3) . #0=(LREF 2 PUSH LREF 3 PUSH CONST :SET PUSH GREF list TAPPLY 3)) VOID . #0#)) LREF 2 PUSH EXPND 1 LREF 0 TEST (LREF 0 . #2=(SHRNK 1 . #1#)) GREF nil . #2#)) VOID . #3#)) CONST nil . #4#)) FRAME (LREF 0 PUSH CONST "`set!` requires symbol, but `%@`" PUSH GREF compile-error APPLY 2) . #5#) DEF traverse-set! HALT)
(CLOSE 3 0 (FRAME (LREF 0 PUSH GREF symbol? APPLY 1) TEST (VOID . #2=(FRAME (LREF 0 PUSH GREF inline-function? APPLY 1) TEST (FRAME (LREF 1 PUSH GREF lambda-expression? APPLY 1) . #1=(TEST (FRAME (LREF 1 PUSH LREF 0 PUSH GREF register-inline-function APPLY 2) . #0=(FRAME (GREF nil PUSH LREF 2 PUSH LREF 1 PUSH GREF traverse APPLY 3) PUSH EXPND 1 FRAME (LREF 0 PUSH LREF 1 PUSH LREF 3 PUSH GREF register-set! APPLY 3) LREF 0 PUSH LREF 1 PUSH CONST :DEF PUSH GREF list TAPPLY 3)) VOID . #0#)) CONST nil . #1#)) FRAME (LREF 0 PUSH CONST "`def` requires symbol, but `%@`" PUSH GREF compile-error APPLY 2) . #2#) DEF traverse-def HALT)
(CLOSE 5 0 (LREF 2 TEST (FRAME (LREF 2 PUSH GREF cdr APPLY 1) . #2=(TEST (FRAME (CONST "malformed if" PUSH GREF compile-error APPLY 1) . #1=(LREF 2 TEST (FRAME (LREF 4 PUSH LREF 3 PUSH FRAME (LREF 2 PUSH GREF car APPLY 1) PUSH GREF traverse APPLY 3) . #0=(PUSH FRAME (LREF 4 PUSH LREF 3 PUSH LREF 1 PUSH GREF traverse APPLY 3) PUSH FRAME (GREF nil PUSH LREF 3 PUSH LREF 0 PUSH GREF traverse APPLY 3) PUSH CONST :IF PUSH GREF list TAPPLY 4)) CONST (:VOID) . #0#)) VOID . #1#)) CONST nil . #2#) DEF traverse-if HALT)
(CLOSE 3 0 (FRAME (LREF 2 PUSH LREF 1 PUSH LREF 0 PUSH GREF traverse APPLY 3) PUSH CONST :CONTI PUSH GREF list TAPPLY 2) DEF traverse-call/cc HALT)
(CLOSE 3 0 (FRAME (LREF 0 PUSH GREF check-parameters APPLY 1) PUSH EXPND 1 FRAME (LREF 3 PUSH LREF 0 PUSH GREF create-scope APPLY 2) PUSH EXPND 1 FRAME (GREF t PUSH LREF 0 PUSH LREF 3 PUSH GREF traverse-body APPLY 3) PUSH EXPND 1 FRAME (LREF 2 PUSH LREF 3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 3 PUSH GREF length APPLY 1) . #0=(PUSH EXPND 1 FRAME (FRAME (LREF 2 PUSH GREF scope-local APPLY 1) PUSH LREF 2 PUSH LREF 6 PUSH GREF propagate-scope-to-upper APPLY 3) LREF 1 PUSH LREF 0 PUSH LREF 3 PUSH LREF 2 PUSH GREF create-lambda-node TAPPLY 4)) FRAME (CONST -1 PUSH FRAME (CONST 1 PUSH FRAME (LREF 2 PUSH GREF length APPLY 1) PUSH GREF - APPLY 2) PUSH GREF list APPLY 2) . #0#) DEF traverse-lambda HALT)
(CLOSE 3 0 (LREF 0 PUSH LREF 2 PUSH LREF 1 PUSH CLOSE 1 2 (FRAME (FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF not APPLY 1) TEST (FREF 1 . #0=(PUSH FREF 0 PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF traverse TAPPLY 3)) CONST nil . #0#) PUSH GREF maplist TAPPLY 2) DEF traverse-body HALT)
(CLOSE 3 0 (FRAME (LREF 2 PUSH LREF 0 PUSH LREF 1 PUSH CLOSE 2 3 (FRAME (FREF 1 PUSH FREF 0 PUSH GREF scope-local-has? APPLY 2) TEST (FRAME (CONST 0 PUSH FRAME (GREF VAR-CALL-IN-BASE1 PUSH FRAME (CONST 0 PUSH LREF 0 PUSH GREF vector-get APPLY 2) PUSH GREF logand APPLY 2) PUSH GREF eq? APPLY 2) TEST (GREF VAR-CALL-IN-BASE1 . #0=(RET)) GREF VAR-CALL-IN-BASE2 . #0#) FRAME (FREF 1 PUSH FREF 0 PUSH GREF var-is-set? APPLY 2) PUSH EXPND 1 LREF 0 TEST (FRAME (LREF 0 PUSH GREF single? APPLY 1) TEST (FRAME (FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF lambda-node? APPLY 1) TEST (FREF 2 . #1=(TEST (GREF VAR-SELF-TAIL-RECUR . #0#) GREF VAR-CALL-OTHER . #0#)) CONST nil . #1#) CONST nil . #1#) CONST nil . #1#) PUSH LREF 0 PUSH LREF 1 PUSH GREF with-var-info APPLY 3) PUSH EXPND 1 LREF 0 TEST (LREF 0 . #2=(RET)) GREF VAR-CALL-OTHER . #2#) DEF detect-call-type HALT)
(CLOSE 4 0 (FRAME (LREF 0 PUSH GREF symbol? APPLY 1) TEST (FRAME (LREF 2 PUSH LREF 0 PUSH GREF traverse-refer APPLY 2) . #0=(PUSH FRAME (LREF 3 PUSH LREF 2 PUSH LREF 0 PUSH GREF detect-call-type APPLY 3) PUSH EXPND 2 FRAME (LREF 0 PUSH LREF 2 PUSH LREF 4 PUSH GREF add-var-info APPLY 3) FRAME (LREF 3 PUSH LREF 4 PUSH CLOSE 1 1 (GREF nil PUSH FREF 0 PUSH LREF 0 PUSH GREF traverse TAPPLY 3) PUSH GREF map APPLY 2) PUSH LREF 1 PUSH LREF 5 PUSH CONST :APPLY PUSH GREF list TAPPLY 4)) FRAME (GREF nil PUSH LREF 2 PUSH LREF 0 PUSH GREF traverse APPLY 3) . #0#) DEF traverse-apply HALT)
(CLOSE 4 0 (FRAME (LREF 0 PUSH GREF get-inline-function-body APPLY 1) PUSH EXPND 1 LREF 4 PUSH LREF 3 PUSH FRAME (FRAME (CONST nil PUSH LREF 2 PUSH GREF append APPLY 2) PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH GREF traverse TAPPLY 3) DEF traverse-inline-apply HALT)
(CLOSE 5 0 (FRAME (LREF 0 PUSH GREF check-parameters APPLY 1) PUSH EXPND 1 FRAME (FRAME (LREF 1 PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (CONST 0 . #0=(PUSH FRAME (LREF 0 PUSH GREF length APPLY 1) PUSH GREF - APPLY 2)) CONST 1 . #0#) PUSH FRAME (LREF 3 PUSH GREF length APPLY 1) PUSH EXPND 2 FRAME (FRAME (LREF 2 PUSH LREF 3 PUSH GREF eq? APPLY 2) PUSH GREF not APPLY 1) TEST (FRAME (LREF 1 PUSH LREF 0 PUSH GREF < APPLY 2) TEST (LREF 7 PUSH LREF 6 PUSH LREF 5 PUSH LREF 4 PUSH LREF 2 PUSH GREF traverse-apply-direct TAPPLY 5) FRAME (LREF 1 PUSH LREF 0 PUSH GREF > APPLY 2) TEST (LREF 7 PUSH LREF 6 PUSH FRAME (FRAME (FRAME (CONST nil PUSH FRAME (FRAME (FRAME (CONST nil PUSH FRAME (LREF 5 PUSH LREF 1 PUSH GREF drop APPLY 2) PUSH GREF append APPLY 2) PUSH CONST (list) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH FRAME (LREF 5 PUSH LREF 1 PUSH GREF take APPLY 2) PUSH GREF append APPLY 2) PUSH FRAME (FRAME (FRAME (FRAME (CONST nil PUSH LREF 4 PUSH GREF append APPLY 2) PUSH FRAME (LREF 2 PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH CONST (^) PUSH GREF append APPLY 2) PUSH GREF list APPLY 1) PUSH GREF append APPLY 2) PUSH GREF traverse TAPPLY 3) LREF 7 PUSH LREF 6 PUSH FRAME (CONST (nil) PUSH LREF 5 PUSH GREF append APPLY 2) PUSH LREF 4 PUSH LREF 2 PUSH GREF traverse-apply-direct TAPPLY 5) FRAME (LREF 1 PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 5 PUSH LREF 6 PUSH CLOSE 1 1 (GREF nil PUSH FREF 0 PUSH LREF 0 PUSH GREF traverse TAPPLY 3) PUSH GREF map APPLY 2) PUSH EXPND 1 FRAME (LREF 7 PUSH LREF 3 PUSH GREF expand-scope APPLY 2) PUSH EXPND 1 FRAME (LREF 9 PUSH LREF 0 PUSH LREF 6 PUSH GREF traverse-body APPLY 3) PUSH EXPND 1 FRAME (LREF 5 PUSH LREF 1 PUSH LREF 9 PUSH GREF propagate-scope-to-upper APPLY 3) LREF 0 PUSH LREF 2 PUSH LREF 5 PUSH LREF 1 PUSH CONST :INVOKE PUSH GREF list TAPPLY 5) FRAME (LREF 1 PUSH LREF 0 PUSH GREF < APPLY 2) TEST (CONST "few" . #1=(PUSH EXPND 1 LREF 2 PUSH LREF 1 PUSH LREF 0 PUSH CONST "Too %@ arguments, %@ for %@" PUSH GREF compile-error TAPPLY 4)) CONST "many" . #1#) DEF traverse-apply-direct HALT)
(CLOSE 4 0 (FRAME (LREF 1 PUSH GREF check-parameters APPLY 1) PUSH EXPND 1 FRAME (LREF 4 PUSH LREF 0 PUSH GREF create-scope APPLY 2) PUSH EXPND 1 FRAME (GREF t PUSH LREF 0 PUSH LREF 4 PUSH GREF traverse-body APPLY 3) PUSH EXPND 1 FRAME (LREF 2 PUSH LREF 4 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 4 PUSH GREF length APPLY 1) . #0=(PUSH EXPND 1 FRAME (FRAME (LREF 2 PUSH GREF scope-local APPLY 1) PUSH LREF 2 PUSH LREF 7 PUSH GREF propagate-scope-to-upper APPLY 3) LREF 1 PUSH LREF 0 PUSH LREF 4 PUSH LREF 2 PUSH CONST :MACRO PUSH GREF list TAPPLY 5)) FRAME (CONST -1 PUSH FRAME (CONST 1 PUSH FRAME (LREF 2 PUSH GREF length APPLY 1) PUSH GREF - APPLY 2) PUSH GREF list APPLY 2) . #0#) DEF traverse-defmacro HALT)
(CLOSE 3 0 (FRAME (LREF 0 PUSH LREF 0 PUSH LREF 2 PUSH LREF 1 PUSH CLOSE 1 3 (FRAME (FREF 2 PUSH GREF cdr APPLY 1) TEST (FREF 1 . #0=(PUSH FREF 0 PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF traverse TAPPLY 3)) CONST nil . #0#) PUSH GREF maplist APPLY 2) PUSH CONST :VALS PUSH GREF list TAPPLY 2) DEF traverse-values HALT)
(CLOSE 5 0 (FRAME (LREF 0 PUSH GREF check-parameters APPLY 1) PUSH EXPND 1 FRAME (GREF nil PUSH LREF 4 PUSH LREF 2 PUSH GREF traverse APPLY 3) PUSH FRAME (LREF 0 PUSH LREF 1 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 1 PUSH GREF length APPLY 1) . #0=(PUSH EXPND 2 FRAME (LREF 6 PUSH LREF 2 PUSH GREF expand-scope APPLY 2) PUSH EXPND 1 FRAME (LREF 8 PUSH LREF 0 PUSH LREF 6 PUSH GREF traverse-body APPLY 3) PUSH EXPND 1 FRAME (LREF 4 PUSH LREF 1 PUSH LREF 8 PUSH GREF propagate-scope-to-upper APPLY 3) LREF 0 PUSH LREF 3 PUSH LREF 2 PUSH LREF 4 PUSH LREF 1 PUSH CONST :RECV PUSH GREF list TAPPLY 6)) FRAME (CONST -1 PUSH FRAME (CONST 1 PUSH FRAME (LREF 0 PUSH GREF length APPLY 1) PUSH GREF - APPLY 2) PUSH GREF list APPLY 2) . #0#) DEF traverse-receive HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF list? APPLY 1) TEST (VOID . #6=(FRAME (LREF 0 PUSH CLOSE 1 0 (FRAME (CONST &rest PUSH LREF 0 PUSH GREF eq? APPLY 2) PUSH EXPND 1 LREF 0 TEST (LREF 0 . #0=(RET)) FRAME (CONST &body PUSH LREF 1 PUSH GREF eq? APPLY 2) PUSH EXPND 1 LREF 0 TEST (LREF 0 . #0#) GREF nil . #0#) PUSH GREF position-if APPLY 2) PUSH EXPND 1 LREF 0 TEST (FRAME (LREF 1 PUSH FRAME (CONST 1 PUSH LREF 0 PUSH GREF + APPLY 2) PUSH GREF drop APPLY 2) PUSH FRAME (LREF 1 PUSH LREF 0 PUSH GREF take APPLY 2) PUSH EXPND 2 FRAME (LREF 1 PUSH GREF single? APPLY 1) TEST (VOID . #4=(FRAME (LREF 1 PUSH LREF 0 PUSH GREF append! APPLY 2) SHRNK 2 . #5=(SHRNK 1 PUSH EXPND 1 FRAME (LREF 1 PUSH CLOSE 1 0 (FRAME (LREF 0 PUSH GREF symbol? APPLY 1) PUSH GREF not TAPPLY 1) PUSH GREF any? APPLY 2) PUSH EXPND 1 LREF 0 TEST (FRAME (FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH CONST "parameter must be symbol, but `%@`" PUSH GREF compile-error APPLY 2) . #3=(SHRNK 1 GREF nil PUSH EXPND 1 BOX 0 LREF 0 PUSH CLOSE 1 1 #1=(LREF 0 TEST (FRAME (FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF member APPLY 2) TEST (FRAME (FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH CONST "Duplicated parameter `%@`" PUSH GREF compile-error APPLY 2) . #2=(FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH LOOP 1 0 . #1#)) VOID . #2#) VOID RET) LSET 0 FRAME (LREF 1 PUSH LREF 0 UNBOX DIRECTCALL 1 . #1#) SHRNK 1 LREF 0 RET)) VOID . #3#))) FRAME (LREF 1 PUSH CONST "&rest requires only 1 name, but %@" PUSH GREF compile-error APPLY 2) . #4#) LREF 1 . #5#)) FRAME (LREF 0 PUSH CONST "parameters must be list, but %@" PUSH GREF compile-error APPLY 2) . #6#) DEF check-parameters HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF pair? APPLY 1) TEST (FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH CONST ^ PUSH GREF eq? TAPPLY 2) CONST nil RET) DEF direct-invoke? HALT)
(CLOSE 2 0 (FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH EXPND 1 FRAME (FRAME (LREF 0 PUSH GREF symbol? APPLY 1) PUSH GREF not APPLY 1) PUSH EXPND 1 LREF 0 TEST (LREF 0 . #0=(SHRNK 1 TEST (LREF 1 RET) LREF 1 PUSH GREF macroexpand TAPPLY 1)) FRAME (LREF 1 PUSH LREF 3 PUSH GREF scope-local-has? APPLY 2) PUSH EXPND 1 LREF 0 TEST (LREF 0 . #1=(SHRNK 1 . #0#)) FRAME (LREF 2 PUSH LREF 4 PUSH GREF scope-upper-vars-has? APPLY 2) PUSH EXPND 1 LREF 0 TEST (LREF 0 . #2=(SHRNK 1 . #1#)) GREF nil . #2#) DEF expand-macro HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF macroexpand-1 APPLY 1) PUSH EXPND 1 FRAME (LREF 1 PUSH LREF 0 PUSH GREF equal? APPLY 2) TEST (LREF 1 RET) LREF 0 PUSH GREF macroexpand TAPPLY 1) DEF macroexpand HALT)
(CLOSE 2 0 (FRAME (LREF 0 PUSH CLOSE 1 0 (GREF nil PUSH CONST 0 PUSH GREF vector TAPPLY 2) PUSH GREF map APPLY 2) PUSH FRAME (GREF gensym APPLY 0) PUSH EXPND 2 LREF 3 PUSH LREF 0 PUSH CONST nil PUSH LREF 1 PUSH LREF 2 PUSH GREF vector TAPPLY 5) DEF create-scope HALT)
(CLOSE 2 0 (FRAME (FRAME (LREF 1 PUSH GREF scope-local-info APPLY 1) PUSH FRAME (LREF 0 PUSH CLOSE 1 0 (GREF nil PUSH CONST 0 PUSH GREF vector TAPPLY 2) PUSH GREF map APPLY 2) PUSH GREF append APPLY 2) PUSH FRAME (FRAME (LREF 1 PUSH GREF scope-local APPLY 1) PUSH LREF 0 PUSH GREF append APPLY 2) PUSH EXPND 2 LREF 3 PUSH FRAME (LREF 3 PUSH GREF scope-id APPLY 1) PUSH FRAME (LREF 3 PUSH GREF scope-frees APPLY 1) PUSH LREF 1 PUSH LREF 0 PUSH GREF vector TAPPLY 5) DEF expand-scope HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF scope-outer-scope APPLY 1) PUSH EXPND 1 FRAME (FRAME (LREF 1 PUSH GREF scope-id APPLY 1) PUSH FRAME (LREF 0 PUSH GREF scope-id APPLY 1) PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 0 PUSH GREF scope-local APPLY 1) PUSH GREF length TAPPLY 1) CONST 0 RET) DEF get-expanded-scope-outer-local-count HALT)
(CLOSE 1 0 (CONST 0 PUSH LREF 0 PUSH GREF vector-get TAPPLY 2) DEF scope-local HALT)
(CLOSE 1 0 (CONST 1 PUSH LREF 0 PUSH GREF vector-get TAPPLY 2) DEF scope-local-info HALT)
(CLOSE 1 0 (CONST 2 PUSH LREF 0 PUSH GREF vector-get TAPPLY 2) DEF scope-frees HALT)
(CLOSE 1 0 (CONST 3 PUSH LREF 0 PUSH GREF vector-get TAPPLY 2) DEF scope-id HALT)
(CLOSE 1 0 (CONST 4 PUSH LREF 0 PUSH GREF vector-get TAPPLY 2) DEF scope-outer-scope HALT)
(CLOSE 2 0 (LREF 1 PUSH CONST 2 PUSH LREF 0 PUSH GREF vector-set! TAPPLY 3) DEF scope-frees-set! HALT)
(CLOSE 2 0 (FRAME (LREF 0 PUSH GREF scope-local APPLY 1) PUSH LREF 1 PUSH GREF position TAPPLY 2) DEF scope-local-has? HALT)
(CLOSE 2 0 (GREF nil PUSH EXPND 1 BOX 0 LREF 0 PUSH LREF 2 PUSH CLOSE 1 2 #0=(LREF 0 TEST (FRAME (FREF 0 PUSH LREF 0 PUSH GREF scope-local-has? APPLY 2) PUSH EXPND 1 LREF 0 TEST (LREF 0 . #1=(RET)) FRAME (LREF 1 PUSH GREF scope-outer-scope APPLY 1) PUSH LOOP 1 0 . #0#) GREF nil . #1#) LSET 0 FRAME (LREF 1 PUSH GREF scope-outer-scope APPLY 1) PUSH LREF 0 UNBOX SHIFT 1 DIRECTCALL 1 . #0#) DEF scope-upper-vars-has? HALT)
(CLOSE 3 0 (LREF 0 TEST (FRAME (FRAME (FRAME (LREF 0 PUSH GREF scope-local APPLY 1) PUSH FRAME (LREF 1 PUSH GREF scope-frees APPLY 1) PUSH GREF set-minus APPLY 2) PUSH FRAME (LREF 0 PUSH GREF scope-frees APPLY 1) PUSH GREF union APPLY 2) PUSH LREF 0 PUSH GREF scope-frees-set! TAPPLY 2) VOID RET) DEF propagate-scope-to-upper HALT)
(CLOSE 3 0 (FRAME (LREF 1 PUSH GREF symbol? APPLY 1) TEST (GREF nil PUSH EXPND 1 BOX 0 LREF 3 PUSH LREF 0 PUSH LREF 2 PUSH CLOSE 1 3 #0=(LREF 0 TEST (FRAME (FREF 0 PUSH LREF 0 PUSH GREF scope-local-has? APPLY 2) PUSH EXPND 1 LREF 0 TEST (LREF 1 PUSH FRAME (LREF 0 PUSH FRAME (LREF 1 PUSH GREF scope-local-info APPLY 1) PUSH GREF elt APPLY 2) PUSH FREF 2 TAPPLY 2) FRAME (LREF 1 PUSH GREF scope-outer-scope APPLY 1) PUSH LOOP 1 0 . #0#) VOID RET) LSET 0 LREF 1 PUSH LREF 0 UNBOX SHIFT 1 DIRECTCALL 1 . #0#) VOID RET) DEF with-var-info HALT)
(CLOSE 3 0 (LREF 2 PUSH CLOSE 2 1 (FRAME (FRAME (FREF 0 PUSH FRAME (CONST 0 PUSH LREF 0 PUSH GREF vector-get APPLY 2) PUSH GREF logior APPLY 2) PUSH CONST 0 PUSH LREF 0 PUSH GREF vector-set! APPLY 3) LREF 0 RET) PUSH LREF 1 PUSH LREF 0 PUSH GREF with-var-info TAPPLY 3) DEF add-var-info HALT)
(CLOSE 3 0 (LREF 2 PUSH CLOSE 2 1 (FRAME (CONST 0 PUSH FRAME (FREF 0 PUSH FRAME (CONST 0 PUSH LREF 0 PUSH GREF vector-get APPLY 2) PUSH GREF logand APPLY 2) PUSH GREF eq? APPLY 2) TEST (VOID . #0=(RET)) LREF 0 . #0#) PUSH LREF 1 PUSH LREF 0 PUSH GREF with-var-info TAPPLY 3) DEF var-has-attr? HALT)
(CLOSE 2 0 (FRAME (GREF VAR-SET PUSH LREF 1 PUSH LREF 0 PUSH GREF var-has-attr? APPLY 3) PUSH EXPND 1 LREF 0 TEST (CONST 1 PUSH LREF 0 PUSH GREF vector-get TAPPLY 2) GREF nil RET) DEF var-is-set? HALT)
(CLOSE 2 0 (FRAME (GREF VAR-FREE PUSH LREF 1 PUSH LREF 0 PUSH GREF add-var-info APPLY 3) FRAME (LREF 0 PUSH GREF scope-frees APPLY 1) PUSH EXPND 1 LREF 0 TEST (FRAME (LREF 0 PUSH LREF 2 PUSH GREF position APPLY 2) PUSH EXPND 1 LREF 0 TEST (LREF 0 . #0=(RET)) FRAME (LREF 1 PUSH GREF length APPLY 1) PUSH EXPND 1 FRAME (FRAME (GREF nil PUSH LREF 4 PUSH GREF cons APPLY 2) PUSH FRAME (LREF 2 PUSH GREF last APPLY 1) PUSH GREF set-cdr! APPLY 2) LREF 0 . #0#) FRAME (FRAME (GREF nil PUSH LREF 2 PUSH GREF cons APPLY 2) PUSH LREF 1 PUSH GREF scope-frees-set! APPLY 2) CONST 0 . #0#) DEF register-fref HALT)
(CLOSE 3 0 (FRAME (GREF VAR-SET PUSH LREF 1 PUSH LREF 0 PUSH GREF add-var-info APPLY 3) PUSH EXPND 1 LREF 0 TEST (FRAME (FRAME (CONST 1 PUSH LREF 0 PUSH GREF vector-get APPLY 2) PUSH LREF 3 PUSH GREF cons APPLY 2) PUSH CONST 1 PUSH LREF 0 PUSH GREF vector-set! TAPPLY 3) VOID RET) DEF register-set! HALT)
(CLOSE 4 0 (LREF 3 PUSH LREF 2 PUSH LREF 1 PUSH FRAME (GREF nil PUSH GREF nil PUSH GREF cons APPLY 2) PUSH LREF 0 PUSH CONST :LAMBDA PUSH GREF list TAPPLY 6) DEF create-lambda-node HALT)
(CLOSE 1 0 (CONST :LAMBDA PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF eq? TAPPLY 2) DEF lambda-node? HALT)
(GREF cadr DEF lambda-scope-get HALT)
(GREF caddr DEF lambda-body-slot-get HALT)
(GREF caddddr DEF lambda-varnum-get HALT)
(CLOSE 1 0 (CONST 5 PUSH LREF 0 PUSH GREF elt TAPPLY 2) DEF lambda-body-node-get HALT)
(CLOSE 2 0 (LREF 1 PUSH FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF set-car! TAPPLY 2) DEF lambda-scope-set! HALT)
(CLOSE 3 0 (LREF 0 PUSH EXPND 1 FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH EXPND 1 FRAME (CONST :CONST PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 4 PUSH CLOSE 1 1 (FREF 0 PUSH LREF 0 PUSH CONST CONST PUSH GREF list* TAPPLY 3) PUSH GREF apply TAPPLY 2) FRAME (CONST :VOID PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 4 PUSH CLOSE 0 1 (FREF 0 PUSH CONST VOID PUSH GREF list* TAPPLY 2) PUSH GREF apply TAPPLY 2) FRAME (CONST :REF PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 4 PUSH LREF 3 PUSH CLOSE 1 2 (FRAME (LREF 0 PUSH FREF 0 PUSH GREF scope-local-has? APPLY 2) PUSH EXPND 1 LREF 0 TEST (LREF 0 PUSH EXPND 1 LREF 0 PUSH CONST LREF PUSH VALS 2 SHRNK 1 . #2=(SHRNK 1 RECV 2 FRAME (FRAME (CONST GREF PUSH LREF 0 PUSH GREF eq? APPLY 2) PUSH GREF not APPLY 1) TEST (FRAME (LREF 2 PUSH FREF 0 PUSH GREF var-is-set? APPLY 2) . #1=(TEST (FRAME (FREF 1 PUSH CONST UNBOX PUSH GREF list* APPLY 2) . #0=(PUSH LREF 1 PUSH LREF 0 PUSH GREF list* TAPPLY 3)) FREF 1 . #0#)) CONST nil . #1#)) FRAME (FRAME (FREF 0 PUSH GREF scope-frees APPLY 1) PUSH LREF 1 PUSH GREF position APPLY 2) PUSH EXPND 1 LREF 0 TEST (LREF 0 PUSH EXPND 1 LREF 0 PUSH CONST FREF PUSH VALS 2 SHRNK 1 . #3=(SHRNK 1 . #2#)) LREF 2 PUSH CONST GREF PUSH VALS 2 . #3#) PUSH GREF apply TAPPLY 2) FRAME (CONST :SET PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 4 PUSH LREF 3 PUSH CLOSE 2 2 (FREF 1 PUSH FREF 0 PUSH LREF 1 PUSH LREF 0 PUSH GREF compile-set! TAPPLY 4) PUSH GREF apply TAPPLY 2) FRAME (CONST :DEF PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 4 PUSH LREF 3 PUSH CLOSE 2 2 (FRAME (FREF 1 PUSH LREF 0 PUSH CONST DEF PUSH GREF list* APPLY 3) PUSH FREF 0 PUSH LREF 1 PUSH GREF compile-recur TAPPLY 3) PUSH GREF apply TAPPLY 2) FRAME (CONST :IF PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 4 PUSH LREF 3 PUSH CLOSE 3 2 (FRAME (FRAME (FREF 1 PUSH FREF 0 PUSH LREF 2 PUSH GREF compile-recur APPLY 3) PUSH FRAME (FREF 1 PUSH FREF 0 PUSH LREF 1 PUSH GREF compile-recur APPLY 3) PUSH CONST TEST PUSH GREF list* APPLY 3) PUSH FREF 0 PUSH LREF 0 PUSH GREF compile-recur TAPPLY 3) PUSH GREF apply TAPPLY 2) FRAME (CONST :LAMBDA PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 4 PUSH LREF 3 PUSH CLOSE 5 2 (FRAME (LREF 0 PUSH GREF scope-frees APPLY 1) PUSH EXPND 1 FRAME (FRAME (FRAME (CONST RET PUSH GREF list APPLY 1) PUSH LREF 1 PUSH LREF 5 PUSH FRAME (LREF 1 PUSH GREF scope-local APPLY 1) PUSH GREF compile-body APPLY 4) PUSH LREF 2 PUSH GREF copy-pair! APPLY 2) FRAME (FREF 1 PUSH LREF 2 PUSH FRAME (LREF 0 PUSH GREF length APPLY 1) PUSH LREF 4 PUSH CONST CLOSE PUSH GREF list* APPLY 5) PUSH FREF 0 PUSH LREF 0 PUSH GREF collect-free TAPPLY 3) PUSH GREF apply TAPPLY 2) FRAME (CONST :INVOKE PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 3 PUSH LREF 4 PUSH CLOSE 4 2 (FRAME (LREF 0 PUSH GREF scope-frees APPLY 1) PUSH FRAME (LREF 0 PUSH GREF scope-local APPLY 1) PUSH FRAME (FREF 0 PUSH GREF tail? APPLY 1) PUSH EXPND 3 LREF 4 TEST (FRAME (LREF 4 PUSH GREF length APPLY 1) PUSH EXPND 1 FRAME (FRAME (LREF 1 TEST (FREF 0 . #4=(PUSH LREF 4 PUSH LREF 7 PUSH LREF 5 PUSH GREF compile-body APPLY 4)) FRAME (FREF 0 PUSH LREF 0 PUSH CONST SHRNK PUSH GREF list* APPLY 3) . #4#) PUSH LREF 0 PUSH CONST EXPND PUSH GREF list* APPLY 3) SHRNK 1 . #5=(PUSH FREF 1 PUSH LREF 5 PUSH GREF compile-args TAPPLY 3)) FRAME (FREF 0 PUSH LREF 3 PUSH LREF 6 PUSH CONST nil PUSH GREF compile-body APPLY 4) . #5#) PUSH GREF apply TAPPLY 2) FRAME (CONST :MACRO PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 4 PUSH LREF 3 PUSH CLOSE 4 2 (FRAME (LREF 0 PUSH GREF scope-frees APPLY 1) PUSH FRAME (LREF 0 PUSH GREF scope-local APPLY 1) PUSH EXPND 2 FRAME (FREF 1 PUSH FRAME (FRAME (CONST RET PUSH GREF list APPLY 1) PUSH LREF 2 PUSH LREF 5 PUSH FRAME (LREF 2 PUSH GREF scope-local APPLY 1) PUSH GREF compile-body APPLY 4) PUSH FRAME (LREF 1 PUSH GREF length APPLY 1) PUSH LREF 4 PUSH LREF 3 PUSH CONST MACRO PUSH GREF list* APPLY 6) PUSH FREF 0 PUSH LREF 1 PUSH GREF collect-free TAPPLY 3) PUSH GREF apply TAPPLY 2) FRAME (CONST :APPLY PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 4 PUSH LREF 3 PUSH CLOSE 3 2 (FREF 1 PUSH FREF 0 PUSH LREF 0 PUSH LREF 2 PUSH LREF 1 PUSH GREF compile-apply TAPPLY 5) PUSH GREF apply TAPPLY 2) FRAME (CONST :CONTI PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 3 PUSH LREF 4 PUSH CLOSE 1 2 (FRAME (FREF 0 PUSH GREF tail? APPLY 1) PUSH EXPND 1 FRAME (FRAME (LREF 0 TEST (CONST (TAPPLY 1) . #6=(PUSH FREF 1 PUSH LREF 1 PUSH GREF compile-recur APPLY 3)) CONST (APPLY 1) . #6#) PUSH CONST PUSH PUSH LREF 0 PUSH CONST CONTI PUSH GREF list* APPLY 4) PUSH EXPND 1 LREF 1 TEST (LREF 0 RET) FREF 0 PUSH LREF 0 PUSH CONST FRAME PUSH GREF list* TAPPLY 3) PUSH GREF apply TAPPLY 2) FRAME (CONST :VALS PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 4 PUSH LREF 3 PUSH CLOSE 1 2 (FRAME (LREF 0 PUSH GREF length APPLY 1) PUSH EXPND 1 FRAME (CONST 0 PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FREF 1 PUSH CONST VOID PUSH GREF list* TAPPLY 2) FRAME (FREF 1 PUSH LREF 0 PUSH CONST VALS PUSH GREF list* APPLY 3) PUSH FREF 0 PUSH LREF 1 PUSH GREF compile-args TAPPLY 3) PUSH GREF apply TAPPLY 2) FRAME (CONST :RECV PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 3 PUSH LREF 4 PUSH CLOSE 5 2 (FRAME (LREF 0 PUSH GREF scope-frees APPLY 1) PUSH FRAME (FREF 0 PUSH GREF tail? APPLY 1) PUSH EXPND 2 FRAME (FRAME (LREF 0 TEST (FREF 0 . #8=(PUSH LREF 2 PUSH LREF 6 PUSH FRAME (LREF 2 PUSH GREF scope-local APPLY 1) PUSH GREF compile-body APPLY 4)) FRAME (FREF 0 PUSH FRAME (LREF 4 PUSH GREF pair? APPLY 1) TEST (FRAME (CONST 1 PUSH FRAME (LREF 4 PUSH GREF car APPLY 1) PUSH GREF + APPLY 2) . #7=(PUSH CONST SHRNK PUSH GREF list* APPLY 3)) LREF 4 . #7#) . #8#) PUSH LREF 4 PUSH CONST RECV PUSH GREF list* APPLY 3) PUSH FREF 1 PUSH LREF 5 PUSH GREF compile-recur TAPPLY 3) PUSH GREF apply TAPPLY 2) LREF 2 PUSH CONST "Unknown [%@]" PUSH GREF error TAPPLY 2) DEF compile-recur HALT)
(CLOSE 5 0 (FRAME (LREF 3 PUSH LREF 0 PUSH GREF apply-func-can-be-loop? APPLY 2) PUSH FRAME (LREF 1 PUSH GREF length APPLY 1) PUSH EXPND 2 LREF 1 TEST (FRAME (LREF 5 PUSH FRAME (FRAME (LREF 1 PUSH GREF lambda-scope-get APPLY 1) PUSH GREF scope-outer-scope APPLY 1) PUSH GREF eq? APPLY 2) . #8=(TEST (FRAME (LREF 6 PUSH GREF tail? APPLY 1) PUSH FRAME (LREF 1 PUSH GREF lambda-body-slot-get APPLY 1) PUSH FRAME (LREF 1 PUSH GREF lambda-scope-get APPLY 1) PUSH EXPND 3 FRAME (LREF 8 PUSH FRAME (LREF 0 PUSH GREF scope-local APPLY 1) PUSH GREF expand-scope APPLY 2) PUSH EXPND 1 FRAME (FRAME (LREF 3 TEST (FRAME (FRAME (LREF 2 PUSH LREF 4 PUSH CONST DIRECTCALL PUSH GREF list* APPLY 3) PUSH LREF 4 PUSH CONST SHIFT PUSH GREF list* APPLY 3) . #0=(PUSH LREF 9 PUSH LREF 6 PUSH GREF compile-recur APPLY 3)) FRAME (LREF 2 PUSH LREF 4 PUSH CONST DIRECTCALL PUSH GREF list* APPLY 3) . #0#) PUSH LREF 9 PUSH LREF 7 PUSH GREF compile-args APPLY 3) PUSH EXPND 1 LREF 4 TEST (LREF 0 . #4=(RET)) LREF 11 PUSH LREF 0 PUSH CONST FRAME PUSH GREF list* TAPPLY 3) LREF 1 TEST (FRAME (FRAME (LREF 5 PUSH GREF scope-id APPLY 1) PUSH FRAME (FRAME (LREF 1 PUSH GREF lambda-scope-get APPLY 1) PUSH GREF scope-id APPLY 1) PUSH GREF eq? APPLY 2) PUSH EXPND 1 LREF 0 TEST (LREF 0 . #6=(SHRNK 1 TEST (LREF 4 . #5=(TEST (FRAME (FRAME (FRAME (LREF 1 PUSH GREF lambda-scope-get APPLY 1) PUSH GREF get-expanded-scope-outer-local-count APPLY 1) PUSH GREF length APPLY 1) PUSH FRAME (LREF 1 PUSH GREF lambda-varnum-get APPLY 1) PUSH EXPND 2 FRAME (LREF 0 PUSH GREF pair? APPLY 1) TEST (FRAME (CONST "Not implemented: rest param for loop" PUSH GREF error APPLY 1) . #2=(FRAME (LREF 0 PUSH LREF 2 PUSH GREF eq? APPLY 2) TEST (VOID . #1=(FRAME (FRAME (LREF 3 PUSH GREF lambda-body-slot-get APPLY 1) PUSH LREF 1 PUSH LREF 2 PUSH CONST LOOP PUSH GREF list* APPLY 4) PUSH LREF 7 PUSH LREF 5 PUSH GREF compile-args TAPPLY 3)) FRAME (LREF 2 PUSH LREF 0 PUSH FRAME (LREF 4 PUSH GREF cadr APPLY 1) PUSH CONST "Illegal argnum, `%@` requires %@, but %@" PUSH GREF compile-error APPLY 4) . #1#)) VOID . #2#) FRAME (LREF 6 PUSH GREF tail? APPLY 1) PUSH EXPND 1 FRAME (FRAME (LREF 0 TEST (FRAME (LREF 1 PUSH CONST TAPPLY PUSH GREF list APPLY 2) . #3=(PUSH LREF 6 PUSH LREF 3 PUSH GREF compile-recur APPLY 3)) FRAME (LREF 1 PUSH CONST APPLY PUSH GREF list APPLY 2) . #3#) PUSH LREF 6 PUSH LREF 4 PUSH GREF compile-args APPLY 3) PUSH EXPND 1 LREF 1 TEST (LREF 0 . #4#) LREF 8 PUSH LREF 0 PUSH CONST FRAME PUSH GREF list* TAPPLY 3)) CONST nil . #5#)) FRAME (FRAME (LREF 6 PUSH GREF scope-id APPLY 1) PUSH FRAME (FRAME (FRAME (LREF 2 PUSH GREF lambda-scope-get APPLY 1) PUSH GREF scope-outer-scope APPLY 1) PUSH GREF scope-id APPLY 1) PUSH GREF eq? APPLY 2) PUSH EXPND 1 LREF 0 TEST (LREF 0 . #7=(SHRNK 1 . #6#)) GREF nil . #7#) CONST nil . #5#)) CONST nil . #8#) DEF compile-apply HALT)
(CLOSE 4 0 (GREF nil TEST (FRAME (LREF 1 PUSH GREF lambda-node? APPLY 1) TEST (FRAME (LREF 0 PUSH LREF 2 PUSH GREF var-is-set? APPLY 2) PUSH EXPND 1 LREF 0 TEST (FRAME (LREF 0 PUSH GREF single? APPLY 1) TEST (FRAME (LREF 0 PUSH GREF car APPLY 1) . #2=(SHRNK 1 . #3=(TEST (LREF 1 PUSH EXPND 1 FRAME (LREF 0 PUSH GREF lambda-body-slot-get APPLY 1) PUSH EXPND 1 FRAME (LREF 1 PUSH GREF lambda-scope-get APPLY 1) PUSH EXPND 1 FRAME (LREF 5 PUSH FRAME (LREF 0 PUSH GREF scope-local APPLY 1) PUSH GREF expand-scope APPLY 2) PUSH EXPND 1 FRAME (LREF 0 PUSH LREF 3 PUSH GREF lambda-scope-set! APPLY 2) FRAME (FRAME (FRAME (CONST RET PUSH GREF list APPLY 1) PUSH LREF 0 PUSH FRAME (LREF 3 PUSH GREF lambda-body-node-get APPLY 1) PUSH FRAME (LREF 1 PUSH GREF scope-local APPLY 1) PUSH GREF compile-body APPLY 4) PUSH LREF 2 PUSH GREF copy-pair! APPLY 2) LREF 7 PUSH LREF 2 PUSH CONST CONST PUSH GREF list* TAPPLY 3) FRAME (LREF 0 PUSH LREF 2 PUSH GREF scope-local-has? APPLY 2) PUSH EXPND 1 LREF 0 TEST (LREF 0 PUSH EXPND 1 LREF 0 PUSH CONST LSET PUSH VALS 2 SHRNK 1 . #0=(SHRNK 1 RECV 2 FRAME (LREF 5 PUSH LREF 1 PUSH LREF 0 PUSH GREF list* APPLY 3) PUSH LREF 4 PUSH LREF 3 PUSH GREF compile-recur TAPPLY 3)) FRAME (FRAME (LREF 3 PUSH GREF scope-frees APPLY 1) PUSH LREF 1 PUSH GREF position APPLY 2) PUSH EXPND 1 LREF 0 TEST (LREF 0 PUSH EXPND 1 LREF 0 PUSH CONST FSET PUSH VALS 2 SHRNK 1 . #1=(SHRNK 1 . #0#)) LREF 2 PUSH CONST GSET PUSH VALS 2 . #1#))) CONST nil . #2#) CONST nil . #2#) CONST nil . #3#) CONST nil . #3#) DEF compile-set! HALT)
(CLOSE 4 0 (LREF 1 TEST (GREF nil PUSH EXPND 1 BOX 0 LREF 0 PUSH LREF 3 PUSH LREF 4 PUSH CLOSE 1 3 #0=(LREF 0 TEST (FRAME (FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH FREF 2 UNBOX APPLY 1) PUSH FREF 1 PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF compile-recur TAPPLY 3) FREF 0 RET) LSET 0 FRAME (LREF 2 PUSH LREF 0 UNBOX DIRECTCALL 1 . #0#) SHRNK 1 PUSH LREF 0 PUSH LREF 2 PUSH GREF make-boxes TAPPLY 3) LREF 3 PUSH CONST VOID PUSH GREF list* TAPPLY 2) DEF compile-body HALT)
(CLOSE 3 0 (GREF nil PUSH EXPND 1 BOX 0 LREF 1 PUSH LREF 0 PUSH LREF 3 PUSH CLOSE 2 3 #0=(LREF 0 TEST (FRAME (FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH FREF 2 PUSH GREF var-is-set? APPLY 2) TEST (FRAME (FRAME (CONST 1 PUSH LREF 1 PUSH GREF + APPLY 2) PUSH FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH FREF 1 UNBOX APPLY 2) PUSH LREF 1 PUSH CONST BOX PUSH GREF list* TAPPLY 3) FRAME (CONST 1 PUSH LREF 1 PUSH GREF + APPLY 2) PUSH FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH LOOP 2 0 . #0#) FREF 0 RET) LSET 0 CONST 0 PUSH LREF 2 PUSH LREF 0 UNBOX SHIFT 2 DIRECTCALL 2 . #0#) DEF make-boxes HALT)
(CLOSE 3 0 (LREF 0 TEST (FRAME (FRAME (LREF 2 PUSH CONST PUSH PUSH GREF list* APPLY 2) PUSH LREF 1 PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF compile-recur APPLY 3) PUSH LREF 1 PUSH FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF compile-args TAPPLY 3) LREF 2 RET) DEF compile-args HALT)
(CLOSE 3 0 (LREF 0 TEST (FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH EXPND 1 FRAME (LREF 0 PUSH LREF 2 PUSH GREF scope-local-has? APPLY 2) PUSH EXPND 1 LREF 0 TEST (FRAME (LREF 4 PUSH CONST PUSH PUSH LREF 0 PUSH CONST LREF PUSH GREF list* APPLY 4) . #0=(SHRNK 1 SHRNK 1 PUSH LREF 1 PUSH FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF collect-free TAPPLY 3)) FRAME (FRAME (LREF 3 PUSH GREF scope-frees APPLY 1) PUSH LREF 1 PUSH GREF position APPLY 2) PUSH EXPND 1 LREF 0 TEST (FRAME (LREF 5 PUSH CONST PUSH PUSH LREF 0 PUSH CONST FREF PUSH GREF list* APPLY 4) . #1=(SHRNK 1 . #0#)) FRAME (LREF 4 PUSH LREF 2 PUSH CONST "something wrong in collect-free [%@](%@)" PUSH GREF error APPLY 3) . #1#) LREF 2 RET) DEF collect-free HALT)
(CLOSE 2 0 (FRAME (CONST :REF PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 0 PUSH GREF cadr APPLY 1) PUSH EXPND 1 FRAME (LREF 0 PUSH LREF 2 PUSH GREF var-is-set? APPLY 2) PUSH EXPND 1 LREF 0 TEST (FRAME (LREF 0 PUSH GREF single? APPLY 1) TEST (FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH EXPND 1 FRAME (LREF 0 PUSH GREF lambda-node? APPLY 1) TEST (LREF 0 . #0=(RET)) CONST nil . #0#) CONST nil . #0#) VOID . #0#) CONST nil . #0#) DEF apply-func-can-be-loop? HALT)
(CLOSE 1 0 (CONST RET PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF eq? TAPPLY 2) DEF tail? HALT)
(MACRO declaim (0 -1) 0 (FRAME (CONST nil PUSH FRAME (LREF 0 PUSH CLOSE 1 0 (FRAME (LREF 0 PUSH GREF pair? APPLY 1) TEST (FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH EXPND 1 FRAME (CONST inline PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (GREF nil PUSH EXPND 1 BOX 0 LREF 0 PUSH CLOSE 1 1 #0=(FRAME (LREF 0 PUSH GREF pair? APPLY 1) TEST (FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH EXPND 1 FRAME (LREF 0 PUSH GREF declaim-inline APPLY 1) FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LOOP 1 0 . #0#) VOID RET) LSET 0 FRAME (FRAME (LREF 2 PUSH GREF cdr APPLY 1) PUSH LREF 0 UNBOX DIRECTCALL 1 . #0#) SHRNK 1 CONST (values) . #1=(RET)) GREF nil . #1#) VOID . #1#) PUSH GREF map APPLY 2) PUSH GREF append APPLY 2) PUSH CONST (do) PUSH GREF append TAPPLY 2) HALT)
(FRAME (GREF table APPLY 0) PUSH EXPND 1 LREF 0 PUSH CLOSE 1 1 (GREF t PUSH LREF 0 PUSH FREF 0 PUSH GREF table-put! TAPPLY 3) DEF declaim-inline LREF 0 PUSH CLOSE 1 1 (FRAME (LREF 0 PUSH GREF symbol? APPLY 1) TEST (LREF 0 PUSH FREF 0 PUSH GREF table-exists? TAPPLY 2) CONST nil RET) DEF inline-function? LREF 0 PUSH CLOSE 2 1 (LREF 1 PUSH LREF 0 PUSH FREF 0 PUSH GREF table-put! TAPPLY 3) DEF register-inline-function LREF 0 PUSH CLOSE 1 1 (LREF 0 PUSH FREF 0 PUSH GREF table-get TAPPLY 2) DEF get-inline-function-body SHRNK 1 HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF pair? APPLY 1) TEST (CONST ^ PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF eq? TAPPLY 2) CONST nil RET) DEF lambda-expression? HALT)
(GREF nil PUSH EXPND 1 BOX 0 LREF 0 PUSH CLOSE (0 -1) 1 (FRAME (LREF 0 PUSH GREF *stderr* PUSH GREF format PUSH GREF apply APPLY 3) FRAME (GREF *stderr* PUSH CONST "\n" PUSH GREF display APPLY 2) GREF nil PUSH FREF 0 UNBOX TAPPLY 1) DEF compile-error LREF 0 PUSH CLOSE 1 1 (CONTI t PUSH LREF 0 PUSH FREF 0 PUSH CLOSE 1 2 (LREF 0 FSET 0 FRAME (GREF nil PUSH CONST nil PUSH GREF create-scope APPLY 2) PUSH EXPND 1 FRAME (GREF nil PUSH LREF 0 PUSH FREF 1 PUSH GREF traverse APPLY 3) PUSH EXPND 1 FRAME (CONST HALT PUSH GREF list APPLY 1) PUSH LREF 1 PUSH LREF 0 PUSH GREF compile-recur TAPPLY 3) TAPPLY 1) DEF compile SHRNK 1 HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF compile APPLY 1) PUSH GREF run-binary TAPPLY 1) DEF eval HALT)
(CLOSE (0 -1) 0 (FRAME (GREF *stderr* PUSH LREF 0 PUSH GREF write/ss APPLY 2) FRAME (GREF *stderr* PUSH CONST "\n" PUSH GREF display APPLY 2) LREF 0 RET) DEF debug/ss HALT)
