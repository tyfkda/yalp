(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF cadr TAPPLY 1) DEF cadar HALT)
(CLOSE 2 0 (LREF 1 TEST (FRAME (FRAME (LREF 1 PUSH GREF car APPLY 1) PUSH LREF 0 APPLY 1) TEST (FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 0 PUSH GREF all? TAPPLY 2) GREF nil . #0=(RET)) GREF t . #0#) DEF all? HALT)
(CLOSE 2 0 (ADDSP 1 FRAME (LREF 0 PUSH GREF reverse! APPLY 1) LOCAL -2 FRAME (LREF 1 PUSH LREF 0 PUSH GREF set-cdr! APPLY 2) LREF -2 RET) DEF nreconc HALT)
(FRAME (GREF gensym APPLY 0) DEF *bq-clobberable* HALT)
(FRAME (GREF nil PUSH CONST quote PUSH GREF list APPLY 2) DEF *bq-quote-nil* HALT)
(FRAME (CLOSE 2 0 (FRAME (LREF 0 PUSH GREF read APPLY 1) PUSH CONST quasiquote PUSH GREF list TAPPLY 2) PUSH CONST 96 PUSH GREF set-macro-character APPLY 2) HALT)
(FRAME (CLOSE 2 0 (ADDSP 2 FRAME (LREF 0 PUSH GREF read-char APPLY 1) LOCAL -2 LREF -2 LOCAL -3 FRAME (CONST 64 PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 0 PUSH GREF read APPLY 1) PUSH CONST unquote-splicing PUSH GREF list TAPPLY 2) FRAME (CONST 46 PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 0 PUSH GREF read APPLY 1) PUSH CONST unquote-dot PUSH GREF list TAPPLY 2) FRAME (LREF 0 PUSH LREF -2 PUSH GREF unread-char APPLY 2) FRAME (LREF 0 PUSH GREF read APPLY 1) PUSH CONST unquote PUSH GREF list TAPPLY 2) PUSH CONST 44 PUSH GREF set-macro-character APPLY 2) HALT)
(MACRO quasiquote 1 0 (LREF 0 PUSH GREF bq-completely-process TAPPLY 1) HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF bq-process APPLY 1) PUSH GREF bq-simplify TAPPLY 1) DEF bq-completely-process HALT)
(CLOSE 1 0 (ADDSP 3 FRAME (FRAME (LREF 0 PUSH GREF pair? APPLY 1) PUSH GREF not APPLY 1) TEST (LREF 0 PUSH CONST quote PUSH GREF list TAPPLY 2) FRAME (CONST quasiquote PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF eq? APPLY 2) TEST (FRAME (FRAME (LREF 0 PUSH GREF cadr APPLY 1) PUSH GREF bq-completely-process APPLY 1) PUSH GREF bq-process TAPPLY 1) FRAME (CONST unquote PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF eq? APPLY 2) TEST (LREF 0 PUSH GREF cadr TAPPLY 1) FRAME (CONST unquote-splicing PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 0 PUSH GREF cadr APPLY 1) PUSH CONST ",@~S after `" PUSH GREF error TAPPLY 2) FRAME (CONST unquote-dot PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 0 PUSH GREF cadr APPLY 1) PUSH CONST ",.~S after `" PUSH GREF error TAPPLY 2) GREF nil LOCAL -2 CONST nil LOCAL -4 LREF 0 LOCAL -3 . #1=(FRAME (FRAME (LREF -3 PUSH GREF pair? APPLY 1) PUSH GREF not APPLY 1) TEST (FRAME (FRAME (FRAME (LREF -3 PUSH CONST quote PUSH GREF list APPLY 2) PUSH GREF list APPLY 1) PUSH LREF -4 PUSH GREF nreconc APPLY 2) PUSH CONST append PUSH GREF cons TAPPLY 2) FRAME (CONST unquote PUSH FRAME (LREF -3 PUSH GREF car APPLY 1) PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -3 PUSH GREF cddr APPLY 1) TEST (FRAME (LREF -3 PUSH CONST "Malformed ,~S" PUSH GREF error APPLY 2) . #0=(FRAME (FRAME (FRAME (LREF -3 PUSH GREF cadr APPLY 1) PUSH GREF list APPLY 1) PUSH LREF -4 PUSH GREF nreconc APPLY 2) PUSH CONST append PUSH GREF cons TAPPLY 2)) VOID . #0#) FRAME (CONST unquote-splicing PUSH FRAME (LREF -3 PUSH GREF car APPLY 1) PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -3 PUSH CONST "Dotted ,@~S" PUSH GREF error APPLY 2) . #3=(FRAME (CONST unquote-dot PUSH FRAME (LREF -3 PUSH GREF car APPLY 1) PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -3 PUSH CONST "Dotted ,.~S" PUSH GREF error APPLY 2) . #2=(FRAME (LREF -4 PUSH FRAME (FRAME (LREF -3 PUSH GREF car APPLY 1) PUSH GREF bracket APPLY 1) PUSH GREF cons APPLY 2) PUSH FRAME (LREF -3 PUSH GREF cdr APPLY 1) PUSH LOOP 1 2 . #1#)) VOID . #2#)) VOID . #3#)) DEF bq-process HALT)
(CLOSE 1 0 (FRAME (FRAME (LREF 0 PUSH GREF pair? APPLY 1) PUSH GREF not APPLY 1) TEST (FRAME (LREF 0 PUSH GREF bq-process APPLY 1) PUSH CONST list PUSH GREF list TAPPLY 2) FRAME (CONST unquote PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 0 PUSH GREF cadr APPLY 1) PUSH CONST list PUSH GREF list TAPPLY 2) FRAME (CONST unquote-splicing PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF eq? APPLY 2) TEST (LREF 0 PUSH GREF cadr TAPPLY 1) FRAME (CONST unquote-dot PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 0 PUSH GREF cadr APPLY 1) PUSH GREF *bq-clobberable* PUSH GREF list TAPPLY 2) FRAME (LREF 0 PUSH GREF bq-process APPLY 1) PUSH CONST list PUSH GREF list TAPPLY 2) DEF bracket HALT)
(CLOSE 2 0 (ADDSP 2 FRAME (FRAME (LREF 1 PUSH GREF pair? APPLY 1) PUSH GREF not APPLY 1) TEST (LREF 1 PUSH LREF 0 TAPPLY 1) FRAME (FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 0 PUSH GREF maptree APPLY 2) LOCAL -3 FRAME (FRAME (LREF 1 PUSH GREF car APPLY 1) PUSH LREF 0 APPLY 1) LOCAL -2 FRAME (FRAME (LREF 1 PUSH GREF car APPLY 1) PUSH LREF -2 PUSH GREF equal? APPLY 2) TEST (FRAME (FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF -3 PUSH GREF equal? APPLY 2) . #0=(TEST (LREF 1 RET) LREF -3 PUSH LREF -2 PUSH GREF cons TAPPLY 2)) CONST nil . #0#) DEF maptree HALT)
(CLOSE 1 0 (ADDSP 2 FRAME (LREF 0 PUSH GREF pair? APPLY 1) TEST (FRAME (CONST unquote-splicing PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF eq? APPLY 2) LOCAL -2 LREF -2 TEST (LREF -2 . #0=(RET)) FRAME (CONST unquote-dot PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF eq? APPLY 2) LOCAL -3 LREF -3 TEST (LREF -3 . #0#) GREF nil . #0#) CONST nil . #0#) DEF bq-splicing-frob HALT)
(CLOSE 1 0 (ADDSP 3 FRAME (LREF 0 PUSH GREF pair? APPLY 1) TEST (FRAME (CONST unquote PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF eq? APPLY 2) LOCAL -2 LREF -2 TEST (LREF -2 . #0=(RET)) FRAME (CONST unquote-splicing PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF eq? APPLY 2) LOCAL -3 LREF -3 TEST (LREF -3 . #0#) FRAME (CONST unquote-dot PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF eq? APPLY 2) LOCAL -4 LREF -4 TEST (LREF -4 . #0#) GREF nil . #0#) CONST nil . #0#) DEF bq-frob HALT)
(CLOSE 1 0 (ADDSP 1 FRAME (LREF 0 PUSH GREF pair? APPLY 1) TEST (FRAME (CONST quote PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF eq? APPLY 2) TEST (LREF 0 . #0=(LOCAL -2 FRAME (FRAME (CONST append PUSH FRAME (LREF -2 PUSH GREF car APPLY 1) PUSH GREF eq? APPLY 2) PUSH GREF not APPLY 1) TEST (LREF -2 . #1=(RET)) LREF -2 PUSH GREF bq-simplify-args TAPPLY 1)) FRAME (LREF 0 PUSH GREF bq-simplify PUSH GREF maptree APPLY 2) . #0#) LREF 0 . #1#) DEF bq-simplify HALT)
(CLOSE 1 0 (ADDSP 3 GREF nil LOCAL -2 GREF nil LOCAL -4 FRAME (FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF reverse APPLY 1) LOCAL -3 . #0=(LREF -3 TEST (FRAME (FRAME (FRAME (LREF -3 PUSH GREF car APPLY 1) PUSH GREF pair? APPLY 1) PUSH GREF not APPLY 1) TEST (FRAME (LREF -4 PUSH FRAME (LREF -3 PUSH GREF car APPLY 1) PUSH CONST append PUSH GREF bq-attach-append APPLY 3) . #1=(PUSH FRAME (LREF -3 PUSH GREF cdr APPLY 1) PUSH LOOP 1 2 . #0#)) FRAME (CONST list PUSH FRAME (LREF -3 PUSH GREF caar APPLY 1) PUSH GREF eq? APPLY 2) TEST (FRAME (FRAME (FRAME (LREF -3 PUSH GREF cdar APPLY 1) PUSH GREF bq-splicing-frob PUSH GREF any? APPLY 2) PUSH GREF not APPLY 1) . #4=(TEST (FRAME (LREF -4 PUSH FRAME (LREF -3 PUSH GREF cdar APPLY 1) PUSH GREF bq-attach-conses APPLY 2) . #1#) FRAME (CONST list* PUSH FRAME (LREF -3 PUSH GREF caar APPLY 1) PUSH GREF eq? APPLY 2) TEST (FRAME (FRAME (FRAME (LREF -3 PUSH GREF cdar APPLY 1) PUSH GREF bq-splicing-frob PUSH GREF any? APPLY 2) PUSH GREF not APPLY 1) . #3=(TEST (FRAME (FRAME (LREF -4 PUSH FRAME (FRAME (FRAME (LREF -3 PUSH GREF car APPLY 1) PUSH GREF last APPLY 1) PUSH GREF car APPLY 1) PUSH CONST append PUSH GREF bq-attach-append APPLY 3) PUSH FRAME (FRAME (FRAME (FRAME (LREF -3 PUSH GREF cdar APPLY 1) PUSH GREF reverse APPLY 1) PUSH GREF cdr APPLY 1) PUSH GREF reverse APPLY 1) PUSH GREF bq-attach-conses APPLY 2) . #1#) FRAME (CONST quote PUSH FRAME (LREF -3 PUSH GREF caar APPLY 1) PUSH GREF eq? APPLY 2) TEST (FRAME (FRAME (LREF -3 PUSH GREF cadar APPLY 1) PUSH GREF pair? APPLY 1) TEST (FRAME (FRAME (FRAME (LREF -3 PUSH GREF cadar APPLY 1) PUSH GREF bq-frob APPLY 1) PUSH GREF not APPLY 1) TEST (FRAME (FRAME (LREF -3 PUSH GREF cddar APPLY 1) PUSH GREF not APPLY 1) . #2=(TEST (FRAME (LREF -4 PUSH FRAME (FRAME (FRAME (LREF -3 PUSH GREF caadar APPLY 1) PUSH CONST quote PUSH GREF list APPLY 2) PUSH GREF list APPLY 1) PUSH GREF bq-attach-conses APPLY 2) . #1#) FRAME (GREF *bq-clobberable* PUSH FRAME (LREF -3 PUSH GREF caar APPLY 1) PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -4 PUSH FRAME (LREF -3 PUSH GREF cadar APPLY 1) PUSH CONST append! PUSH GREF bq-attach-append APPLY 3) . #1#) FRAME (LREF -4 PUSH FRAME (LREF -3 PUSH GREF car APPLY 1) PUSH CONST append PUSH GREF bq-attach-append APPLY 3) . #1#)) CONST nil . #2#) CONST nil . #2#) CONST nil . #2#)) CONST nil . #3#)) CONST nil . #4#) LREF -4 RET)) DEF bq-simplify-args HALT)
(CLOSE 1 0 (ADDSP 2 FRAME (LREF 0 PUSH GREF not APPLY 1) LOCAL -2 LREF -2 TEST (LREF -2 . #0=(RET)) FRAME (LREF 0 PUSH GREF pair? APPLY 1) TEST (FRAME (CONST quote PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF eq? APPLY 2) . #1=(LOCAL -3 LREF -3 TEST (LREF -3 . #0#) GREF nil . #0#)) CONST nil . #1#) DEF null-or-quoted HALT)
(CLOSE 3 0 (ADDSP 2 FRAME (LREF 1 PUSH GREF null-or-quoted APPLY 1) TEST (FRAME (LREF 2 PUSH GREF null-or-quoted APPLY 1) . #2=(TEST (FRAME (FRAME (LREF 2 PUSH GREF cadr APPLY 1) PUSH FRAME (LREF 1 PUSH GREF cadr APPLY 1) PUSH GREF append APPLY 2) PUSH CONST quote PUSH GREF list TAPPLY 2) FRAME (LREF 2 PUSH GREF not APPLY 1) LOCAL -2 LREF -2 TEST (LREF -2 . #1=(TEST (FRAME (LREF 1 PUSH GREF bq-splicing-frob APPLY 1) TEST (LREF 1 PUSH LREF 0 PUSH GREF list TAPPLY 2) LREF 1 RET) FRAME (LREF 2 PUSH GREF pair? APPLY 1) TEST (FRAME (LREF 0 PUSH FRAME (LREF 2 PUSH GREF car APPLY 1) PUSH GREF eq? APPLY 2) . #0=(TEST (FRAME (LREF 2 PUSH GREF cdr APPLY 1) PUSH LREF 1 PUSH FRAME (LREF 2 PUSH GREF car APPLY 1) PUSH GREF list* TAPPLY 3) LREF 2 PUSH LREF 1 PUSH LREF 0 PUSH GREF list TAPPLY 3)) CONST nil . #0#)) FRAME (GREF *bq-quote-nil* PUSH LREF 2 PUSH GREF equal? APPLY 2) LOCAL -3 LREF -3 TEST (LREF -3 . #1#) GREF nil . #1#)) CONST nil . #2#) DEF bq-attach-append HALT)
(CLOSE 2 0 (ADDSP 2 FRAME (LREF 0 PUSH GREF null-or-quoted PUSH GREF all? APPLY 2) TEST (FRAME (LREF 1 PUSH GREF null-or-quoted APPLY 1) . #2=(TEST (FRAME (FRAME (LREF 1 PUSH GREF cadr APPLY 1) PUSH FRAME (LREF 0 PUSH GREF cadr PUSH GREF map APPLY 2) PUSH GREF append APPLY 2) PUSH CONST quote PUSH GREF list TAPPLY 2) FRAME (LREF 1 PUSH GREF not APPLY 1) LOCAL -2 LREF -2 TEST (LREF -2 . #1=(TEST (LREF 0 PUSH CONST list PUSH GREF cons TAPPLY 2) FRAME (LREF 1 PUSH GREF pair? APPLY 1) TEST (FRAME (CONST list PUSH FRAME (LREF 1 PUSH GREF car APPLY 1) PUSH GREF eq? APPLY 2) LOCAL -2 LREF -2 TEST (LREF -2 . #0=(TEST (FRAME (FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 0 PUSH GREF append APPLY 2) PUSH FRAME (LREF 1 PUSH GREF car APPLY 1) PUSH GREF cons TAPPLY 2) FRAME (FRAME (LREF 1 PUSH GREF list APPLY 1) PUSH LREF 0 PUSH GREF append APPLY 2) PUSH CONST list* PUSH GREF cons TAPPLY 2)) FRAME (CONST list* PUSH FRAME (LREF 1 PUSH GREF car APPLY 1) PUSH GREF eq? APPLY 2) LOCAL -3 LREF -3 TEST (LREF -3 . #0#) GREF nil . #0#) CONST nil . #0#)) FRAME (GREF *bq-quote-nil* PUSH LREF 1 PUSH GREF equal? APPLY 2) LOCAL -3 LREF -3 TEST (LREF -3 . #1#) GREF nil . #1#)) CONST nil . #2#) DEF bq-attach-conses HALT)
(FRAME (CLOSE 2 0 (ADDSP 1 GREF nil LOCAL -2 . #0=(FRAME (CONST (10 -1) PUSH FRAME (LREF 0 PUSH GREF read-char APPLY 1) PUSH GREF member APPLY 2) TEST (VOID VOID RET) LOOP 1 0 . #0#)) PUSH CONST 59 PUSH GREF set-macro-character APPLY 2) HALT)
(FRAME (CLOSE 2 0 (FRAME (LREF 0 PUSH GREF read APPLY 1) PUSH CONST quote PUSH GREF list TAPPLY 2) PUSH CONST 39 PUSH GREF set-macro-character APPLY 2) HALT)
(FRAME (CLOSE 2 0 (FRAME (LREF 0 PUSH CONST 93 PUSH GREF read-delimited-list APPLY 2) PUSH CONST (_) PUSH CONST ^ PUSH GREF list TAPPLY 3) PUSH CONST 91 PUSH GREF set-macro-character APPLY 2) HALT)
(MACRO defun (2 -1) 0 (FRAME (LREF 2 PUSH LREF 1 PUSH CONST ^ PUSH GREF list* APPLY 3) PUSH LREF 0 PUSH CONST def PUSH GREF list TAPPLY 3) HALT)
(CLOSE 1 0 (LREF 0 TEST (GREF nil . #0=(RET)) GREF t . #0#) DEF not HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF car TAPPLY 1) DEF caar HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF cdr TAPPLY 1) DEF cdar HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF car TAPPLY 1) DEF cadr HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF cdr TAPPLY 1) DEF cddr HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF cddr APPLY 1) PUSH GREF car TAPPLY 1) DEF caddr HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF cddr APPLY 1) PUSH GREF cdr TAPPLY 1) DEF cdddr HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF cdddr APPLY 1) PUSH GREF car TAPPLY 1) DEF cadddr HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF cdddr APPLY 1) PUSH GREF cdr TAPPLY 1) DEF cddddr HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF cddddr APPLY 1) PUSH GREF car TAPPLY 1) DEF caddddr HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF cddddr APPLY 1) PUSH GREF cdr TAPPLY 1) DEF cdddddr HALT)
(CLOSE 1 0 (CONST int PUSH FRAME (LREF 0 PUSH GREF type APPLY 1) PUSH GREF eq? TAPPLY 2) DEF int? HALT)
(CLOSE 1 0 (CONST pair PUSH FRAME (LREF 0 PUSH GREF type APPLY 1) PUSH GREF eq? TAPPLY 2) DEF pair? HALT)
(CLOSE 1 0 (CONST symbol PUSH FRAME (LREF 0 PUSH GREF type APPLY 1) PUSH GREF eq? TAPPLY 2) DEF symbol? HALT)
(CLOSE 1 0 (CONST string PUSH FRAME (LREF 0 PUSH GREF type APPLY 1) PUSH GREF eq? TAPPLY 2) DEF string? HALT)
(CLOSE 1 0 (CONST flonum PUSH FRAME (LREF 0 PUSH GREF type APPLY 1) PUSH GREF eq? TAPPLY 2) DEF flonum? HALT)
(CLOSE 2 0 (FRAME (LREF 1 PUSH GREF pair? APPLY 1) TEST (FRAME (FRAME (LREF 1 PUSH GREF car APPLY 1) PUSH LREF 0 APPLY 1) TEST (LREF 1 . #0=(RET)) FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 0 PUSH GREF any? TAPPLY 2) GREF nil . #0#) DEF any? HALT)
(CLOSE 3 0 (ADDSP 1 FRAME (LREF 1 PUSH GREF pair? APPLY 1) TEST (FRAME (LREF 2 PUSH FRAME (FRAME (LREF 1 PUSH GREF car APPLY 1) PUSH LREF 0 APPLY 1) PUSH GREF cons APPLY 2) PUSH FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 0 PUSH GREF map1-loop TAPPLY 3) FRAME (LREF 2 PUSH GREF reverse! APPLY 1) LOCAL -2 LREF 1 TEST (LREF 2 TEST (FRAME (FRAME (LREF 1 PUSH LREF 0 APPLY 1) PUSH LREF 2 PUSH GREF set-cdr! APPLY 2) LREF -2 . #0=(RET)) LREF 1 PUSH LREF 0 TAPPLY 1) LREF -2 . #0#) DEF map1-loop HALT)
(CLOSE 3 0 (FRAME (LREF 1 PUSH GREF not PUSH GREF any? APPLY 2) TEST (LREF 2 PUSH GREF reverse! TAPPLY 1) FRAME (LREF 2 PUSH FRAME (FRAME (CONST nil PUSH LREF 1 PUSH GREF car PUSH GREF map1-loop APPLY 3) PUSH LREF 0 PUSH GREF apply APPLY 2) PUSH GREF cons APPLY 2) PUSH FRAME (CONST nil PUSH LREF 1 PUSH GREF cdr PUSH GREF map1-loop APPLY 3) PUSH LREF 0 PUSH GREF mapn-loop TAPPLY 3) DEF mapn-loop HALT)
(CLOSE (2 -1) 0 (LREF 2 TEST (CONST nil PUSH FRAME (LREF 2 PUSH LREF 1 PUSH GREF cons APPLY 2) PUSH LREF 0 PUSH GREF mapn-loop TAPPLY 3) CONST nil PUSH LREF 1 PUSH LREF 0 PUSH GREF map1-loop TAPPLY 3) DEF map HALT)
(MACRO do (0 -1) 0 (FRAME (LREF 0 PUSH CONST nil PUSH CONST ^ PUSH GREF list* APPLY 3) PUSH GREF list TAPPLY 1) HALT)
(MACRO when (1 -1) 0 (FRAME (LREF 1 PUSH CONST do PUSH GREF list* APPLY 2) PUSH LREF 0 PUSH CONST if PUSH GREF list TAPPLY 3) HALT)
(MACRO unless (1 -1) 0 (FRAME (LREF 1 PUSH CONST do PUSH GREF list* APPLY 2) PUSH CONST (do) PUSH LREF 0 PUSH CONST if PUSH GREF list TAPPLY 4) HALT)
(MACRO set! (2 -1) 0 (LREF 2 TEST (FRAME (LREF 2 PUSH CONST set! PUSH GREF list* APPLY 2) PUSH FRAME (LREF 1 PUSH LREF 0 PUSH CONST set! PUSH GREF list APPLY 3) PUSH CONST do PUSH GREF list TAPPLY 3) LREF 1 PUSH LREF 0 PUSH CONST set! PUSH GREF list TAPPLY 3) HALT)
(MACRO and (0 -1) 0 (LREF 0 TEST (FRAME (LREF 0 PUSH GREF cdr APPLY 1) TEST (CONST ('nil) PUSH FRAME (FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH CONST and PUSH GREF list* APPLY 2) PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH CONST if PUSH GREF list* TAPPLY 4) LREF 0 PUSH GREF car TAPPLY 1) CONST t RET) HALT)
(MACRO let1 (2 -1) 0 (LREF 1 PUSH FRAME (LREF 2 PUSH FRAME (LREF 0 PUSH GREF list APPLY 1) PUSH CONST ^ PUSH GREF list* APPLY 3) PUSH GREF list TAPPLY 2) HALT)
(MACRO let (1 -1) 0 (ADDSP 3 FRAME (LREF 0 PUSH GREF symbol? APPLY 1) TEST (LREF 0 . #2=(TEST (FRAME (LREF 1 PUSH GREF cdr APPLY 1) LOCAL -4 FRAME (LREF 1 PUSH GREF car APPLY 1) LOCAL -3 LREF 0 LOCAL -2 FRAME (FRAME (LREF -3 PUSH GREF cadr PUSH GREF map APPLY 2) PUSH LREF -2 PUSH GREF list* APPLY 2) PUSH FRAME (FRAME (LREF -4 PUSH FRAME (LREF -3 PUSH GREF car PUSH GREF map APPLY 2) PUSH CONST ^ PUSH GREF list* APPLY 3) PUSH LREF -2 PUSH CONST set! PUSH GREF list APPLY 3) PUSH CONST nil PUSH LREF -2 PUSH CONST let1 PUSH GREF list TAPPLY 5) FRAME (LREF 0 PUSH CLOSE 1 0 (FRAME (LREF 0 PUSH GREF pair? APPLY 1) TEST (FRAME (FRAME (FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF single? APPLY 1) PUSH GREF not APPLY 1) . #1=(TEST (FRAME (LREF 0 PUSH CONST "malformed let: %@" PUSH GREF compile-error APPLY 2) . #0=(LREF 0 PUSH GREF cadr TAPPLY 1)) VOID . #0#)) CONST nil . #1#) PUSH GREF map APPLY 2) PUSH FRAME (LREF 1 PUSH FRAME (LREF 0 PUSH GREF car PUSH GREF map APPLY 2) PUSH CONST ^ PUSH GREF list* APPLY 3) PUSH GREF list* TAPPLY 2)) CONST nil . #2#) HALT)
(MACRO let* (1 -1) 0 (LREF 0 TEST (FRAME (FRAME (FRAME (LREF 1 PUSH FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH CONST let* PUSH GREF list* APPLY 3) PUSH GREF list APPLY 1) PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF append APPLY 2) PUSH CONST let1 PUSH GREF list* TAPPLY 2) LREF 1 PUSH CONST do PUSH GREF list* TAPPLY 2) HALT)
(MACRO alet (1 -1) 0 (LREF 1 PUSH LREF 0 PUSH CONST loop PUSH CONST let PUSH GREF list* TAPPLY 4) HALT)
(CLOSE 2 0 (ADDSP 4 LREF 0 TEST (FRAME (LREF 0 PUSH GREF cdr APPLY 1) LOCAL -3 FRAME (LREF 0 PUSH GREF car APPLY 1) LOCAL -2 FRAME (LREF -2 PUSH GREF cdr APPLY 1) LOCAL -5 FRAME (LREF -2 PUSH GREF car APPLY 1) LOCAL -4 FRAME (CONST t PUSH LREF -4 PUSH GREF eq? APPLY 2) TEST (LREF -3 TEST (CONST "else clause must comes at last in cond" PUSH GREF compile-error TAPPLY 1) LREF -5 PUSH CONST do PUSH GREF list* TAPPLY 2) LREF -3 PUSH LREF -5 PUSH LREF -4 PUSH LREF 1 TAPPLY 3) GREF nil RET) DEF cond-template HALT)
(MACRO cond (0 -1) 0 (CLOSE 3 0 (FRAME (LREF 2 PUSH CONST cond PUSH GREF list* APPLY 2) PUSH FRAME (LREF 1 PUSH CONST do PUSH GREF list* APPLY 2) PUSH LREF 0 PUSH CONST if PUSH GREF list TAPPLY 4) PUSH LREF 0 PUSH GREF cond-template TAPPLY 2) HALT)
(MACRO acond (0 -1) 0 (CLOSE 3 0 (ADDSP 1 FRAME (GREF gensym APPLY 0) LOCAL -2 FRAME (FRAME (LREF 2 PUSH CONST acond PUSH GREF list* APPLY 2) PUSH FRAME (LREF 1 PUSH LREF -2 PUSH CONST it PUSH CONST let1 PUSH GREF list* APPLY 4) PUSH LREF -2 PUSH CONST if PUSH GREF list APPLY 4) PUSH LREF 0 PUSH LREF -2 PUSH CONST let1 PUSH GREF list TAPPLY 4) PUSH LREF 0 PUSH GREF cond-template TAPPLY 2) HALT)
(MACRO aif (1 -1) 0 (FRAME (LREF 1 PUSH CONST it PUSH CONST if PUSH GREF list* APPLY 3) PUSH LREF 0 PUSH CONST it PUSH CONST let1 PUSH GREF list TAPPLY 4) HALT)
(MACRO awhen (1 -1) 0 (FRAME (LREF 1 PUSH CONST do PUSH GREF list* APPLY 2) PUSH LREF 0 PUSH CONST aif PUSH GREF list TAPPLY 3) HALT)
(MACRO let-gensym (1 -1) 0 (FRAME (LREF 0 PUSH GREF pair? APPLY 1) TEST (LREF 1 PUSH FRAME (LREF 0 PUSH CLOSE 1 0 (CONST (gensym) PUSH LREF 0 PUSH GREF list TAPPLY 2) PUSH GREF map APPLY 2) PUSH CONST let PUSH GREF list* TAPPLY 3) LREF 1 PUSH CONST (gensym) PUSH LREF 0 PUSH CONST let1 PUSH GREF list* TAPPLY 4) HALT)
(MACRO while (1 -1) 0 (ADDSP 1 FRAME (GREF gensym APPLY 0) LOCAL -2 FRAME (FRAME (FRAME (FRAME (LREF -2 PUSH GREF list APPLY 1) PUSH GREF list APPLY 1) PUSH LREF 1 PUSH GREF append APPLY 2) PUSH LREF 0 PUSH CONST when PUSH GREF list* APPLY 3) PUSH CONST nil PUSH LREF -2 PUSH CONST let PUSH GREF list TAPPLY 4) HALT)
(MACRO awhile (1 -1) 0 (ADDSP 1 FRAME (GREF gensym APPLY 0) LOCAL -2 FRAME (FRAME (FRAME (FRAME (LREF -2 PUSH GREF list APPLY 1) PUSH GREF list APPLY 1) PUSH LREF 1 PUSH GREF append APPLY 2) PUSH LREF 0 PUSH CONST awhen PUSH GREF list* APPLY 3) PUSH CONST nil PUSH LREF -2 PUSH CONST let PUSH GREF list TAPPLY 4) HALT)
(MACRO until (1 -1) 0 (ADDSP 1 FRAME (GREF gensym APPLY 0) LOCAL -2 FRAME (FRAME (FRAME (FRAME (LREF -2 PUSH GREF list APPLY 1) PUSH GREF list APPLY 1) PUSH LREF 1 PUSH GREF append APPLY 2) PUSH LREF 0 PUSH CONST unless PUSH GREF list* APPLY 3) PUSH CONST nil PUSH LREF -2 PUSH CONST let PUSH GREF list TAPPLY 4) HALT)
(MACRO or (0 -1) 0 (ADDSP 1 LREF 0 TEST (FRAME (GREF gensym APPLY 0) LOCAL -2 FRAME (FRAME (FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH CONST or PUSH GREF list* APPLY 2) PUSH LREF -2 PUSH LREF -2 PUSH CONST if PUSH GREF list APPLY 4) PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH LREF -2 PUSH CONST let1 PUSH GREF list TAPPLY 4) CONST nil RET) HALT)
(MACRO case (1 -1) 0 (ADDSP 1 FRAME (GREF gensym APPLY 0) LOCAL -2 FRAME (FRAME (LREF 1 PUSH LREF -2 PUSH CLOSE 1 1 (ADDSP 2 FRAME (LREF 0 PUSH GREF cdr APPLY 1) LOCAL -3 FRAME (LREF 0 PUSH GREF car APPLY 1) LOCAL -2 FRAME (CONST t PUSH LREF -2 PUSH GREF eq? APPLY 2) TEST (LREF 0 RET) FRAME (LREF -2 PUSH GREF pair? APPLY 1) TEST (LREF -3 PUSH FRAME (FRAME (LREF -2 PUSH CONST quote PUSH GREF list APPLY 2) PUSH FREF 0 PUSH CONST member PUSH GREF list APPLY 3) PUSH GREF list* TAPPLY 2) LREF -3 PUSH FRAME (FRAME (LREF -2 PUSH CONST quote PUSH GREF list APPLY 2) PUSH FREF 0 PUSH CONST eq? PUSH GREF list APPLY 3) PUSH GREF list* TAPPLY 2) PUSH GREF map APPLY 2) PUSH CONST cond PUSH GREF list* APPLY 2) PUSH LREF 0 PUSH LREF -2 PUSH CONST let1 PUSH GREF list TAPPLY 4) HALT)
(MACRO dolist (1 -1) 0 (ADDSP 4 FRAME (LREF 0 PUSH GREF cadr APPLY 1) LOCAL -3 FRAME (LREF 0 PUSH GREF car APPLY 1) LOCAL -2 FRAME (GREF gensym APPLY 0) LOCAL -5 FRAME (GREF gensym APPLY 0) LOCAL -4 FRAME (FRAME (FRAME (FRAME (FRAME (FRAME (LREF -4 PUSH CONST cdr PUSH GREF list APPLY 2) PUSH LREF -5 PUSH GREF list APPLY 2) PUSH GREF list APPLY 1) PUSH LREF 1 PUSH GREF append APPLY 2) PUSH FRAME (LREF -4 PUSH CONST car PUSH GREF list APPLY 2) PUSH LREF -2 PUSH CONST let1 PUSH GREF list* APPLY 4) PUSH FRAME (LREF -4 PUSH CONST pair? PUSH GREF list APPLY 2) PUSH CONST when PUSH GREF list APPLY 3) PUSH FRAME (FRAME (LREF -3 PUSH LREF -4 PUSH GREF list APPLY 2) PUSH GREF list APPLY 1) PUSH LREF -5 PUSH CONST let PUSH GREF list TAPPLY 4) HALT)
(MACRO for0-n (2 -1) 0 (ADDSP 2 FRAME (GREF gensym APPLY 0) LOCAL -3 FRAME (GREF gensym APPLY 0) LOCAL -2 FRAME (FRAME (FRAME (FRAME (FRAME (FRAME (CONST (1) PUSH LREF 0 PUSH CONST + PUSH GREF list* APPLY 3) PUSH LREF -3 PUSH GREF list APPLY 2) PUSH GREF list APPLY 1) PUSH LREF 2 PUSH GREF append APPLY 2) PUSH FRAME (LREF -2 PUSH LREF 0 PUSH CONST < PUSH GREF list APPLY 3) PUSH CONST when PUSH GREF list* APPLY 3) PUSH FRAME (FRAME (CONST (0) PUSH LREF 0 PUSH GREF list* APPLY 2) PUSH GREF list APPLY 1) PUSH LREF -3 PUSH CONST let PUSH GREF list APPLY 4) PUSH LREF 1 PUSH LREF -2 PUSH CONST let1 PUSH GREF list TAPPLY 4) HALT)
(CLOSE 1 0 (ADDSP 4 FRAME (LREF 0 PUSH GREF type APPLY 1) LOCAL -2 FRAME (CONST pair PUSH LREF -2 PUSH GREF eq? APPLY 2) TEST (GREF nil LOCAL -3 CONST 0 LOCAL -5 LREF 0 LOCAL -4 . #0=(FRAME (LREF -4 PUSH GREF pair? APPLY 1) TEST (FRAME (CONST 1 PUSH LREF -5 PUSH GREF + APPLY 2) PUSH FRAME (LREF -4 PUSH GREF cdr APPLY 1) PUSH LOOP 2 2 . #0#) LREF -5 . #1=(RET))) FRAME (CONST string PUSH LREF -2 PUSH GREF eq? APPLY 2) TEST (LREF 0 PUSH GREF string-length TAPPLY 1) FRAME (CONST vector PUSH LREF -2 PUSH GREF eq? APPLY 2) TEST (LREF 0 PUSH GREF vector-length TAPPLY 1) CONST 0 . #1#) DEF length HALT)
(CLOSE 1 0 (FRAME (FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF pair? APPLY 1) TEST (FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF last TAPPLY 1) LREF 0 RET) DEF last HALT)
(CLOSE 1 0 (ADDSP 3 GREF nil LOCAL -2 CONST nil LOCAL -4 LREF 0 LOCAL -3 . #0=(FRAME (LREF -3 PUSH GREF pair? APPLY 1) TEST (FRAME (LREF -4 PUSH FRAME (LREF -3 PUSH GREF car APPLY 1) PUSH GREF cons APPLY 2) PUSH FRAME (LREF -3 PUSH GREF cdr APPLY 1) PUSH LOOP 1 2 . #0#) LREF -4 RET)) DEF reverse HALT)
(CLOSE 2 0 (ADDSP 4 GREF nil LOCAL -2 CONST nil LOCAL -4 LREF 1 LOCAL -3 . #0=(FRAME (LREF -3 PUSH GREF pair? APPLY 1) TEST (FRAME (LREF -4 PUSH FRAME (LREF -3 PUSH LREF 0 APPLY 1) PUSH GREF cons APPLY 2) PUSH FRAME (LREF -3 PUSH GREF cdr APPLY 1) PUSH LOOP 1 2 . #0#) FRAME (LREF -4 PUSH GREF reverse! APPLY 1) LOCAL -5 LREF -3 TEST (LREF -4 TEST (FRAME (FRAME (LREF -3 PUSH LREF 0 APPLY 1) PUSH LREF -4 PUSH GREF set-cdr! APPLY 2) LREF -5 . #1=(RET)) LREF -3 PUSH LREF 0 TAPPLY 1) LREF -5 . #1#)) DEF maplist HALT)
(CLOSE 2 0 (LREF 1 PUSH LREF 0 PUSH CLOSE 1 1 (LREF 0 PUSH FREF 0 PUSH GREF eq? TAPPLY 2) PUSH GREF any? TAPPLY 2) DEF member HALT)
(CLOSE 2 0 (LREF 1 TEST (FRAME (LREF 0 PUSH FRAME (LREF 1 PUSH GREF caar APPLY 1) PUSH GREF eq? APPLY 2) TEST (LREF 1 PUSH GREF car TAPPLY 1) FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 0 PUSH GREF assoc TAPPLY 2) GREF nil RET) DEF assoc HALT)
(CLOSE 3 0 (LREF 2 PUSH FRAME (LREF 1 PUSH LREF 0 PUSH GREF cons APPLY 2) PUSH GREF cons TAPPLY 2) DEF acons HALT)
(CLOSE 2 0 (ADDSP 1 LREF 0 TEST (FRAME (LREF 0 PUSH GREF car APPLY 1) LOCAL -2 FRAME (LREF 1 PUSH LREF -2 PUSH GREF member APPLY 2) TEST (LREF 1 . #0=(PUSH FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF union TAPPLY 2)) FRAME (LREF 1 PUSH LREF -2 PUSH GREF cons APPLY 2) . #0#) LREF 1 RET) DEF union HALT)
(CLOSE 2 0 (LREF 0 TEST (FRAME (LREF 1 PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF member APPLY 2) TEST (FRAME (LREF 1 PUSH FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF intersection APPLY 2) PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF cons TAPPLY 2) LREF 1 PUSH FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF intersection TAPPLY 2) CONST nil RET) DEF intersection HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF pair? APPLY 1) TEST (FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF not TAPPLY 1) CONST nil RET) DEF single? HALT)
(CLOSE (1 -1) 0 (ADDSP 1 LREF 1 TEST (FRAME (LREF 1 PUSH GREF car APPLY 1) . #0=(LOCAL -2 FRAME (LREF -2 PUSH FRAME (LREF 0 PUSH GREF create-ss-table APPLY 1) PUSH LREF 0 PUSH GREF write/ss-print APPLY 3) LREF 0 RET)) GREF *stdout* . #0#) DEF write/ss HALT)
(CONST 0 PUSH ADDSP 1 FRAME (GREF gensym APPLY 0) LOCAL -2 LREF -2 PUSH CLOSE 1 1 (ADDSP 3 CLOSE 3 0 (ADDSP 1 FRAME (LREF 1 PUSH LREF 0 PUSH GREF table-get APPLY 2) TEST (VOID RET) FRAME (LREF 2 PUSH LREF 0 PUSH GREF table-get APPLY 2) LOCAL -2 FRAME (LREF -2 PUSH LREF 1 PUSH LREF 0 PUSH GREF table-put! APPLY 3) FRAME (LREF -2 PUSH CONST 1 PUSH GREF + APPLY 2) PUSH LREF 2 PUSH LREF 0 PUSH GREF table-put! TAPPLY 3) LOCAL -3 FRAME (CONST eq? PUSH GREF table APPLY 1) LOCAL -2 FRAME (CONST 0 PUSH FREF 0 PUSH LREF -2 PUSH GREF table-put! APPLY 3) GREF nil LOCAL -4 BOX -4 FREF 0 PUSH LREF -3 PUSH LREF -4 PUSH LREF -2 PUSH CLOSE 1 4 (ADDSP 5 . #0=(FRAME (LREF 0 PUSH GREF type APPLY 1) LOCAL -2 FRAME (CONST (pair vector) PUSH LREF -2 PUSH GREF member APPLY 2) TEST (FRAME (LREF 0 PUSH FREF 0 PUSH GREF table-exists? APPLY 2) TEST (FREF 3 PUSH LREF 0 PUSH FREF 0 PUSH FREF 2 TAPPLY 3) FRAME (GREF nil PUSH LREF 0 PUSH FREF 0 PUSH GREF table-put! APPLY 3) LREF -2 LOCAL -3 FRAME (CONST pair PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH FREF 1 UNBOX APPLY 1) FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH LOOP 0 1 . #0#) FRAME (CONST vector PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 0 PUSH GREF length APPLY 1) LOCAL -4 GREF nil LOCAL -5 CONST 0 LOCAL -6 . #1=(FRAME (LREF -4 PUSH LREF -6 PUSH GREF < APPLY 2) TEST (FRAME (FRAME (LREF -6 PUSH LREF 0 PUSH GREF vector-get APPLY 2) PUSH FREF 1 UNBOX APPLY 1) FRAME (CONST 1 PUSH LREF -6 PUSH GREF + APPLY 2) PUSH LOOP 4 1 . #1#) VOID . #2=(RET))) GREF nil . #2#) VOID . #2#)) LSET -4 FRAME (LREF 0 PUSH LREF -4 UNBOX APPLY 1) LREF -2 RET) DEF create-ss-table ADDSP -2 HALT)
(CLOSE 3 0 (ADDSP 9 FRAME (LREF 0 PUSH LREF 1 PUSH GREF table-get APPLY 2) LOCAL -2 LREF -2 TEST (FRAME (CONST 0 PUSH LREF -2 PUSH GREF < APPLY 2) . #7=(TEST (FRAME (LREF -2 PUSH CONST -1 PUSH GREF - APPLY 2) PUSH CONST "#%@#" PUSH LREF 2 PUSH GREF format TAPPLY 3) LREF -2 TEST (FRAME (LREF -2 PUSH CONST "#%@=" PUSH LREF 2 PUSH GREF format APPLY 3) FRAME (FRAME (LREF -2 PUSH CONST -1 PUSH GREF - APPLY 2) PUSH LREF 0 PUSH LREF 1 PUSH GREF table-put! APPLY 3) . #6=(FRAME (LREF 0 PUSH GREF type APPLY 1) LOCAL -3 FRAME (CONST pair PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF single? APPLY 1) TEST (FRAME (FRAME (FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH LREF 1 PUSH GREF table-get APPLY 2) PUSH GREF not APPLY 1) TEST (FRAME (CONST ((quote . "'") (quasiquote . "`") (unquote . ",") (unquote-splicing . ",@")) PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF assoc APPLY 2) . #4=(LOCAL -4 LREF -4 TEST (FRAME (LREF 2 PUSH FRAME (LREF -4 PUSH GREF cdr APPLY 1) PUSH GREF display APPLY 2) LREF 2 PUSH FRAME (LREF 0 PUSH GREF cadr APPLY 1) PUSH GREF write TAPPLY 2) GREF nil LOCAL -5 LREF 0 LOCAL -7 CONST "(" LOCAL -6 . #0=(LREF -7 TEST (FRAME (LREF 2 PUSH LREF -6 PUSH GREF display APPLY 2) FRAME (LREF 2 PUSH LREF 1 PUSH FRAME (LREF -7 PUSH GREF car APPLY 1) PUSH GREF write/ss-print APPLY 3) FRAME (LREF -7 PUSH GREF cdr APPLY 1) LOCAL -8 LREF -8 TEST (FRAME (FRAME (LREF -8 PUSH GREF pair? APPLY 1) PUSH GREF not APPLY 1) . #2=(LOCAL -9 LREF -9 TEST (LREF -9 . #1=(TEST (FRAME (LREF 2 PUSH CONST " . " PUSH GREF display APPLY 2) FRAME (LREF 2 PUSH LREF 1 PUSH LREF -8 PUSH GREF write/ss-print APPLY 3) . #3=(LREF 2 PUSH CONST ")" PUSH GREF display TAPPLY 2)) LREF -8 PUSH CONST " " PUSH LOOP 4 2 . #0#)) FRAME (LREF -8 PUSH LREF 1 PUSH GREF table-get APPLY 2) LOCAL -10 LREF -10 TEST (LREF -10 . #1#) GREF nil . #1#)) CONST nil . #2#) VOID . #3#))) CONST nil . #4#) CONST nil . #4#) FRAME (CONST vector PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 0 PUSH GREF vector-length APPLY 1) LOCAL -4 GREF nil LOCAL -5 CONST 0 LOCAL -7 CONST "#(" LOCAL -6 . #5=(FRAME (LREF -4 PUSH LREF -7 PUSH GREF < APPLY 2) TEST (FRAME (LREF 2 PUSH LREF -6 PUSH GREF display APPLY 2) FRAME (LREF 2 PUSH LREF 1 PUSH FRAME (LREF -7 PUSH LREF 0 PUSH GREF vector-get APPLY 2) PUSH GREF write/ss-print APPLY 3) FRAME (CONST 1 PUSH LREF -7 PUSH GREF + APPLY 2) PUSH CONST " " PUSH LOOP 4 2 . #5#) VOID LREF 2 PUSH CONST ")" PUSH GREF display TAPPLY 2)) LREF 2 PUSH LREF 0 PUSH GREF write TAPPLY 2)) VOID . #6#)) CONST nil . #7#) DEF write/ss-print HALT)
(CLOSE 2 0 (ADDSP 4 GREF nil LOCAL -2 LREF 1 LOCAL -5 CONST nil LOCAL -4 LREF 0 LOCAL -3 . #0=(LREF -5 TEST (FRAME (CONST 0 PUSH LREF -3 PUSH GREF > APPLY 2) . #1=(TEST (FRAME (LREF -5 PUSH GREF cdr APPLY 1) PUSH FRAME (LREF -4 PUSH FRAME (LREF -5 PUSH GREF car APPLY 1) PUSH GREF cons APPLY 2) PUSH FRAME (CONST 1 PUSH LREF -3 PUSH GREF - APPLY 2) PUSH LOOP 1 3 . #0#) LREF -4 PUSH GREF reverse! TAPPLY 1)) CONST nil . #1#)) DEF take HALT)
(CLOSE 2 0 (LREF 1 TEST (FRAME (CONST 0 PUSH LREF 0 PUSH GREF > APPLY 2) TEST (FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH FRAME (CONST 1 PUSH LREF 0 PUSH GREF - APPLY 2) PUSH GREF drop TAPPLY 2) LREF 1 . #0=(RET)) VOID . #0#) DEF drop HALT)
(CLOSE 2 0 (FRAME (LREF 0 PUSH LREF 1 PUSH GREF drop APPLY 2) PUSH GREF car TAPPLY 1) DEF elt HALT)
(CLOSE 2 0 (ADDSP 3 GREF nil LOCAL -2 CONST 0 LOCAL -4 LREF 1 LOCAL -3 . #0=(LREF -3 TEST (FRAME (FRAME (LREF -3 PUSH GREF car APPLY 1) PUSH LREF 0 APPLY 1) TEST (LREF -4 . #1=(RET)) FRAME (CONST 1 PUSH LREF -4 PUSH GREF + APPLY 2) PUSH FRAME (LREF -3 PUSH GREF cdr APPLY 1) PUSH LOOP 1 2 . #0#) GREF nil . #1#)) DEF position-if HALT)
(CLOSE 2 0 (LREF 1 PUSH LREF 0 PUSH CLOSE 1 1 (FREF 0 PUSH LREF 0 PUSH GREF eq? TAPPLY 2) PUSH GREF position-if TAPPLY 2) DEF position HALT)
(CLOSE 1 0 (ADDSP 2 FRAME (LREF 0 PUSH GREF not APPLY 1) LOCAL -2 LREF -2 TEST (LREF -2 . #0=(RET)) FRAME (LREF 0 PUSH GREF pair? APPLY 1) TEST (FRAME (FRAME (FRAME (LREF 0 PUSH GREF last APPLY 1) PUSH GREF cdr APPLY 1) PUSH GREF not APPLY 1) . #1=(LOCAL -3 LREF -3 TEST (LREF -3 . #0#) GREF nil . #0#)) CONST nil . #1#) DEF list? HALT)
(CLOSE 2 0 (FRAME (FRAME (LREF 1 PUSH GREF car APPLY 1) PUSH LREF 0 PUSH GREF set-car! APPLY 2) FRAME (LREF 1 PUSH GREF cdr APPLY 1) PUSH LREF 0 PUSH GREF set-cdr! TAPPLY 2) DEF copy-pair! HALT)
(CLOSE 2 0 (ADDSP 3 GREF nil LOCAL -2 CONST nil LOCAL -4 LREF 1 LOCAL -3 . #0=(LREF -3 TEST (FRAME (FRAME (LREF -3 PUSH GREF car APPLY 1) PUSH LREF 0 APPLY 1) TEST (LREF -4 . #1=(PUSH FRAME (LREF -3 PUSH GREF cdr APPLY 1) PUSH LOOP 1 2 . #0#)) FRAME (LREF -4 PUSH FRAME (LREF -3 PUSH GREF car APPLY 1) PUSH GREF cons APPLY 2) . #1#) LREF -4 PUSH GREF reverse! TAPPLY 1)) DEF remove-if HALT)
(CLOSE 2 0 (LREF 1 PUSH LREF 0 PUSH CLOSE 1 1 (FRAME (LREF 0 PUSH FREF 0 APPLY 1) PUSH GREF not TAPPLY 1) PUSH GREF remove-if TAPPLY 2) DEF remove-if-not HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF pair? APPLY 1) TEST (FRAME (FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF copy-list APPLY 1) PUSH FRAME (FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF copy-list APPLY 1) PUSH GREF cons TAPPLY 2) LREF 0 RET) DEF copy-list HALT)
(CLOSE 2 0 (FRAME (CONST 0 PUSH FRAME (LREF 1 PUSH LREF 0 PUSH GREF logand APPLY 2) PUSH GREF eq? APPLY 2) PUSH GREF not TAPPLY 1) DEF bit? HALT)
(MACRO record (2 -1) 0 (LREF 0 PUSH FRAME (LREF 2 PUSH LREF 1 PUSH CONST ^ PUSH GREF list* APPLY 3) PUSH CONST apply PUSH GREF list TAPPLY 3) HALT)
(MACRO record-case (1 -1) 0 (ADDSP 1 FRAME (GREF gensym APPLY 0) LOCAL -2 FRAME (FRAME (LREF 1 PUSH LREF -2 PUSH CLOSE 1 1 (ADDSP 1 FRAME (LREF 0 PUSH GREF car APPLY 1) LOCAL -2 FRAME (CONST t PUSH LREF -2 PUSH GREF eq? APPLY 2) TEST (LREF 0 RET) FRAME (FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH FRAME (FREF 0 PUSH CONST cdr PUSH GREF list APPLY 2) PUSH CONST record PUSH GREF list* APPLY 3) PUSH LREF -2 PUSH GREF list TAPPLY 2) PUSH GREF map APPLY 2) PUSH FRAME (LREF -2 PUSH CONST car PUSH GREF list APPLY 2) PUSH CONST case PUSH GREF list* APPLY 3) PUSH LREF 0 PUSH LREF -2 PUSH CONST let1 PUSH GREF list TAPPLY 4) HALT)
(CONST 1 DEF VAR-ARG HALT)
(CONST 2 DEF VAR-FREE HALT)
(CONST 4 DEF VAR-SET HALT)
(CONST 8 DEF VAR-SELF-TAIL-RECUR HALT)
(CONST 16 DEF VAR-CALL-IN-BASE1 HALT)
(CONST 32 DEF VAR-CALL-IN-BASE2 HALT)
(CONST 64 DEF VAR-CALL-OTHER HALT)
(CONST 128 DEF VAR-CONTI HALT)
(CLOSE 3 0 (ADDSP 1 FRAME (LREF 0 PUSH GREF symbol? APPLY 1) TEST (FRAME (GREF VAR-ARG PUSH LREF 0 PUSH LREF 1 PUSH GREF add-var-info APPLY 3) LREF 1 PUSH LREF 0 PUSH GREF traverse-refer TAPPLY 2) FRAME (LREF 0 PUSH GREF pair? APPLY 1) TEST (FRAME (LREF 1 PUSH LREF 0 PUSH GREF expand-macro APPLY 2) LOCAL -2 FRAME (LREF -2 PUSH GREF pair? APPLY 1) TEST (LREF 2 PUSH LREF 1 PUSH LREF -2 PUSH GREF traverse-list TAPPLY 3) LREF 2 PUSH LREF 1 PUSH LREF -2 PUSH GREF traverse TAPPLY 3) LREF 0 PUSH CONST :CONST PUSH GREF list TAPPLY 2) DEF traverse HALT)
(CLOSE 3 0 (ADDSP 4 LREF 0 LOCAL -2 FRAME (LREF -2 PUSH GREF car APPLY 1) LOCAL -3 FRAME (CONST quote PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH CLOSE 1 0 (LREF 0 PUSH CONST :CONST PUSH GREF list TAPPLY 2) PUSH GREF apply TAPPLY 2) FRAME (CONST ^ PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 1 PUSH CLOSE (1 -1) 1 (FREF 0 PUSH LREF 1 PUSH LREF 0 PUSH GREF traverse-lambda TAPPLY 3) PUSH GREF apply TAPPLY 2) FRAME (CONST if PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 2 PUSH LREF 1 PUSH CLOSE (2 -1) 2 (FREF 1 PUSH FREF 0 PUSH LREF 2 PUSH LREF 1 PUSH LREF 0 PUSH GREF traverse-if TAPPLY 5) PUSH GREF apply TAPPLY 2) FRAME (CONST set! PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 1 PUSH CLOSE 2 1 (FREF 0 PUSH LREF 1 PUSH LREF 0 PUSH GREF traverse-set! TAPPLY 3) PUSH GREF apply TAPPLY 2) FRAME (CONST def PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 1 PUSH CLOSE 2 1 (FREF 0 PUSH LREF 1 PUSH LREF 0 PUSH GREF traverse-def TAPPLY 3) PUSH GREF apply TAPPLY 2) FRAME (CONST call/cc PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 2 PUSH LREF 1 PUSH CLOSE 1 2 (FREF 1 PUSH FREF 0 PUSH LREF 0 PUSH GREF traverse-call/cc TAPPLY 3) PUSH GREF apply TAPPLY 2) FRAME (CONST defmacro PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 1 PUSH CLOSE (2 -1) 1 (FREF 0 PUSH LREF 2 PUSH LREF 1 PUSH LREF 0 PUSH GREF traverse-defmacro TAPPLY 4) PUSH GREF apply TAPPLY 2) FRAME (CONST values PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 2 PUSH LREF 1 PUSH CLOSE (0 -1) 2 (FREF 1 PUSH FREF 0 PUSH LREF 0 PUSH GREF traverse-values TAPPLY 3) PUSH GREF apply TAPPLY 2) FRAME (CONST receive PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 2 PUSH LREF 1 PUSH CLOSE (2 -1) 2 (FREF 1 PUSH FREF 0 PUSH LREF 2 PUSH LREF 1 PUSH LREF 0 PUSH GREF traverse-receive TAPPLY 5) PUSH GREF apply TAPPLY 2) FRAME (LREF 0 PUSH GREF cdr APPLY 1) LOCAL -5 FRAME (LREF 0 PUSH GREF car APPLY 1) LOCAL -4 FRAME (LREF -4 PUSH GREF direct-invoke? APPLY 1) TEST (LREF 2 PUSH LREF 1 PUSH LREF -5 PUSH FRAME (LREF -4 PUSH GREF cddr APPLY 1) PUSH FRAME (LREF -4 PUSH GREF cadr APPLY 1) PUSH GREF traverse-apply-direct TAPPLY 5) FRAME (LREF -4 PUSH GREF inline-function? APPLY 1) TEST (LREF 2 PUSH LREF 1 PUSH LREF -5 PUSH LREF -4 PUSH GREF traverse-inline-apply TAPPLY 4) LREF 2 PUSH LREF 1 PUSH LREF -5 PUSH LREF -4 PUSH GREF traverse-apply TAPPLY 4) DEF traverse-list HALT)
(CLOSE 2 0 (FRAME (FRAME (LREF 0 PUSH LREF 1 PUSH GREF scope-local-has? APPLY 2) PUSH GREF not APPLY 1) TEST (FRAME (LREF 0 PUSH LREF 1 PUSH GREF scope-upper-vars-has? APPLY 2) . #1=(TEST (FRAME (LREF 0 PUSH LREF 1 PUSH GREF register-fref APPLY 2) . #0=(LREF 0 PUSH CONST :REF PUSH GREF list TAPPLY 2)) VOID . #0#)) CONST nil . #1#) DEF traverse-refer HALT)
(CLOSE 3 0 (ADDSP 7 FRAME (LREF 0 PUSH GREF symbol? APPLY 1) TEST (VOID . #6=(FRAME (LREF 0 PUSH LREF 2 PUSH GREF scope-upper-vars-has? APPLY 2) LOCAL -3 FRAME (LREF 0 PUSH LREF 2 PUSH GREF scope-local-has? APPLY 2) LOCAL -2 FRAME (LREF -2 PUSH GREF not APPLY 1) TEST (LREF -3 . #5=(TEST (FRAME (LREF 0 PUSH LREF 2 PUSH GREF register-fref APPLY 2) . #4=(FRAME (LREF 1 PUSH GREF lambda-expression? APPLY 1) TEST (FRAME (LREF 1 PUSH GREF cddr APPLY 1) LOCAL -5 FRAME (LREF 1 PUSH GREF cadr APPLY 1) LOCAL -4 FRAME (LREF 2 PUSH LREF -5 PUSH LREF -4 PUSH GREF prepare-lambda-node APPLY 3) LOCAL -6 LREF -2 LOCAL -7 LREF -7 TEST (LREF -7 . #1=(TEST (FRAME (LREF -6 PUSH LREF 0 PUSH LREF 2 PUSH GREF register-set! APPLY 3) . #0=(FRAME (LREF -5 PUSH LREF -6 PUSH GREF traverse-lambda-exec APPLY 2) LREF -6 PUSH LREF 0 PUSH CONST :SET PUSH GREF list TAPPLY 3)) VOID . #0#)) LREF -3 LOCAL -8 LREF -8 TEST (LREF -8 . #1#) GREF nil . #1#) FRAME (GREF nil PUSH LREF 2 PUSH LREF 1 PUSH GREF traverse APPLY 3) LOCAL -4 LREF -2 LOCAL -5 LREF -5 TEST (LREF -5 . #3=(TEST (FRAME (LREF -4 PUSH LREF 0 PUSH LREF 2 PUSH GREF register-set! APPLY 3) . #2=(LREF -4 PUSH LREF 0 PUSH CONST :SET PUSH GREF list TAPPLY 3)) VOID . #2#)) LREF -3 LOCAL -6 LREF -6 TEST (LREF -6 . #3#) GREF nil . #3#)) VOID . #4#)) CONST nil . #5#)) FRAME (LREF 0 PUSH CONST "`set!` requires symbol, but `%@`" PUSH GREF compile-error APPLY 2) . #6#) DEF traverse-set! HALT)
(CLOSE 3 0 (ADDSP 1 FRAME (LREF 0 PUSH GREF symbol? APPLY 1) TEST (VOID . #2=(FRAME (LREF 0 PUSH GREF inline-function? APPLY 1) TEST (FRAME (LREF 1 PUSH GREF lambda-expression? APPLY 1) . #1=(TEST (FRAME (LREF 1 PUSH LREF 0 PUSH GREF register-inline-function APPLY 2) . #0=(FRAME (GREF nil PUSH LREF 2 PUSH LREF 1 PUSH GREF traverse APPLY 3) LOCAL -2 LREF -2 PUSH LREF 0 PUSH CONST :DEF PUSH GREF list TAPPLY 3)) VOID . #0#)) CONST nil . #1#)) FRAME (LREF 0 PUSH CONST "`def` requires symbol, but `%@`" PUSH GREF compile-error APPLY 2) . #2#) DEF traverse-def HALT)
(CLOSE 5 0 (LREF 2 TEST (FRAME (LREF 2 PUSH GREF cdr APPLY 1) . #2=(TEST (FRAME (CONST "malformed if" PUSH GREF compile-error APPLY 1) . #1=(LREF 2 TEST (FRAME (LREF 4 PUSH LREF 3 PUSH FRAME (LREF 2 PUSH GREF car APPLY 1) PUSH GREF traverse APPLY 3) . #0=(PUSH FRAME (LREF 4 PUSH LREF 3 PUSH LREF 1 PUSH GREF traverse APPLY 3) PUSH FRAME (GREF nil PUSH LREF 3 PUSH LREF 0 PUSH GREF traverse APPLY 3) PUSH CONST :IF PUSH GREF list TAPPLY 4)) CONST (:VOID) . #0#)) VOID . #1#)) CONST nil . #2#) DEF traverse-if HALT)
(CLOSE 3 0 (ADDSP 4 FRAME (LREF 0 PUSH GREF direct-invoke? APPLY 1) TEST (FRAME (LREF 0 PUSH GREF cddr APPLY 1) LOCAL -3 FRAME (LREF 0 PUSH GREF cadr APPLY 1) LOCAL -2 FRAME (FRAME (LREF -2 PUSH FRAME (LREF -2 PUSH GREF check-parameters APPLY 1) PUSH GREF eq? APPLY 2) PUSH GREF not APPLY 1) TEST (FRAME (CONST "Not implemented: rest param for call/cc" PUSH GREF compile-error APPLY 1) . #1=(FRAME (CONST 1 PUSH FRAME (LREF -2 PUSH GREF length APPLY 1) PUSH GREF eq? APPLY 2) TEST (VOID . #0=(FRAME (LREF 1 PUSH LREF -2 PUSH GREF expand-scope APPLY 2) LOCAL -4 FRAME (LREF 2 PUSH LREF -4 PUSH LREF -3 PUSH GREF traverse-body APPLY 3) LOCAL -5 FRAME (GREF VAR-CONTI PUSH FRAME (LREF -2 PUSH GREF car APPLY 1) PUSH LREF -4 PUSH GREF add-var-info APPLY 3) LREF -5 PUSH LREF -4 PUSH CONST :CONTI-DIRECT PUSH GREF list TAPPLY 3)) FRAME (LREF -2 PUSH CONST "Illegal parameters, call/cc requires 1 parameter function, but `%@`" PUSH GREF compile-error APPLY 2) . #0#)) VOID . #1#) FRAME (LREF 2 PUSH LREF 1 PUSH LREF 0 PUSH GREF traverse APPLY 3) PUSH CONST :CONTI PUSH GREF list TAPPLY 2) DEF traverse-call/cc HALT)
(CLOSE 3 0 (ADDSP 4 LREF 1 TEST (FRAME (GREF nil PUSH GREF nil PUSH GREF cons APPLY 2) . #1=(LOCAL -3 FRAME (LREF 0 PUSH GREF check-parameters APPLY 1) LOCAL -2 FRAME (LREF -2 PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 0 PUSH GREF length APPLY 1) . #0=(LOCAL -5 FRAME (LREF 2 PUSH LREF -2 PUSH GREF create-scope APPLY 2) LOCAL -4 LREF -3 PUSH LREF -5 PUSH LREF -2 PUSH LREF -4 PUSH GREF create-lambda-node TAPPLY 4)) FRAME (CONST -1 PUSH FRAME (CONST 1 PUSH FRAME (LREF -2 PUSH GREF length APPLY 1) PUSH GREF - APPLY 2) PUSH GREF list APPLY 2) . #0#)) GREF nil . #1#) DEF prepare-lambda-node HALT)
(CLOSE 2 0 (ADDSP 2 FRAME (LREF 0 PUSH GREF lambda-body-node-get APPLY 1) LOCAL -3 FRAME (LREF 0 PUSH GREF lambda-scope-get APPLY 1) LOCAL -2 LREF 1 TEST (FRAME (FRAME (GREF t PUSH LREF -2 PUSH LREF 1 PUSH GREF traverse-body APPLY 3) PUSH LREF -3 PUSH GREF copy-pair! APPLY 2) . #0=(LREF 0 RET)) VOID . #0#) DEF traverse-lambda-exec HALT)
(CLOSE 3 0 (LREF 1 PUSH FRAME (LREF 2 PUSH LREF 1 PUSH LREF 0 PUSH GREF prepare-lambda-node APPLY 3) PUSH GREF traverse-lambda-exec TAPPLY 2) DEF traverse-lambda HALT)
(CLOSE 3 0 (LREF 0 PUSH LREF 2 PUSH LREF 1 PUSH CLOSE 1 2 (FRAME (FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF not APPLY 1) TEST (FREF 1 . #0=(PUSH FREF 0 PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF traverse TAPPLY 3)) CONST nil . #0#) PUSH GREF maplist TAPPLY 2) DEF traverse-body HALT)
(CLOSE 2 0 (ADDSP 2 FRAME (LREF 1 PUSH GREF scope-block-top-get APPLY 1) LOCAL -3 FRAME (LREF 0 PUSH GREF scope-upper-block-top-get APPLY 1) LOCAL -2 LREF -3 PUSH LREF -2 PUSH GREF eq? TAPPLY 2) DEF upper-scope-is? HALT)
(CLOSE 3 0 (ADDSP 3 FRAME (LREF 0 PUSH LREF 1 PUSH GREF var-is-set? APPLY 2) LOCAL -2 LREF -2 TEST (FRAME (LREF -2 PUSH GREF single? APPLY 1) TEST (FRAME (FRAME (LREF -2 PUSH GREF car APPLY 1) PUSH GREF lambda-node? APPLY 1) . #1=(TEST (FRAME (LREF 0 PUSH LREF 1 PUSH GREF scope-local-has? APPLY 2) TEST (FRAME (GREF VAR-CALL-IN-BASE1 PUSH LREF 0 PUSH LREF 1 PUSH GREF var-has-attr? APPLY 3) TEST (GREF VAR-CALL-IN-BASE2 . #0=(RET)) GREF VAR-CALL-IN-BASE1 . #0#) LREF 2 TEST (FRAME (LREF 0 PUSH LREF 1 PUSH GREF get-var-info APPLY 2) RECV 1 2 FRAME (LREF -4 PUSH LREF 1 PUSH GREF upper-scope-is? APPLY 2) TEST (GREF VAR-SELF-TAIL-RECUR . #0#) GREF VAR-CALL-OTHER . #0#) GREF VAR-CALL-OTHER . #0#) GREF VAR-CALL-OTHER . #0#)) CONST nil . #1#) CONST nil . #1#) DEF detect-call-type HALT)
(CLOSE 4 0 (ADDSP 2 FRAME (LREF 0 PUSH GREF symbol? APPLY 1) TEST (FRAME (LREF 2 PUSH LREF 0 PUSH GREF traverse-refer APPLY 2) . #0=(LOCAL -3 FRAME (LREF 3 PUSH LREF 2 PUSH LREF 0 PUSH GREF detect-call-type APPLY 3) LOCAL -2 FRAME (LREF -2 PUSH LREF 0 PUSH LREF 2 PUSH GREF add-var-info APPLY 3) FRAME (LREF 1 PUSH LREF 2 PUSH CLOSE 1 1 (GREF nil PUSH FREF 0 PUSH LREF 0 PUSH GREF traverse TAPPLY 3) PUSH GREF map APPLY 2) PUSH LREF -3 PUSH LREF -2 PUSH CONST :APPLY PUSH GREF list TAPPLY 4)) FRAME (GREF nil PUSH LREF 2 PUSH LREF 0 PUSH GREF traverse APPLY 3) . #0#) DEF traverse-apply HALT)
(CLOSE 4 0 (ADDSP 1 FRAME (LREF 0 PUSH GREF get-inline-function-body APPLY 1) LOCAL -2 LREF 3 PUSH LREF 2 PUSH FRAME (LREF 1 PUSH LREF -2 PUSH GREF list* APPLY 2) PUSH GREF traverse TAPPLY 3) DEF traverse-inline-apply HALT)
(CLOSE 5 0 (ADDSP 6 FRAME (LREF 0 PUSH GREF check-parameters APPLY 1) LOCAL -2 FRAME (FRAME (LREF 0 PUSH LREF -2 PUSH GREF eq? APPLY 2) TEST (CONST 0 . #0=(PUSH FRAME (LREF -2 PUSH GREF length APPLY 1) PUSH GREF - APPLY 2)) CONST 1 . #0#) LOCAL -4 FRAME (LREF 2 PUSH GREF length APPLY 1) LOCAL -3 FRAME (FRAME (LREF -2 PUSH LREF 0 PUSH GREF eq? APPLY 2) PUSH GREF not APPLY 1) TEST (FRAME (LREF -4 PUSH LREF -3 PUSH GREF < APPLY 2) TEST (LREF 4 PUSH LREF 3 PUSH LREF 2 PUSH LREF 1 PUSH LREF -2 PUSH GREF traverse-apply-direct TAPPLY 5) FRAME (LREF -4 PUSH LREF -3 PUSH GREF > APPLY 2) TEST (LREF 4 PUSH LREF 3 PUSH FRAME (FRAME (FRAME (FRAME (FRAME (LREF 2 PUSH LREF -4 PUSH GREF drop APPLY 2) PUSH CONST list PUSH GREF list* APPLY 2) PUSH GREF list APPLY 1) PUSH FRAME (LREF 2 PUSH LREF -4 PUSH GREF take APPLY 2) PUSH GREF append APPLY 2) PUSH FRAME (LREF 1 PUSH LREF -2 PUSH CONST ^ PUSH GREF list* APPLY 3) PUSH GREF list* APPLY 2) PUSH GREF traverse TAPPLY 3) LREF 4 PUSH LREF 3 PUSH FRAME (CONST (nil) PUSH LREF 2 PUSH GREF append APPLY 2) PUSH LREF 1 PUSH LREF -2 PUSH GREF traverse-apply-direct TAPPLY 5) FRAME (LREF -4 PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 2 PUSH LREF 3 PUSH CLOSE 1 1 (GREF nil PUSH FREF 0 PUSH LREF 0 PUSH GREF traverse TAPPLY 3) PUSH GREF map APPLY 2) LOCAL -5 FRAME (LREF 3 PUSH LREF -2 PUSH GREF expand-scope APPLY 2) LOCAL -6 FRAME (LREF 4 PUSH LREF -6 PUSH LREF 1 PUSH GREF traverse-body APPLY 3) LOCAL -7 LREF -7 PUSH LREF -5 PUSH LREF -6 PUSH CONST :INVOKE PUSH GREF list TAPPLY 4) FRAME (LREF -4 PUSH LREF -3 PUSH GREF < APPLY 2) TEST (CONST "few" . #1=(LOCAL -5 LREF -4 PUSH LREF -3 PUSH LREF -5 PUSH CONST "Too %@ arguments, %@ for %@" PUSH GREF compile-error TAPPLY 4)) CONST "many" . #1#) DEF traverse-apply-direct HALT)
(CLOSE 4 0 (ADDSP 4 FRAME (LREF 1 PUSH GREF check-parameters APPLY 1) LOCAL -2 FRAME (LREF 3 PUSH LREF -2 PUSH GREF create-scope APPLY 2) LOCAL -3 FRAME (GREF t PUSH LREF -3 PUSH LREF 2 PUSH GREF traverse-body APPLY 3) LOCAL -4 FRAME (LREF -2 PUSH LREF 1 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 1 PUSH GREF length APPLY 1) . #0=(LOCAL -5 LREF -4 PUSH LREF -5 PUSH LREF 0 PUSH LREF -3 PUSH CONST :MACRO PUSH GREF list TAPPLY 5)) FRAME (CONST -1 PUSH FRAME (CONST 1 PUSH FRAME (LREF -2 PUSH GREF length APPLY 1) PUSH GREF - APPLY 2) PUSH GREF list APPLY 2) . #0#) DEF traverse-defmacro HALT)
(CLOSE 3 0 (FRAME (LREF 0 PUSH LREF 0 PUSH LREF 2 PUSH LREF 1 PUSH CLOSE 1 3 (FRAME (FREF 2 PUSH GREF cdr APPLY 1) TEST (FREF 1 . #0=(PUSH FREF 0 PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF traverse TAPPLY 3)) CONST nil . #0#) PUSH GREF maplist APPLY 2) PUSH CONST :VALS PUSH GREF list TAPPLY 2) DEF traverse-values HALT)
(CLOSE 5 0 (ADDSP 5 FRAME (LREF 0 PUSH GREF check-parameters APPLY 1) LOCAL -2 FRAME (GREF nil PUSH LREF 3 PUSH LREF 1 PUSH GREF traverse APPLY 3) LOCAL -4 FRAME (LREF -2 PUSH LREF 0 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF 0 PUSH GREF length APPLY 1) . #0=(LOCAL -3 FRAME (LREF 3 PUSH LREF -2 PUSH GREF expand-scope APPLY 2) LOCAL -5 FRAME (LREF 4 PUSH LREF -5 PUSH LREF 2 PUSH GREF traverse-body APPLY 3) LOCAL -6 LREF -6 PUSH LREF -4 PUSH LREF -3 PUSH LREF -5 PUSH CONST :RECV PUSH GREF list TAPPLY 5)) FRAME (CONST -1 PUSH FRAME (CONST 1 PUSH FRAME (LREF -2 PUSH GREF length APPLY 1) PUSH GREF - APPLY 2) PUSH GREF list APPLY 2) . #0#) DEF traverse-receive HALT)
(CLOSE 1 0 (ADDSP 3 FRAME (LREF 0 PUSH GREF list? APPLY 1) TEST (VOID . #5=(FRAME (LREF 0 PUSH CLOSE 1 0 (CONST (&rest &body) PUSH LREF 0 PUSH GREF member TAPPLY 2) PUSH GREF position-if APPLY 2) LOCAL -2 LREF -2 TEST (FRAME (LREF 0 PUSH FRAME (CONST 1 PUSH LREF -2 PUSH GREF + APPLY 2) PUSH GREF drop APPLY 2) LOCAL -4 FRAME (LREF 0 PUSH LREF -2 PUSH GREF take APPLY 2) LOCAL -3 FRAME (LREF -4 PUSH GREF single? APPLY 1) TEST (VOID . #3=(FRAME (LREF -4 PUSH LREF -3 PUSH GREF append! APPLY 2) . #4=(LOCAL -2 FRAME (LREF 0 PUSH CLOSE 1 0 (FRAME (LREF 0 PUSH GREF symbol? APPLY 1) PUSH GREF not TAPPLY 1) PUSH GREF any? APPLY 2) LOCAL -3 LREF -3 TEST (FRAME (FRAME (LREF -3 PUSH GREF car APPLY 1) PUSH CONST "parameter must be symbol, but `%@`" PUSH GREF compile-error APPLY 2) . #2=(GREF nil LOCAL -3 LREF -2 LOCAL -4 . #0=(LREF -4 TEST (FRAME (FRAME (LREF -4 PUSH GREF cdr APPLY 1) PUSH FRAME (LREF -4 PUSH GREF car APPLY 1) PUSH GREF member APPLY 2) TEST (FRAME (FRAME (LREF -4 PUSH GREF car APPLY 1) PUSH CONST "Duplicated parameter `%@`" PUSH GREF compile-error APPLY 2) . #1=(FRAME (LREF -4 PUSH GREF cdr APPLY 1) PUSH LOOP 2 1 . #0#)) VOID . #1#) VOID LREF -2 RET))) VOID . #2#))) FRAME (LREF -4 PUSH CONST "&rest requires only 1 name, but %@" PUSH GREF compile-error APPLY 2) . #3#) LREF 0 . #4#)) FRAME (LREF 0 PUSH CONST "parameters must be list, but %@" PUSH GREF compile-error APPLY 2) . #5#) DEF check-parameters HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF pair? APPLY 1) TEST (FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH CONST ^ PUSH GREF eq? TAPPLY 2) CONST nil RET) DEF direct-invoke? HALT)
(CLOSE 2 0 (ADDSP 4 FRAME (LREF 0 PUSH GREF car APPLY 1) LOCAL -2 FRAME (FRAME (LREF -2 PUSH GREF symbol? APPLY 1) PUSH GREF not APPLY 1) LOCAL -3 LREF -3 TEST (LREF -3 . #0=(TEST (LREF 0 RET) LREF 0 PUSH GREF macroexpand TAPPLY 1)) FRAME (LREF -2 PUSH LREF 1 PUSH GREF scope-local-has? APPLY 2) LOCAL -4 LREF -4 TEST (LREF -4 . #0#) FRAME (LREF -2 PUSH LREF 1 PUSH GREF scope-upper-vars-has? APPLY 2) LOCAL -5 LREF -5 TEST (LREF -5 . #0#) GREF nil . #0#) DEF expand-macro HALT)
(CLOSE 1 0 (ADDSP 1 FRAME (LREF 0 PUSH GREF macroexpand-1 APPLY 1) LOCAL -2 FRAME (LREF 0 PUSH LREF -2 PUSH GREF equal? APPLY 2) TEST (LREF 0 RET) LREF -2 PUSH GREF macroexpand TAPPLY 1) DEF macroexpand HALT)
(CLOSE 2 0 (CONST 0 PUSH LREF 1 PUSH CONST nil PUSH GREF t PUSH CONST nil PUSH FRAME (LREF 0 PUSH CLOSE 1 0 (CONST 0 PUSH LREF 0 PUSH GREF cons TAPPLY 2) PUSH GREF map APPLY 2) PUSH GREF vector TAPPLY 6) DEF create-scope HALT)
(CLOSE 2 0 (LREF 1 PUSH FRAME (LREF 0 PUSH CLOSE 1 0 (CONST 0 PUSH LREF 0 PUSH GREF cons TAPPLY 2) PUSH GREF map APPLY 2) PUSH GREF expand-scope2 TAPPLY 2) DEF expand-scope HALT)
(CLOSE 2 0 (CONST 0 PUSH LREF 1 PUSH CONST nil PUSH GREF nil PUSH CONST nil PUSH LREF 0 PUSH GREF vector TAPPLY 6) DEF expand-scope2 HALT)
(CLOSE 1 0 (CONST 0 PUSH LREF 0 PUSH GREF vector-get TAPPLY 2) DEF scope-local-infos HALT)
(CLOSE 1 0 (CONST 1 PUSH LREF 0 PUSH GREF vector-get TAPPLY 2) DEF scope-frees HALT)
(CLOSE 1 0 (CONST 2 PUSH LREF 0 PUSH GREF vector-get TAPPLY 2) DEF scope-block-top? HALT)
(CLOSE 1 0 (CONST 3 PUSH LREF 0 PUSH GREF vector-get TAPPLY 2) DEF scope-sets HALT)
(CLOSE 1 0 (CONST 4 PUSH LREF 0 PUSH GREF vector-get TAPPLY 2) DEF scope-outer-scope HALT)
(CLOSE 1 0 (CONST 5 PUSH LREF 0 PUSH GREF vector-get TAPPLY 2) DEF scope-work-size HALT)
(CLOSE 2 0 (LREF 1 PUSH CONST 1 PUSH LREF 0 PUSH GREF vector-set! TAPPLY 3) DEF scope-frees-set! HALT)
(CLOSE 2 0 (LREF 1 PUSH CONST 3 PUSH LREF 0 PUSH GREF vector-set! TAPPLY 3) DEF scope-sets-set! HALT)
(CLOSE 2 0 (LREF 1 PUSH CONST 5 PUSH LREF 0 PUSH GREF vector-set! TAPPLY 3) DEF scope-work-size-set! HALT)
(CLOSE 2 0 (LREF 1 PUSH CONST 4 PUSH LREF 0 PUSH GREF vector-set! TAPPLY 3) DEF scope-outer-scope-set! HALT)
(CLOSE 1 0 (ADDSP 3 GREF nil LOCAL -2 CONST 0 LOCAL -4 FRAME (LREF 0 PUSH GREF scope-outer-scope APPLY 1) LOCAL -3 . #0=(FRAME (LREF -3 PUSH GREF scope-block-top? APPLY 1) TEST (LREF -4 RET) FRAME (FRAME (FRAME (LREF -3 PUSH GREF scope-local-infos APPLY 1) PUSH GREF length APPLY 1) PUSH LREF -4 PUSH GREF + APPLY 2) PUSH FRAME (LREF -3 PUSH GREF scope-outer-scope APPLY 1) PUSH LOOP 1 2 . #0#)) DEF scope-upper-work-size HALT)
(CLOSE 2 0 (ADDSP 3 GREF nil LOCAL -2 LREF 0 LOCAL -3 . #1=(FRAME (LREF 1 PUSH LREF -3 PUSH GREF scope-local-only-has? APPLY 2) LOCAL -4 LREF -4 TEST (FRAME (LREF -3 PUSH GREF scope-block-top? APPLY 1) TEST (LREF -4 . #0=(RET)) FRAME (FRAME (LREF -3 PUSH GREF scope-upper-work-size APPLY 1) PUSH LREF -4 PUSH GREF + APPLY 2) PUSH CONST -2 PUSH GREF - TAPPLY 2) FRAME (LREF -3 PUSH GREF scope-block-top? APPLY 1) TEST (VOID . #0#) FRAME (LREF -3 PUSH GREF scope-outer-scope APPLY 1) PUSH LOOP 1 1 . #1#)) DEF scope-local-has? HALT)
(CLOSE 2 0 (FRAME (LREF 0 PUSH GREF scope-local-infos APPLY 1) PUSH LREF 1 PUSH CLOSE 1 1 (FREF 0 PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF eq? TAPPLY 2) PUSH GREF position-if TAPPLY 2) DEF scope-local-only-has? HALT)
(CLOSE 1 0 (ADDSP 2 GREF nil LOCAL -2 LREF 0 LOCAL -3 . #0=(FRAME (LREF -3 PUSH GREF scope-block-top? APPLY 1) TEST (LREF -3 RET) FRAME (LREF -3 PUSH GREF scope-outer-scope APPLY 1) PUSH LOOP 1 1 . #0#)) DEF scope-block-top-get HALT)
(CLOSE 1 0 (FRAME (FRAME (LREF 0 PUSH GREF scope-block-top-get APPLY 1) PUSH GREF scope-outer-scope APPLY 1) PUSH GREF scope-block-top-get TAPPLY 1) DEF scope-upper-block-top-get HALT)
(CLOSE 2 0 (FRAME (LREF 1 PUSH GREF scope-block-top-get APPLY 1) PUSH FRAME (LREF 0 PUSH GREF scope-block-top-get APPLY 1) PUSH GREF eq? TAPPLY 2) DEF same-scope-block? HALT)
(CLOSE 2 0 (FRAME (FRAME (LREF 0 PUSH GREF scope-block-top-get APPLY 1) PUSH GREF scope-frees APPLY 1) PUSH LREF 1 PUSH GREF position TAPPLY 2) DEF scope-frees-has? HALT)
(CLOSE 2 0 (ADDSP 3 GREF nil LOCAL -2 FRAME (LREF 0 PUSH GREF scope-block-top-get APPLY 1) LOCAL -3 . #0=(FRAME (LREF -3 PUSH GREF scope-outer-scope APPLY 1) LOCAL -4 LREF -4 TEST (FRAME (LREF 1 PUSH LREF -4 PUSH GREF scope-local-only-has? APPLY 2) TEST (LREF -4 . #1=(RET)) LREF -4 PUSH LOOP 1 1 . #0#) GREF nil . #1#)) DEF scope-upper-vars-has? HALT)
(CLOSE 1 0 (ADDSP 4 GREF nil LOCAL -2 CONST 0 LOCAL -4 LREF 0 LOCAL -3 . #0=(FRAME (FRAME (FRAME (LREF -3 PUSH GREF scope-local-infos APPLY 1) PUSH GREF length APPLY 1) PUSH LREF -4 PUSH GREF + APPLY 2) LOCAL -5 FRAME (LREF -3 PUSH GREF scope-block-top? APPLY 1) TEST (LREF -5 RET) LREF -5 PUSH FRAME (LREF -3 PUSH GREF scope-outer-scope APPLY 1) PUSH LOOP 1 2 . #0#)) DEF scope-local-count HALT)
(CLOSE 1 0 (LREF 0 PUSH GREF cdr TAPPLY 1) DEF var-info-flag-get HALT)
(CLOSE 2 0 (LREF 1 PUSH LREF 0 PUSH GREF set-cdr! TAPPLY 2) DEF var-info-flag-set! HALT)
(CLOSE 2 0 (ADDSP 3 FRAME (LREF 1 PUSH GREF symbol? APPLY 1) TEST (GREF nil LOCAL -2 LREF 0 LOCAL -3 . #0=(LREF -3 TEST (FRAME (LREF 1 PUSH LREF -3 PUSH GREF scope-local-only-has? APPLY 2) LOCAL -4 LREF -4 TEST (LREF -3 PUSH FRAME (LREF -4 PUSH FRAME (LREF -3 PUSH GREF scope-local-infos APPLY 1) PUSH GREF elt APPLY 2) PUSH VALS 2 . #1=(RET)) FRAME (LREF -3 PUSH GREF scope-outer-scope APPLY 1) PUSH LOOP 1 1 . #0#) GREF nil PUSH GREF nil PUSH VALS 2 . #1#)) GREF nil PUSH GREF nil PUSH VALS 2 . #1#) DEF get-var-info HALT)
(CLOSE 3 0 (ADDSP 2 FRAME (LREF 1 PUSH LREF 0 PUSH GREF get-var-info APPLY 2) RECV 0 2 LREF -2 TEST (FRAME (FRAME (LREF 2 PUSH FRAME (LREF -2 PUSH GREF var-info-flag-get APPLY 1) PUSH GREF logior APPLY 2) PUSH LREF -2 PUSH GREF var-info-flag-set! APPLY 2) LREF -2 . #0=(RET)) VOID . #0#) DEF add-var-info HALT)
(CLOSE 3 0 (ADDSP 2 FRAME (LREF 1 PUSH LREF 0 PUSH GREF get-var-info APPLY 2) RECV 0 2 LREF -2 TEST (FRAME (LREF 2 PUSH FRAME (LREF -2 PUSH GREF var-info-flag-get APPLY 1) PUSH GREF bit? APPLY 2) TEST (LREF -2 . #0=(RET)) CONST nil . #0#) CONST nil . #0#) DEF var-has-attr? HALT)
(CLOSE 2 0 (ADDSP 3 FRAME (LREF 1 PUSH LREF 0 PUSH GREF get-var-info APPLY 2) RECV 0 2 LREF -3 TEST (FRAME (FRAME (LREF -3 PUSH GREF scope-sets APPLY 1) PUSH LREF 1 PUSH GREF assoc APPLY 2) . #0=(LOCAL -4 LREF -4 TEST (LREF -4 PUSH GREF cdr TAPPLY 1) VOID RET)) CONST nil . #0#) DEF var-is-set? HALT)
(CLOSE 2 0 (ADDSP 4 FRAME (GREF VAR-FREE PUSH LREF 1 PUSH LREF 0 PUSH GREF add-var-info APPLY 3) GREF nil LOCAL -2 LREF 0 LOCAL -3 . #0=(LREF -3 TEST (FRAME (LREF 1 PUSH LREF -3 PUSH GREF scope-local-has? APPLY 2) TEST (VOID . #2=(RET)) FRAME (LREF -3 PUSH GREF scope-block-top-get APPLY 1) LOCAL -4 FRAME (LREF -4 PUSH GREF scope-frees APPLY 1) LOCAL -5 LREF -5 TEST (FRAME (LREF -5 PUSH LREF 1 PUSH GREF member APPLY 2) TEST (VOID . #1=(FRAME (LREF -4 PUSH GREF scope-outer-scope APPLY 1) PUSH LOOP 1 1 . #0#)) FRAME (FRAME (GREF nil PUSH LREF 1 PUSH GREF cons APPLY 2) PUSH FRAME (LREF -5 PUSH GREF last APPLY 1) PUSH GREF set-cdr! APPLY 2) . #1#) FRAME (FRAME (GREF nil PUSH LREF 1 PUSH GREF cons APPLY 2) PUSH LREF -4 PUSH GREF scope-frees-set! APPLY 2) . #1#) VOID . #2#)) DEF register-fref HALT)
(CLOSE 3 0 (ADDSP 5 FRAME (GREF VAR-SET PUSH LREF 1 PUSH LREF 0 PUSH GREF add-var-info APPLY 3) FRAME (LREF 1 PUSH LREF 0 PUSH GREF get-var-info APPLY 2) RECV 0 2 LREF -2 TEST (FRAME (LREF 0 PUSH LREF -3 PUSH GREF same-scope-block? APPLY 2) TEST (LREF 2 . #0=(LOCAL -4 FRAME (LREF -3 PUSH GREF scope-sets APPLY 1) LOCAL -5 FRAME (LREF -5 PUSH LREF 1 PUSH GREF assoc APPLY 2) LOCAL -6 LREF -6 TEST (FRAME (FRAME (LREF -6 PUSH GREF cdr APPLY 1) PUSH LREF 2 PUSH GREF cons APPLY 2) PUSH LREF -6 PUSH GREF set-cdr! TAPPLY 2) FRAME (LREF -5 PUSH FRAME (LREF 2 PUSH GREF list APPLY 1) PUSH LREF 1 PUSH GREF acons APPLY 3) PUSH LREF -3 PUSH GREF scope-sets-set! TAPPLY 2)) GREF nil . #0#) VOID RET) DEF register-set! HALT)
(CLOSE 1 0 (ADDSP 3 GREF nil LOCAL -2 CONST 0 LOCAL -4 LREF 0 LOCAL -3 . #0=(FRAME (LREF -3 PUSH GREF scope-block-top? APPLY 1) TEST (FRAME (FRAME (LREF -3 PUSH GREF scope-work-size APPLY 1) PUSH LREF -4 PUSH GREF > APPLY 2) TEST (LREF -4 PUSH LREF -3 PUSH GREF scope-work-size-set! TAPPLY 2) VOID RET) FRAME (FRAME (FRAME (LREF -3 PUSH GREF scope-local-infos APPLY 1) PUSH GREF length APPLY 1) PUSH LREF -4 PUSH GREF + APPLY 2) PUSH FRAME (LREF -3 PUSH GREF scope-outer-scope APPLY 1) PUSH LOOP 1 2 . #0#)) DEF calc-scope-work-size HALT)
(CLOSE 4 0 (LREF 3 PUSH LREF 2 PUSH FRAME (GREF nil PUSH GREF nil PUSH GREF cons APPLY 2) PUSH LREF 0 PUSH CONST :LAMBDA PUSH GREF list TAPPLY 5) DEF create-lambda-node HALT)
(CLOSE 1 0 (CONST :LAMBDA PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF eq? TAPPLY 2) DEF lambda-node? HALT)
(GREF cadr DEF lambda-scope-get HALT)
(GREF caddr DEF lambda-body-slot-get HALT)
(GREF cadddr DEF lambda-varnum-get HALT)
(CLOSE 1 0 (CONST 4 PUSH LREF 0 PUSH GREF elt TAPPLY 2) DEF lambda-body-node-get HALT)
(CLOSE 2 0 (LREF 1 PUSH FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF set-car! TAPPLY 2) DEF lambda-scope-set! HALT)
(CLOSE 3 0 (ADDSP 2 LREF 0 LOCAL -2 FRAME (LREF -2 PUSH GREF car APPLY 1) LOCAL -3 FRAME (CONST :CONST PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 2 PUSH CLOSE 1 1 (FREF 0 PUSH LREF 0 PUSH CONST CONST PUSH GREF list* TAPPLY 3) PUSH GREF apply TAPPLY 2) FRAME (CONST :VOID PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 2 PUSH CLOSE 0 1 (FREF 0 PUSH CONST VOID PUSH GREF list* TAPPLY 2) PUSH GREF apply TAPPLY 2) FRAME (CONST :REF PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 2 PUSH LREF 1 PUSH CLOSE 1 2 (ADDSP 3 FRAME (LREF 0 PUSH FREF 0 PUSH GREF scope-local-has? APPLY 2) LOCAL -2 LREF -2 TEST (LREF -2 LOCAL -3 LREF -3 PUSH CONST LREF PUSH VALS 2 . #2=(RECV 0 2 FRAME (FRAME (CONST GREF PUSH LREF -2 PUSH GREF eq? APPLY 2) PUSH GREF not APPLY 1) TEST (FRAME (LREF 0 PUSH FREF 0 PUSH GREF var-is-set? APPLY 2) . #1=(TEST (FRAME (FREF 1 PUSH CONST UNBOX PUSH GREF list* APPLY 2) . #0=(PUSH LREF -3 PUSH LREF -2 PUSH GREF list* TAPPLY 3)) FREF 1 . #0#)) CONST nil . #1#)) FRAME (LREF 0 PUSH FREF 0 PUSH GREF scope-frees-has? APPLY 2) LOCAL -3 LREF -3 TEST (LREF -3 LOCAL -4 LREF -4 PUSH CONST FREF PUSH VALS 2 . #2#) LREF 0 PUSH CONST GREF PUSH VALS 2 . #2#) PUSH GREF apply TAPPLY 2) FRAME (CONST :SET PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 2 PUSH LREF 1 PUSH CLOSE 2 2 (FREF 1 PUSH FREF 0 PUSH LREF 1 PUSH LREF 0 PUSH GREF compile-set! TAPPLY 4) PUSH GREF apply TAPPLY 2) FRAME (CONST :DEF PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 2 PUSH LREF 1 PUSH CLOSE 2 2 (FRAME (FREF 1 PUSH LREF 0 PUSH CONST DEF PUSH GREF list* APPLY 3) PUSH FREF 0 PUSH LREF 1 PUSH GREF compile-recur TAPPLY 3) PUSH GREF apply TAPPLY 2) FRAME (CONST :IF PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 2 PUSH LREF 1 PUSH CLOSE 3 2 (FRAME (FRAME (FREF 1 PUSH FREF 0 PUSH LREF 2 PUSH GREF compile-recur APPLY 3) PUSH FRAME (FREF 1 PUSH FREF 0 PUSH LREF 1 PUSH GREF compile-recur APPLY 3) PUSH CONST TEST PUSH GREF list* APPLY 3) PUSH FREF 0 PUSH LREF 0 PUSH GREF compile-recur TAPPLY 3) PUSH GREF apply TAPPLY 2) FRAME (CONST :LAMBDA PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 2 PUSH LREF 1 PUSH CLOSE 4 2 (ADDSP 2 FRAME (LREF 0 PUSH GREF scope-frees APPLY 1) LOCAL -2 FRAME (FRAME (FRAME (CONST RET PUSH GREF list APPLY 1) PUSH LREF 0 PUSH LREF 3 PUSH FRAME (LREF 0 PUSH GREF scope-local-infos APPLY 1) PUSH GREF compile-body APPLY 4) PUSH LREF 1 PUSH GREF copy-pair! APPLY 2) FRAME (LREF 0 PUSH GREF scope-work-size APPLY 1) LOCAL -3 FRAME (FREF 1 PUSH FRAME (CONST 0 PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (LREF 1 . #3=(PUSH FRAME (LREF -2 PUSH GREF length APPLY 1) PUSH LREF 2 PUSH CONST CLOSE PUSH GREF list* APPLY 5)) FRAME (LREF 1 PUSH LREF -3 PUSH CONST ADDSP PUSH GREF list* APPLY 3) . #3#) PUSH FREF 0 PUSH LREF -2 PUSH GREF collect-free TAPPLY 3) PUSH GREF apply TAPPLY 2) FRAME (CONST :INVOKE PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 1 PUSH LREF 2 PUSH CLOSE 3 2 (ADDSP 3 FRAME (LREF 0 PUSH GREF scope-frees APPLY 1) LOCAL -4 FRAME (LREF 0 PUSH GREF scope-local-infos APPLY 1) LOCAL -3 FRAME (FREF 0 PUSH GREF tail? APPLY 1) LOCAL -2 FRAME (LREF 0 PUSH GREF calc-scope-work-size APPLY 1) FRAME (FREF 0 PUSH LREF 0 PUSH LREF 2 PUSH LREF -3 PUSH GREF compile-body APPLY 4) PUSH LREF 0 PUSH FREF 1 PUSH LREF 1 PUSH GREF compile-args-for-local TAPPLY 4) PUSH GREF apply TAPPLY 2) FRAME (CONST :MACRO PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 2 PUSH LREF 1 PUSH CLOSE 4 2 (ADDSP 4 FRAME (FRAME (CONST RET PUSH GREF list APPLY 1) PUSH LREF 0 PUSH LREF 3 PUSH FRAME (LREF 0 PUSH GREF scope-local-infos APPLY 1) PUSH GREF compile-body APPLY 4) LOCAL -4 FRAME (LREF 0 PUSH GREF scope-frees APPLY 1) LOCAL -3 FRAME (LREF 0 PUSH GREF scope-local-infos APPLY 1) LOCAL -2 FRAME (LREF 0 PUSH GREF scope-work-size APPLY 1) LOCAL -5 FRAME (FREF 1 PUSH FRAME (CONST 0 PUSH LREF -5 PUSH GREF eq? APPLY 2) TEST (LREF -4 . #4=(PUSH FRAME (LREF -3 PUSH GREF length APPLY 1) PUSH LREF 2 PUSH LREF 1 PUSH CONST MACRO PUSH GREF list* APPLY 6)) FRAME (LREF -4 PUSH LREF -5 PUSH CONST ADDSP PUSH GREF list* APPLY 3) . #4#) PUSH FREF 0 PUSH LREF -3 PUSH GREF collect-free TAPPLY 3) PUSH GREF apply TAPPLY 2) FRAME (CONST :APPLY PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 2 PUSH LREF 1 PUSH CLOSE 3 2 (FREF 1 PUSH FREF 0 PUSH LREF 0 PUSH LREF 2 PUSH LREF 1 PUSH GREF compile-apply TAPPLY 5) PUSH GREF apply TAPPLY 2) FRAME (CONST :CONTI PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 2 PUSH LREF 1 PUSH CLOSE 1 2 (FREF 1 PUSH FREF 0 PUSH LREF 0 PUSH GREF compile-conti TAPPLY 3) PUSH GREF apply TAPPLY 2) FRAME (CONST :CONTI-DIRECT PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 2 PUSH LREF 1 PUSH CLOSE 2 2 (FRAME (LREF 0 PUSH GREF calc-scope-work-size APPLY 1) FREF 1 PUSH FREF 0 PUSH LREF 1 PUSH LREF 0 PUSH GREF compile-conti-direct TAPPLY 4) PUSH GREF apply TAPPLY 2) FRAME (CONST :VALS PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 2 PUSH LREF 1 PUSH CLOSE 1 2 (ADDSP 1 FRAME (LREF 0 PUSH GREF length APPLY 1) LOCAL -2 FRAME (CONST 0 PUSH LREF -2 PUSH GREF eq? APPLY 2) TEST (FREF 1 PUSH CONST VOID PUSH GREF list* TAPPLY 2) FRAME (FREF 1 PUSH LREF -2 PUSH CONST VALS PUSH GREF list* APPLY 3) PUSH FREF 0 PUSH LREF 0 PUSH GREF compile-args TAPPLY 3) PUSH GREF apply TAPPLY 2) FRAME (CONST :RECV PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 1 PUSH LREF 2 PUSH CLOSE 4 2 (ADDSP 2 FRAME (LREF 0 PUSH GREF calc-scope-work-size APPLY 1) FRAME (LREF 0 PUSH GREF scope-frees APPLY 1) LOCAL -3 FRAME (FREF 0 PUSH GREF tail? APPLY 1) LOCAL -2 FRAME (FRAME (FREF 0 PUSH LREF 0 PUSH LREF 3 PUSH FRAME (LREF 0 PUSH GREF scope-local-infos APPLY 1) PUSH GREF compile-body APPLY 4) PUSH LREF 1 PUSH FRAME (LREF 0 PUSH GREF scope-upper-work-size APPLY 1) PUSH CONST RECV PUSH GREF list* APPLY 4) PUSH FREF 1 PUSH LREF 2 PUSH GREF compile-recur TAPPLY 3) PUSH GREF apply TAPPLY 2) LREF 0 PUSH CONST "Unknown [%@]" PUSH GREF compile-error TAPPLY 2) DEF compile-recur HALT)
(CLOSE 2 0 (ADDSP 3 FRAME (LREF 1 PUSH LREF 0 PUSH GREF get-var-info APPLY 2) RECV 0 2 LREF -2 TEST (FRAME (LREF -2 PUSH GREF var-info-flag-get APPLY 1) LOCAL -4 FRAME (FRAME (FRAME (GREF VAR-CALL-IN-BASE2 PUSH GREF VAR-CALL-OTHER PUSH GREF VAR-ARG PUSH GREF logior APPLY 3) PUSH LREF -4 PUSH GREF bit? APPLY 2) PUSH GREF not APPLY 1) TEST (GREF VAR-CALL-IN-BASE1 PUSH LREF -4 PUSH GREF bit? TAPPLY 2) CONST nil . #0=(RET)) CONST nil . #0#) DEF can-eliminate-lambda-node? HALT)
(CLOSE 2 0 (ADDSP 2 LREF 0 LOCAL -2 FRAME (LREF -2 PUSH GREF car APPLY 1) LOCAL -3 FRAME (CONST :LAMBDA PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 1 PUSH CLOSE 5 1 (FREF 0 PUSH LREF 0 PUSH GREF scope-outer-scope-set! TAPPLY 2) PUSH GREF apply TAPPLY 2) FRAME (CONST :INVOKE PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 1 PUSH CLOSE 3 1 (FREF 0 PUSH LREF 0 PUSH GREF scope-outer-scope-set! TAPPLY 2) PUSH GREF apply TAPPLY 2) FRAME (CONST :RECV PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 1 PUSH CLOSE 4 1 (FREF 0 PUSH LREF 0 PUSH GREF scope-outer-scope-set! TAPPLY 2) PUSH GREF apply TAPPLY 2) FRAME (CONST :SET PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 1 PUSH CLOSE 2 1 (FREF 0 PUSH LREF 1 PUSH GREF replace-outer-scope! TAPPLY 2) PUSH GREF apply TAPPLY 2) FRAME (CONST :DEF PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 1 PUSH CLOSE 2 1 (FREF 0 PUSH LREF 1 PUSH GREF replace-outer-scope! TAPPLY 2) PUSH GREF apply TAPPLY 2) FRAME (CONST :IF PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 1 PUSH CLOSE 3 1 (FRAME (FREF 0 PUSH LREF 0 PUSH GREF replace-outer-scope! APPLY 2) FRAME (FREF 0 PUSH LREF 1 PUSH GREF replace-outer-scope! APPLY 2) FREF 0 PUSH LREF 2 PUSH GREF replace-outer-scope! TAPPLY 2) PUSH GREF apply TAPPLY 2) FRAME (CONST :APPLY PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 1 PUSH CLOSE 3 1 (FRAME (FREF 0 PUSH LREF 1 PUSH GREF replace-outer-scope! APPLY 2) FREF 0 PUSH LREF 2 PUSH GREF replace-body-scope! TAPPLY 2) PUSH GREF apply TAPPLY 2) FRAME (CONST :CONTI PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 1 PUSH CLOSE 1 1 (FREF 0 PUSH LREF 0 PUSH GREF replace-outer-scope! TAPPLY 2) PUSH GREF apply TAPPLY 2) FRAME (CONST :CONTI-DIRECT PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 1 PUSH CLOSE 2 1 (FREF 0 PUSH LREF 1 PUSH GREF replace-body-scope! TAPPLY 2) PUSH GREF apply TAPPLY 2) FRAME (CONST :VALS PUSH LREF -3 PUSH GREF eq? APPLY 2) TEST (FRAME (LREF -2 PUSH GREF cdr APPLY 1) PUSH LREF 1 PUSH CLOSE 1 1 (FREF 0 PUSH LREF 0 PUSH GREF replace-body-scope! TAPPLY 2) PUSH GREF apply TAPPLY 2) GREF nil RET) DEF replace-outer-scope! HALT)
(CLOSE 2 0 (FRAME (LREF 1 PUSH LREF 0 PUSH GREF lambda-scope-set! APPLY 2) LREF 1 PUSH FRAME (LREF 0 PUSH GREF lambda-body-node-get APPLY 1) PUSH GREF replace-body-scope! TAPPLY 2) DEF replace-lambda-scope! HALT)
(CLOSE 2 0 (ADDSP 3 GREF nil LOCAL -2 LREF 0 LOCAL -3 . #0=(FRAME (LREF -3 PUSH GREF pair? APPLY 1) TEST (FRAME (LREF -3 PUSH GREF car APPLY 1) LOCAL -4 FRAME (LREF 1 PUSH LREF -4 PUSH GREF replace-outer-scope! APPLY 2) FRAME (LREF -3 PUSH GREF cdr APPLY 1) PUSH LOOP 1 1 . #0#) VOID RET)) DEF replace-body-scope! HALT)
(CLOSE 5 0 (ADDSP 4 FRAME (LREF 3 PUSH LREF 0 PUSH GREF apply-func-can-be-loop? APPLY 2) LOCAL -2 LREF -2 TEST (FRAME (GREF VAR-CALL-IN-BASE1 PUSH LREF 2 PUSH GREF bit? APPLY 2) TEST (FRAME (FRAME (LREF 0 PUSH GREF cadr APPLY 1) PUSH LREF 3 PUSH GREF can-eliminate-lambda-node? APPLY 2) . #2=(TEST (LREF 4 PUSH LREF 3 PUSH LREF 1 PUSH LREF 0 PUSH LREF -2 PUSH GREF compile-apply-loop TAPPLY 5) LREF -2 TEST (FRAME (GREF VAR-SELF-TAIL-RECUR PUSH LREF 2 PUSH GREF bit? APPLY 2) . #1=(TEST (LREF 3 PUSH LREF 1 PUSH LREF 0 PUSH LREF -2 PUSH GREF compile-apply-self-recur TAPPLY 4) FRAME (FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH CONST :REF PUSH GREF eq? APPLY 2) TEST (FRAME (FRAME (LREF 0 PUSH GREF cadr APPLY 1) PUSH LREF 3 PUSH GREF get-var-info APPLY 2) RECV 1 2 LREF -3 TEST (FRAME (LREF -3 PUSH GREF var-info-flag-get APPLY 1) LOCAL -5 FRAME (GREF VAR-CONTI PUSH LREF -5 PUSH GREF bit? APPLY 2) TEST (FRAME (FRAME (FRAME (GREF VAR-SET PUSH GREF VAR-ARG PUSH GREF logior APPLY 2) PUSH LREF -5 PUSH GREF bit? APPLY 2) PUSH GREF not APPLY 1) . #0=(LOCAL -3 LREF -3 TEST (LREF 3 PUSH LREF 1 PUSH LREF 0 PUSH GREF compile-apply-conti TAPPLY 3) LREF 4 PUSH LREF 3 PUSH LREF 1 PUSH LREF 0 PUSH GREF compile-apply-normal TAPPLY 4)) CONST nil . #0#) CONST nil . #0#) CONST nil . #0#)) CONST nil . #1#)) CONST nil . #2#) CONST nil . #2#) DEF compile-apply HALT)
(CLOSE 3 0 (ADDSP 2 FRAME (LREF 1 PUSH GREF length APPLY 1) LOCAL -2 FRAME (CONST 1 PUSH LREF -2 PUSH GREF > APPLY 2) TEST (FRAME (FRAME (LREF 0 PUSH GREF cadr APPLY 1) PUSH CONST "Too many argument for `%@`" PUSH GREF compile-error APPLY 2) . #0=(FRAME (FRAME (CONST LONGJMP PUSH GREF list APPLY 1) PUSH LREF 2 PUSH LREF 0 PUSH GREF compile-recur APPLY 3) LOCAL -3 FRAME (CONST 0 PUSH LREF -2 PUSH GREF eq? APPLY 2) TEST (LREF -3 PUSH CONST PUSH PUSH CONST NIL PUSH GREF list* TAPPLY 3) LREF -3 PUSH LREF 2 PUSH LREF 1 PUSH GREF compile-args TAPPLY 3)) VOID . #0#) DEF compile-apply-conti HALT)
(CLOSE 4 0 (ADDSP 3 FRAME (LREF 1 PUSH GREF length APPLY 1) LOCAL -3 FRAME (LREF 3 PUSH GREF tail? APPLY 1) LOCAL -2 FRAME (FRAME (LREF -2 TEST (FRAME (LREF -3 PUSH CONST TAPPLY PUSH GREF list APPLY 2) . #0=(PUSH LREF 2 PUSH LREF 0 PUSH GREF compile-recur APPLY 3)) FRAME (LREF -3 PUSH CONST APPLY PUSH GREF list APPLY 2) . #0#) PUSH LREF 2 PUSH LREF 1 PUSH GREF compile-args APPLY 3) LOCAL -4 LREF -2 TEST (LREF -4 RET) LREF 3 PUSH LREF -4 PUSH CONST FRAME PUSH GREF list* TAPPLY 3) DEF compile-apply-normal HALT)
(CLOSE 5 0 (ADDSP 7 FRAME (LREF 0 PUSH GREF lambda-scope-get APPLY 1) LOCAL -2 FRAME (LREF -2 PUSH GREF scope-local-infos APPLY 1) LOCAL -3 FRAME (LREF 2 PUSH GREF length APPLY 1) LOCAL -8 FRAME (LREF 4 PUSH GREF tail? APPLY 1) LOCAL -7 FRAME (LREF 0 PUSH GREF lambda-body-slot-get APPLY 1) LOCAL -6 FRAME (LREF 0 PUSH GREF lambda-varnum-get APPLY 1) LOCAL -5 FRAME (LREF 3 PUSH LREF -3 PUSH GREF expand-scope2 APPLY 2) LOCAL -4 FRAME (LREF -5 PUSH GREF pair? APPLY 1) TEST (FRAME (CONST "Not implemented: rest param for loop" PUSH GREF compile-error APPLY 1) . #1=(FRAME (LREF -5 PUSH LREF -8 PUSH GREF eq? APPLY 2) TEST (VOID . #0=(FRAME (LREF -4 PUSH LREF 0 PUSH GREF replace-lambda-scope! APPLY 2) FRAME (FRAME (LREF 4 PUSH LREF -4 PUSH FRAME (LREF 0 PUSH GREF lambda-body-node-get APPLY 1) PUSH LREF -3 PUSH GREF compile-body APPLY 4) PUSH LREF -6 PUSH GREF copy-pair! APPLY 2) FRAME (LREF -4 PUSH GREF calc-scope-work-size APPLY 1) LREF -6 PUSH LREF -4 PUSH LREF 3 PUSH LREF 2 PUSH GREF compile-args-for-local TAPPLY 4)) FRAME (LREF -8 PUSH LREF -5 PUSH FRAME (LREF 1 PUSH GREF cadr APPLY 1) PUSH CONST "Illegal argnum, `%@` requires %@, but %@" PUSH GREF compile-error APPLY 4) . #0#)) VOID . #1#) DEF compile-apply-loop HALT)
(CLOSE 4 0 (ADDSP 3 FRAME (FRAME (LREF 1 PUSH GREF cadr APPLY 1) PUSH LREF 3 PUSH GREF can-eliminate-lambda-node? APPLY 2) TEST (FRAME (FRAME (LREF 0 PUSH GREF lambda-scope-get APPLY 1) PUSH GREF scope-upper-work-size APPLY 1) . #2=(LOCAL -4 FRAME (LREF 0 PUSH GREF lambda-varnum-get APPLY 1) LOCAL -3 FRAME (LREF 2 PUSH GREF length APPLY 1) LOCAL -2 FRAME (LREF -3 PUSH GREF pair? APPLY 1) TEST (FRAME (CONST "Not implemented: rest param for loop" PUSH GREF compile-error APPLY 1) . #1=(FRAME (LREF -3 PUSH LREF -2 PUSH GREF eq? APPLY 2) TEST (VOID . #0=(FRAME (FRAME (LREF 0 PUSH GREF lambda-body-slot-get APPLY 1) PUSH LREF -2 PUSH LREF -4 PUSH CONST LOOP PUSH GREF list* APPLY 4) PUSH LREF 3 PUSH LREF 2 PUSH GREF compile-args TAPPLY 3)) FRAME (LREF -2 PUSH LREF -3 PUSH FRAME (LREF 1 PUSH GREF cadr APPLY 1) PUSH CONST "Illegal argnum, `%@` requires %@, but %@" PUSH GREF compile-error APPLY 4) . #0#)) VOID . #1#)) CONST 0 . #2#) DEF compile-apply-self-recur HALT)
(CLOSE 4 0 (ADDSP 3 FRAME (LREF 1 PUSH GREF lambda-node? APPLY 1) TEST (FRAME (LREF 0 PUSH LREF 2 PUSH GREF can-eliminate-lambda-node? APPLY 2) . #1=(TEST (LREF 3 RET) FRAME (LREF 0 PUSH LREF 2 PUSH GREF scope-local-has? APPLY 2) LOCAL -2 LREF -2 TEST (LREF -2 LOCAL -3 LREF -3 PUSH CONST LSET PUSH VALS 2 . #0=(RECV 0 2 FRAME (LREF 3 PUSH LREF -3 PUSH LREF -2 PUSH GREF list* APPLY 3) PUSH LREF 2 PUSH LREF 1 PUSH GREF compile-recur TAPPLY 3)) FRAME (LREF 0 PUSH LREF 2 PUSH GREF scope-frees-has? APPLY 2) LOCAL -3 LREF -3 TEST (LREF -3 LOCAL -4 LREF -4 PUSH CONST FSET PUSH VALS 2 . #0#) LREF 0 PUSH CONST GSET PUSH VALS 2 . #0#)) CONST nil . #1#) DEF compile-set! HALT)
(CLOSE 3 0 (ADDSP 2 FRAME (LREF 2 PUSH GREF tail? APPLY 1) LOCAL -2 FRAME (FRAME (LREF -2 TEST (CONST (TAPPLY 1) . #0=(PUSH LREF 1 PUSH LREF 0 PUSH GREF compile-recur APPLY 3)) CONST (APPLY 1) . #0#) PUSH CONST PUSH PUSH LREF -2 PUSH CONST CONTI PUSH GREF list* APPLY 4) LOCAL -3 LREF -2 TEST (LREF -3 RET) LREF 2 PUSH LREF -3 PUSH CONST FRAME PUSH GREF list* TAPPLY 3) DEF compile-conti HALT)
(CLOSE 4 0 (ADDSP 6 FRAME (LREF 0 PUSH GREF scope-local-infos APPLY 1) LOCAL -2 FRAME (FRAME (LREF -2 PUSH GREF caar APPLY 1) PUSH LREF 0 PUSH GREF get-var-info APPLY 2) RECV 1 2 FRAME (LREF -3 PUSH GREF var-info-flag-get APPLY 1) LOCAL -4 FRAME (LREF 3 PUSH GREF tail? APPLY 1) LOCAL -3 FRAME (FRAME (GREF VAR-SET PUSH GREF VAR-ARG PUSH GREF logior APPLY 2) PUSH LREF -4 PUSH GREF bit? APPLY 2) TEST (FRAME (FRAME (LREF -3 TEST (LREF 3 . #0=(PUSH LREF 0 PUSH LREF 1 PUSH LREF -2 PUSH GREF compile-body APPLY 4)) FRAME (CONST UNFRAME PUSH GREF list APPLY 1) . #0#) PUSH FRAME (FRAME (LREF -2 PUSH GREF caar APPLY 1) PUSH LREF 0 PUSH GREF scope-local-has? APPLY 2) PUSH CONST LOCAL PUSH LREF -3 PUSH CONST CONTI PUSH GREF list* APPLY 5) LOCAL -5 LREF -3 TEST (LREF -5 RET) LREF 3 PUSH LREF -5 PUSH CONST FRAME PUSH GREF list* TAPPLY 3) FRAME (FRAME (GREF VAR-SELF-TAIL-RECUR PUSH GREF VAR-CALL-OTHER PUSH GREF VAR-CALL-IN-BASE1 PUSH GREF logior APPLY 3) PUSH LREF -4 PUSH GREF bit? APPLY 2) TEST (FRAME (GREF gensym APPLY 0) LOCAL -5 FRAME (FRAME (FRAME (GREF VAR-ARG PUSH LREF -5 PUSH GREF cons APPLY 2) PUSH FRAME (GREF VAR-ARG PUSH LREF -5 PUSH GREF cons APPLY 2) PUSH FRAME (GREF VAR-ARG PUSH LREF -5 PUSH GREF cons APPLY 2) PUSH GREF list APPLY 3) PUSH FRAME (LREF 0 PUSH GREF scope-local-infos APPLY 1) PUSH GREF append APPLY 2) LOCAL -6 FRAME (LREF 2 PUSH LREF -6 PUSH GREF expand-scope2 APPLY 2) LOCAL -7 FRAME (LREF -7 PUSH LREF 1 PUSH GREF replace-body-scope! APPLY 2) FRAME (LREF -7 PUSH GREF calc-scope-work-size APPLY 1) LREF 3 PUSH FRAME (LREF 3 PUSH LREF -7 PUSH LREF 1 PUSH LREF -2 PUSH GREF compile-body APPLY 4) PUSH FRAME (LREF -7 PUSH GREF scope-upper-work-size APPLY 1) PUSH CONST SETJMP PUSH GREF list* TAPPLY 4) FRAME (LREF 2 PUSH LREF 1 PUSH GREF replace-body-scope! APPLY 2) LREF 3 PUSH LREF 2 PUSH LREF 1 PUSH LREF -2 PUSH GREF compile-body TAPPLY 4) DEF compile-conti-direct HALT)
(CLOSE 4 0 (ADDSP 1 LREF 1 TEST (GREF nil LOCAL -2 BOX -2 LREF -2 PUSH LREF 2 PUSH LREF 3 PUSH CLOSE 1 3 (LREF 0 TEST (FRAME (FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH FREF 2 UNBOX APPLY 1) PUSH FREF 1 PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF compile-recur TAPPLY 3) FREF 0 RET) LSET -2 FRAME (LREF 1 PUSH LREF -2 UNBOX APPLY 1) PUSH LREF 0 PUSH LREF 2 PUSH GREF make-boxes TAPPLY 3) LREF 3 PUSH CONST VOID PUSH GREF list* TAPPLY 2) DEF compile-body HALT)
(CLOSE 3 0 (ADDSP 1 GREF nil LOCAL -2 BOX -2 LREF 0 PUSH LREF -2 PUSH LREF 2 PUSH CLOSE 1 3 (ADDSP 2 . #1=(LREF 0 TEST (FRAME (LREF 0 PUSH GREF cdr APPLY 1) LOCAL -3 FRAME (LREF 0 PUSH GREF caar APPLY 1) LOCAL -2 FRAME (LREF -2 PUSH FREF 2 PUSH GREF var-is-set? APPLY 2) TEST (FRAME (FRAME (FREF 2 PUSH LREF -2 PUSH GREF symbol-can-be-loop? APPLY 2) TEST (FRAME (LREF -2 PUSH FREF 2 PUSH GREF can-eliminate-lambda-node? APPLY 2) . #0=(PUSH GREF not APPLY 1)) CONST nil . #0#) . #2=(TEST (FRAME (LREF -3 PUSH FREF 1 UNBOX APPLY 1) PUSH FRAME (LREF -2 PUSH FREF 2 PUSH GREF scope-local-has? APPLY 2) PUSH CONST BOX PUSH GREF list* TAPPLY 3) LREF -3 PUSH LOOP 0 1 . #1#)) CONST nil . #2#) FREF 0 RET)) LSET -2 LREF 1 PUSH LREF -2 UNBOX TAPPLY 1) DEF make-boxes HALT)
(CLOSE 3 0 (LREF 0 TEST (FRAME (FRAME (LREF 2 PUSH CONST PUSH PUSH GREF list* APPLY 2) PUSH LREF 1 PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF compile-recur APPLY 3) PUSH LREF 1 PUSH FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF compile-args TAPPLY 3) LREF 2 RET) DEF compile-args HALT)
(CLOSE 4 0 (ADDSP 5 GREF nil LOCAL -2 LREF 3 LOCAL -6 FRAME (LREF 2 PUSH GREF scope-upper-work-size APPLY 1) LOCAL -5 FRAME (LREF 2 PUSH GREF scope-local-infos APPLY 1) LOCAL -4 LREF 0 LOCAL -3 . #0=(LREF -3 TEST (FRAME (FRAME (LREF -6 PUSH FRAME (FRAME (LREF -4 PUSH GREF caar APPLY 1) PUSH LREF 2 PUSH GREF scope-local-has? APPLY 2) PUSH CONST LOCAL PUSH GREF list* APPLY 3) PUSH LREF 1 PUSH FRAME (LREF -3 PUSH GREF car APPLY 1) PUSH GREF compile-recur APPLY 3) PUSH FRAME (CONST 1 PUSH LREF -5 PUSH GREF + APPLY 2) PUSH FRAME (LREF -4 PUSH GREF cdr APPLY 1) PUSH FRAME (LREF -3 PUSH GREF cdr APPLY 1) PUSH LOOP 1 4 . #0#) LREF -6 RET)) DEF compile-args-for-local HALT)
(CLOSE 3 0 (ADDSP 3 LREF 0 TEST (FRAME (LREF 0 PUSH GREF car APPLY 1) LOCAL -2 FRAME (LREF -2 PUSH LREF 1 PUSH GREF scope-local-has? APPLY 2) LOCAL -3 LREF -3 TEST (FRAME (LREF 2 PUSH CONST PUSH PUSH LREF -3 PUSH CONST LREF PUSH GREF list* APPLY 4) . #0=(PUSH LREF 1 PUSH FRAME (LREF 0 PUSH GREF cdr APPLY 1) PUSH GREF collect-free TAPPLY 3)) FRAME (LREF -2 PUSH LREF 1 PUSH GREF scope-frees-has? APPLY 2) LOCAL -4 LREF -4 TEST (FRAME (LREF 2 PUSH CONST PUSH PUSH LREF -4 PUSH CONST FREF PUSH GREF list* APPLY 4) . #0#) FRAME (LREF 1 PUSH LREF -2 PUSH CONST "something wrong in collect-free [%@](%@)" PUSH GREF compile-error APPLY 3) . #0#) LREF 2 RET) DEF collect-free HALT)
(CLOSE 2 0 (FRAME (CONST :REF PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF eq? APPLY 2) TEST (LREF 1 PUSH FRAME (LREF 0 PUSH GREF cadr APPLY 1) PUSH GREF symbol-can-be-loop? TAPPLY 2) CONST nil RET) DEF apply-func-can-be-loop? HALT)
(CLOSE 2 0 (ADDSP 2 FRAME (LREF 0 PUSH LREF 1 PUSH GREF var-is-set? APPLY 2) LOCAL -2 LREF -2 TEST (FRAME (LREF -2 PUSH GREF single? APPLY 1) TEST (FRAME (LREF -2 PUSH GREF car APPLY 1) LOCAL -3 FRAME (LREF -3 PUSH GREF lambda-node? APPLY 1) TEST (LREF -3 . #0=(RET)) CONST nil . #0#) CONST nil . #0#) VOID . #0#) DEF symbol-can-be-loop? HALT)
(CLOSE 1 0 (CONST RET PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF eq? TAPPLY 2) DEF tail? HALT)
(MACRO declaim (0 -1) 0 (FRAME (LREF 0 PUSH CLOSE 1 0 (ADDSP 4 FRAME (LREF 0 PUSH GREF pair? APPLY 1) TEST (FRAME (LREF 0 PUSH GREF car APPLY 1) LOCAL -2 FRAME (CONST inline PUSH LREF -2 PUSH GREF eq? APPLY 2) TEST (GREF nil LOCAL -3 FRAME (LREF 0 PUSH GREF cdr APPLY 1) LOCAL -4 . #0=(FRAME (LREF -4 PUSH GREF pair? APPLY 1) TEST (FRAME (LREF -4 PUSH GREF car APPLY 1) LOCAL -5 FRAME (LREF -5 PUSH GREF declaim-inline APPLY 1) FRAME (LREF -4 PUSH GREF cdr APPLY 1) PUSH LOOP 2 1 . #0#) VOID CONST (values) . #1=(RET))) GREF nil . #1#) VOID . #1#) PUSH GREF map APPLY 2) PUSH CONST do PUSH GREF list* TAPPLY 2) HALT)
(CONST 0 PUSH ADDSP 1 FRAME (GREF table APPLY 0) LOCAL -2 LREF -2 PUSH CLOSE 1 1 (GREF t PUSH LREF 0 PUSH FREF 0 PUSH GREF table-put! TAPPLY 3) DEF declaim-inline LREF -2 PUSH CLOSE 1 1 (FRAME (LREF 0 PUSH GREF symbol? APPLY 1) TEST (LREF 0 PUSH FREF 0 PUSH GREF table-exists? TAPPLY 2) CONST nil RET) DEF inline-function? LREF -2 PUSH CLOSE 2 1 (LREF 1 PUSH LREF 0 PUSH FREF 0 PUSH GREF table-put! TAPPLY 3) DEF register-inline-function LREF -2 PUSH CLOSE 1 1 (LREF 0 PUSH FREF 0 PUSH GREF table-get TAPPLY 2) DEF get-inline-function-body ADDSP -2 HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF pair? APPLY 1) TEST (CONST ^ PUSH FRAME (LREF 0 PUSH GREF car APPLY 1) PUSH GREF eq? TAPPLY 2) CONST nil RET) DEF lambda-expression? HALT)
(CONST 0 PUSH ADDSP 1 GREF nil LOCAL -2 BOX -2 LREF -2 PUSH CLOSE (0 -1) 1 (FREF 0 UNBOX TEST (FRAME (LREF 0 PUSH GREF *stderr* PUSH GREF format PUSH GREF apply APPLY 3) FRAME (GREF *stderr* PUSH CONST "\n" PUSH GREF display APPLY 2) GREF nil PUSH FREF 0 UNBOX TAPPLY 1) FRAME (LREF 0 PUSH GREF nil PUSH GREF format PUSH GREF apply APPLY 3) PUSH GREF error TAPPLY 1) DEF compile-error LREF -2 PUSH CLOSE 1 1 (ADDSP 6 CONTI t LOCAL -2 LREF -2 FSET 0 FRAME (GREF nil PUSH CONST nil PUSH GREF create-scope APPLY 2) LOCAL -3 FRAME (GREF nil PUSH LREF -3 PUSH LREF 0 PUSH GREF traverse APPLY 3) LOCAL -4 FRAME (CONST HALT PUSH GREF list APPLY 1) LOCAL -5 FRAME (LREF -5 PUSH LREF -3 PUSH LREF -4 PUSH GREF compile-recur APPLY 3) LOCAL -6 FRAME (LREF -3 PUSH GREF scope-work-size APPLY 1) LOCAL -7 GREF nil FSET 0 FRAME (CONST 0 PUSH LREF -7 PUSH GREF eq? APPLY 2) TEST (LREF -6 RET) FRAME (FRAME (CONST HALT PUSH FRAME (LREF -7 PUSH CONST -1 PUSH GREF - APPLY 2) PUSH CONST ADDSP PUSH GREF list APPLY 3) PUSH LREF -5 PUSH GREF copy-pair! APPLY 2) LREF -6 PUSH LREF -7 PUSH CONST ADDSP PUSH CONST PUSH PUSH CONST 0 PUSH CONST CONST PUSH GREF list* TAPPLY 6) DEF compile ADDSP -2 HALT)
(CLOSE 1 0 (FRAME (LREF 0 PUSH GREF compile APPLY 1) PUSH GREF run-binary TAPPLY 1) DEF eval HALT)
(CLOSE (0 -1) 0 (FRAME (GREF *stderr* PUSH LREF 0 PUSH GREF write/ss APPLY 2) GREF *stderr* PUSH CONST "\n" PUSH GREF display TAPPLY 2) DEF debug/ss HALT)
